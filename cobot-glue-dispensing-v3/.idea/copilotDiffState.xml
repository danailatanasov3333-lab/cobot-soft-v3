<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="CopilotDiffPersistence">
    <option name="pendingDiffs">
      <map>
        <entry key="$PROJECT_DIR$/tests/compare_contours/alignement/test_align_single_contour.py">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/tests/compare_contours/alignement/test_align_single_contour.py" />
              <option name="originalContent" value="import numpy as np&#10;import pytest&#10;&#10;&#10;from backend.system.contour_matching.alignment.contour_aligner import align_single_contour&#10;from backend.system.contour_matching.matching_config import REFINEMENT_THRESHOLD&#10;from compare_contours.testShapeGenerator import create_rectangle_contour&#10;from modules.shared.shared.ContourStandartized import Contour&#10;&#10;&#10;# --- Fixtures for basic contours ---&#10;@pytest.fixture&#10;def square_contour():&#10;&#10;    return Contour(create_rectangle_contour())&#10;&#10;@pytest.fixture&#10;def reference_square():&#10;&#10;    return create_rectangle_contour(center=(500, 400))  # Offset reference&#10;&#10;@pytest.fixture&#10;def spray_contours(square_contour):&#10;    return [square_contour]&#10;&#10;@pytest.fixture&#10;def spray_fills(square_contour):&#10;    return [square_contour]&#10;&#10;# --- Unit tests ---&#10;def test_initial_rotation_translation(square_contour, reference_square):&#10;    &quot;&quot;&quot;Test initial rotation and translation applied.&quot;&quot;&quot;&#10;    initial_centroid = square_contour.getCentroid()&#10;    align_single_contour(square_contour, reference_square, rotation_diff=45.0, translation_diff=(10, 20), refine=False)&#10;    final_centroid = square_contour.getCentroid()&#10;&#10;    # Centroid should move by translation&#10;    assert np.allclose(final_centroid, np.array(initial_centroid) + np.array([10, 20]), atol=1e-5)&#10;&#10;def test_refinement_applied(square_contour, reference_square):&#10;    &quot;&quot;&quot;Test mask-based refinement is applied.&quot;&quot;&quot;&#10;    # Patch _refine_alignment_with_mask to return known rotation&#10;    from unittest.mock import patch&#10;    # patch the function where it is looked up in the runtime module&#10;    with patch(&quot;backend.system.contour_matching.alignment.contour_aligner._refine_alignment_with_mask&quot;) as mock_refine:&#10;        mock_refine.return_value = (30.0, 1.0)  # Large enough to apply&#10;        initial_centroid = square_contour.getCentroid()&#10;        align_single_contour(square_contour, reference_square, refine=True)&#10;&#10;        # Check that _refine_alignment_with_mask was called&#10;        mock_refine.assert_called_once()&#10;        # Final rotation moves centroid back (rotation about centroid doesn't move centroid)&#10;        assert np.allclose(square_contour.getCentroid(), initial_centroid, atol=1e-5)&#10;&#10;def test_spray_contours_transformed(square_contour, reference_square):&#10;    &quot;&quot;&quot;Test spray contours are rotated and translated along with target.&quot;&quot;&quot;&#10;    spray = Contour(square_contour.get())  # clone&#10;    initial_centroid = spray.getCentroid()&#10;    align_single_contour(square_contour, reference_square, spray_contours=[spray], rotation_diff=15, translation_diff=(5, 5), refine=False)&#10;&#10;    # Spray centroid should be translated the same as target&#10;    expected = np.array(initial_centroid) + np.array([5, 5])&#10;    assert np.allclose(spray.getCentroid(), expected, atol=1e-5)&#10;&#10;def test_no_refinement_below_threshold(square_contour, reference_square):&#10;    &quot;&quot;&quot;Test refinement rotation below threshold does not apply.&quot;&quot;&quot;&#10;&#10;    from unittest.mock import patch&#10;&#10;    with patch(&quot;backend.system.contour_matching.alignment.contour_aligner._refine_alignment_with_mask&quot;) as mock_refine:&#10;        mock_refine.return_value = (REFINEMENT_THRESHOLD * 0.5, 1.0)&#10;        initial_centroid = square_contour.getCentroid()&#10;        align_single_contour(square_contour, reference_square, refine=True)&#10;&#10;        # Centroid should not move due to rotation below threshold&#10;        assert np.allclose(square_contour.getCentroid(), initial_centroid, atol=1e-5)&#10;" />
              <option name="updatedContent" value="import numpy as np&#10;import pytest&#10;&#10;&#10;from backend.system.contour_matching.alignment.contour_aligner import align_single_contour&#10;from backend.system.contour_matching.matching_config import REFINEMENT_THRESHOLD&#10;from compare_contours.testShapeGenerator import create_rectangle_contour&#10;from modules.shared.shared.ContourStandartized import Contour&#10;&#10;&#10;# --- Fixtures for basic contours ---&#10;@pytest.fixture&#10;def square_contour():&#10;&#10;    return Contour(create_rectangle_contour())&#10;&#10;@pytest.fixture&#10;def reference_square():&#10;&#10;    return create_rectangle_contour(center=(500, 400))  # Offset reference&#10;&#10;@pytest.fixture&#10;def spray_contours(square_contour):&#10;    return [square_contour]&#10;&#10;@pytest.fixture&#10;def spray_fills(square_contour):&#10;    return [square_contour]&#10;&#10;# --- Unit tests ---&#10;def test_initial_rotation_translation(square_contour, reference_square):&#10;    &quot;&quot;&quot;Test initial rotation and translation applied.&quot;&quot;&quot;&#10;    initial_centroid = square_contour.getCentroid()&#10;    align_single_contour(square_contour, reference_square, rotation_diff=45.0, translation_diff=(10, 20), refine=False)&#10;    final_centroid = square_contour.getCentroid()&#10;&#10;    # Centroid should move by translation&#10;    assert np.allclose(final_centroid, np.array(initial_centroid) + np.array([10, 20]), atol=1e-5)&#10;&#10;def test_refinement_applied(square_contour, reference_square):&#10;    &quot;&quot;&quot;Test mask-based refinement is applied.&quot;&quot;&quot;&#10;    # Patch _refine_alignment_with_mask to return known rotation&#10;    from unittest.mock import patch&#10;    # patch the function where it is looked up in the runtime module&#10;    with patch(&quot;backend.system.contour_matching.alignment.contour_aligner._refine_alignment_with_mask&quot;) as mock_refine:&#10;        mock_refine.return_value = (30.0, 1.0)  # Large enough to apply&#10;        initial_centroid = square_contour.getCentroid()&#10;        align_single_contour(square_contour, reference_square, refine=True)&#10;&#10;        # Check that _refine_alignment_with_mask was called&#10;        mock_refine.assert_called_once()&#10;        # Final rotation moves centroid back (rotation about centroid doesn't move centroid)&#10;        assert np.allclose(square_contour.getCentroid(), initial_centroid, atol=1e-5)&#10;&#10;def test_spray_contours_transformed(square_contour, reference_square):&#10;    &quot;&quot;&quot;Test spray contours are rotated and translated along with target.&quot;&quot;&quot;&#10;    spray = Contour(square_contour.get())  # clone&#10;    initial_centroid = spray.getCentroid()&#10;    align_single_contour(square_contour, reference_square, spray_contours=[spray], rotation_diff=15, translation_diff=(5, 5), refine=False)&#10;&#10;    # Spray centroid should be translated the same as target&#10;    expected = np.array(initial_centroid) + np.array([5, 5])&#10;    assert np.allclose(spray.getCentroid(), expected, atol=1e-5)&#10;&#10;def test_no_refinement_below_threshold(square_contour, reference_square):&#10;    &quot;&quot;&quot;Test refinement rotation below threshold does not apply.&quot;&quot;&quot;&#10;&#10;    from unittest.mock import patch&#10;&#10;    with patch(&quot;backend.system.contour_matching.alignment.contour_aligner._refine_alignment_with_mask&quot;) as mock_refine:&#10;        mock_refine.return_value = (REFINEMENT_THRESHOLD * 0.5, 1.0)&#10;        initial_centroid = square_contour.getCentroid()&#10;        align_single_contour(square_contour, reference_square, refine=True)&#10;&#10;        # Centroid should not move due to rotation below threshold&#10;        assert np.allclose(square_contour.getCentroid(), initial_centroid, atol=1e-5)" />
            </PendingDiffInfo>
          </value>
        </entry>
      </map>
    </option>
  </component>
</project>