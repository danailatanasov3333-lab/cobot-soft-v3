<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="CopilotDiffPersistence">
    <option name="pendingDiffs">
      <map>
        <entry key="$PROJECT_DIR$/src/backend/system/settings/SettingsJsonRepository.py">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/backend/system/settings/SettingsJsonRepository.py" />
              <option name="originalContent" value="import json&#10;import os&#10;import logging&#10;&#10;class SettingsRepositoryError(Exception):&#10;    &quot;&quot;&quot;Custom exception for SettingsJsonRepository errors.&quot;&quot;&quot;&#10;    pass&#10;&#10;class SettingsJsonRepository:&#10;&#10;    def __init__(self, file_path: str,settings_object):&#10;        self.file_path = file_path&#10;        self.settings_object = settings_object&#10;        self.logger = logging.getLogger(self.__class__.__name__)&#10;&#10;    def save(self):&#10;        &quot;&quot;&quot;&#10;        Persist the repository's associated settings object to its configured file path.&#10;&#10;        Uses:&#10;            self.file_path (str): target JSON file path&#10;            self.settings_object: object that implements .to_dict()&#10;        &quot;&quot;&quot;&#10;        try:&#10;            # Create the directory for the JSON file if it doesn't exist&#10;            if self.file_path:&#10;                os.makedirs(os.path.dirname(self.file_path), exist_ok=True)&#10;            else:&#10;                raise SettingsRepositoryError(&quot;File path is not set.&quot;)&#10;&#10;            settings_data = self.settings_object.to_dict()&#10;&#10;            with open(self.file_path, 'w') as f:&#10;                json.dump(settings_data, f, indent=4)&#10;            self.logger.info(f&quot;Settings saved to {self.file_path}.&quot;)&#10;&#10;        except Exception as e:&#10;            self.logger.error(f&quot;Error saving settings to {self.file_path}: {e}&quot;)&#10;            import traceback&#10;            traceback.print_exc()&#10;&#10;    def load(self):&#10;        &quot;&quot;&quot;&#10;        Load JSON from the repository's configured file path and populate the settings object.&#10;&#10;        Uses:&#10;            self.file_path (str): source JSON file path&#10;            self.settings_object: object that implements .from_dict(dict)&#10;        &quot;&quot;&quot;&#10;        try:&#10;            with open(self.file_path, 'r', encoding='utf-8') as f:&#10;                settings_data = json.load(f)&#10;&#10;                self.logger.debug(f&quot;Settings loaded from {self.file_path} Settings: {settings_data}.&quot;)&#10;&#10;&#10;            self.settings_object.from_dict(settings_data)&#10;&#10;        except (FileNotFoundError, json.JSONDecodeError) as e:&#10;            self.logger.error(f&quot;Error loading settings from {self.file_path}: {e}&quot;)&#10;            self.logger.info(f&quot;Using default values for {type(self.settings_object).__name__}.&quot;)&#10;" />
              <option name="updatedContent" value="import json&#10;import os&#10;import logging&#10;&#10;class SettingsRepositoryError(Exception):&#10;    &quot;&quot;&quot;Custom exception for SettingsJsonRepository errors.&quot;&quot;&quot;&#10;    pass&#10;&#10;class SettingsJsonRepository:&#10;&#10;    def __init__(self, file_path: str,settings_object):&#10;        self.file_path = file_path&#10;        self.settings_object = settings_object&#10;        self.logger = logging.getLogger(self.__class__.__name__)&#10;&#10;    def save(self):&#10;        &quot;&quot;&quot;&#10;        Persist the repository's associated settings object to its configured file path.&#10;&#10;        Uses:&#10;            self.file_path (str): target JSON file path&#10;            self.settings_object: object that implements .to_dict()&#10;        &quot;&quot;&quot;&#10;        try:&#10;            # Create the directory for the JSON file if it doesn't exist&#10;            if self.file_path:&#10;                os.makedirs(os.path.dirname(self.file_path), exist_ok=True)&#10;            else:&#10;                raise SettingsRepositoryError(&quot;File path is not set.&quot;)&#10;&#10;            settings_data = self.settings_object.to_dict()&#10;&#10;            with open(self.file_path, 'w') as f:&#10;                json.dump(settings_data, f, indent=4)&#10;            self.logger.info(f&quot;Settings saved to {self.file_path}.&quot;)&#10;&#10;        except Exception as e:&#10;            self.logger.error(f&quot;Error saving settings to {self.file_path}: {e}&quot;)&#10;            import traceback&#10;            traceback.print_exc()&#10;&#10;    def load(self):&#10;        &quot;&quot;&quot;&#10;        Load JSON from the repository's configured file path and populate the settings object.&#10;&#10;        Uses:&#10;            self.file_path (str): source JSON file path&#10;            self.settings_object: object that implements .from_dict(dict)&#10;        &quot;&quot;&quot;&#10;        try:&#10;            with open(self.file_path, 'r', encoding='utf-8') as f:&#10;                settings_data = json.load(f)&#10;&#10;                self.logger.debug(f&quot;Settings loaded from {self.file_path} Settings: {settings_data}.&quot;)&#10;&#10;&#10;            self.settings_object.from_dict(settings_data)&#10;&#10;        except (FileNotFoundError, json.JSONDecodeError) as e:&#10;            self.logger.error(f&quot;Error loading settings from {self.file_path}: {e}&quot;)&#10;            self.logger.info(f&quot;Using default values for {type(self.settings_object).__name__}.&quot;)" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/src/backend/system/settings/SettingsService.py">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/backend/system/settings/SettingsService.py" />
              <option name="originalContent" value="import json&#10;import os&#10;&#10;&#10;from backend.system.settings.CameraSettings import CameraSettings&#10;from backend.system.settings.SettingsJsonRepository import SettingsJsonRepository&#10;from backend.system.settings.robotConfig.robotConfigModel import RobotConfig, get_default_config&#10;&#10;from core.application.interfaces.application_settings_interface import ApplicationSettingsRegistry&#10;&#10;from modules.shared.v1 import Constants&#10;from backend.system.settings.enums.CameraSettingKey import CameraSettingKey&#10;import logging&#10;&#10;&#10;&#10;class SettingsService:&#10;    &quot;&quot;&quot;&#10;      Service responsible for managing core system settings (camera and robot).&#10;      &#10;      Application-specific settings are now managed by their respective applications&#10;      through the ApplicationSettingsInterface and are accessible via the settings registry.&#10;&#10;      This class handles:&#10;      - Loading and saving core settings (camera and robot) to JSON files&#10;      - Providing settings objects for external access&#10;      - Updating core settings based on external input&#10;      - Routing application-specific settings to registered handlers&#10;&#10;      Attributes:&#10;          settings_dir (str): The root directory where settings JSON files are stored.&#10;          settings_file_paths (dict): File paths for core settings files.&#10;          settings_objects (dict): Dictionary storing core settings objects.&#10;      &quot;&quot;&quot;&#10;&#10;&#10;    def __init__(self, settings_file_paths, settings_registry: ApplicationSettingsRegistry):&#10;        &quot;&quot;&quot;&#10;               Initialize the SettingsService by creating and loading core settings (camera and robot).&#10;               Application-specific settings are managed by their respective applications.&#10;               &quot;&quot;&quot;&#10;        self.settings_file_paths = settings_file_paths&#10;        self.settings_registry = settings_registry&#10;        # robot_config_file_path is still used by existing robot config logic&#10;        self.robot_config_file_path = settings_file_paths.get(&quot;robot_config&quot;) if settings_file_paths else None&#10;        self.logger = logging.getLogger(self.__class__.__name__)&#10;&#10;        # Initialize settings directory from the first file path&#10;        if settings_file_paths:&#10;            first_path = next(iter(settings_file_paths.values()))&#10;            if first_path:&#10;                self.settings_dir = os.path.dirname(first_path)&#10;            else:&#10;                self.settings_dir = &quot;settings&quot;&#10;        else:&#10;            self.settings_dir = &quot;settings&quot;&#10;&#10;        # Initialize a dictionary to store core settings objects&#10;        self.settings_objects = {}&#10;&#10;        # Initialize and load core settings only&#10;        self.camera_settings = CameraSettings()&#10;&#10;        # Store core settings in the settings dictionary&#10;        self.settings_objects[&quot;camera&quot;] = self.camera_settings&#10;&#10;        # Create a placeholder RobotConfig instance (use defaults) and register it so a repo will be created&#10;        # We'll load the actual values via the repository afterwards which may return a new RobotConfig instance.&#10;        try:&#10;            self.robot_config = get_default_config()&#10;        except Exception:&#10;            # fallback: create a minimal RobotConfig-like empty object if get_default_config fails&#10;            self.robot_config = RobotConfig.from_dict({})&#10;        &#10;        self.settings_objects[&quot;robot_config&quot;] = self.robot_config&#10;&#10;        # Create repository instances for each settings object (may receive None file paths)&#10;        self.settings_repos = {}&#10;        for key, settings_obj in self.settings_objects.items():&#10;            file_path = self.settings_file_paths.get(key) if self.settings_file_paths else None&#10;            # Pass the settings object instance to the repository&#10;            self.settings_repos[key] = SettingsJsonRepository(file_path=file_path, settings_object=settings_obj)&#10;&#10;        # Now load robot_config via its repository (the repository handles both in-place mutation and factory returns)&#10;        robot_repo = self.settings_repos.get(&quot;robot_config&quot;)&#10;        if robot_repo:&#10;            try:&#10;                loaded_robot = robot_repo.load()&#10;                if loaded_robot is not None and loaded_robot is not self.robot_config:&#10;                    self.robot_config = loaded_robot&#10;                    robot_repo.settings_object = self.robot_config&#10;            except Exception:&#10;                self.logger.exception(&quot;Failed to load robot_config via repository; using default robot_config&quot;)&#10;&#10;        # Load core settings from JSON files, or use default values if files do not exist&#10;        self.load_all_settings()&#10;&#10;    def set_camera_index(self, index):&#10;        self.camera_settings.set_camera_index(index)&#10;&#10;    def set_camera_width(self, width):&#10;        self.camera_settings.set_width(width)&#10;&#10;    def set_camera_height(self, height):&#10;        self.camera_settings.set_height(height)&#10;&#10;    def get_camera_index(self):&#10;        return self.camera_settings.get_camera_index()&#10;&#10;    def get_camera_width(self):&#10;        return self.camera_settings.get_camera_width()&#10;&#10;    def get_camera_height(self):&#10;        return self.camera_settings.get_camera_height()&#10;&#10;    def get_camera_settings(self):&#10;        &quot;&quot;&quot;Retrieve the camera settings object.&quot;&quot;&quot;&#10;        return self.camera_settings&#10;&#10;    def getSettings(self, key):&#10;        &quot;&quot;&quot;&#10;        Retrieve settings data based on the key provided.&#10;&#10;        Args:&#10;            key (str): The key corresponding to the settings type (&quot;camera&quot;, &quot;robot&quot;, or application type).&#10;&#10;        Returns:&#10;            dict: The settings data as a dictionary.&#10;        &quot;&quot;&quot;&#10;        # Handle core settings&#10;        if key == Constants.REQUEST_RESOURCE_CAMERA:&#10;            # For camera settings, return the nested JSON structure&#10;            data = self.camera_settings.to_dict()&#10;            self.logger.debug(&quot;from Settings Service: %s&quot;, data)&#10;            return data&#10;&#10;        # Handle application-specific settings through registry&#10;        # Convert resource names to lowercase for registry lookup&#10;        resource_map = {&#10;            &quot;Glue&quot;: &quot;glue&quot;,&#10;            &quot;Paint&quot;: &quot;paint&quot;,&#10;&#10;        }&#10;&#10;        settings_type = resource_map.get(key, key.lower())&#10;&#10;        if self.settings_registry.is_type_registered(settings_type):&#10;            try:&#10;                handler = self.settings_registry.get_handler(settings_type)&#10;                return handler.handle_get_settings()&#10;            except KeyError:&#10;                self.logger.warning(f&quot;Settings handler not found for type: {settings_type}&quot;)&#10;                return {}&#10;        else:&#10;            self.logger.warning(f&quot;Unknown settings key: {key}&quot;)&#10;            return {}&#10;&#10;    def save_all_settings(self):&#10;        &quot;&quot;&quot;Save all settings to their respective files.&quot;&quot;&quot;&#10;        for key, repo in self.settings_repos.items():&#10;            # delegate to repository - repository will handle missing file path errors&#10;            try:&#10;                repo.save()&#10;            except Exception:&#10;                # repository logs its own errors; continue with other repos&#10;                continue&#10;&#10;    # MUST BE REFACTORED load_robot_config AND  // TODO: MUST BE REFACTORED&#10;    def load_robot_config(self):&#10;        &quot;&quot;&quot;Load configuration from JSON file&quot;&quot;&quot;&#10;&#10;        try:&#10;            if self.robot_config_file_path and os.path.exists(self.robot_config_file_path):&#10;                with open(self.robot_config_file_path, 'r') as f:&#10;                    data = json.load(f)&#10;                    config = RobotConfig.from_dict(data)&#10;            else:&#10;                config = get_default_config()&#10;                self.save_robot_config_to_file(config.to_dict())&#10;&#10;        except Exception as e:&#10;            raise ValueError(f&quot;Error loading robot configuration: {e}&quot;)&#10;&#10;        return config&#10;&#10;    def save_robot_config_to_file(self, config: dict):&#10;        &quot;&quot;&quot;Save configuration to JSON file and send ROBOT_UPDATE_CONFIG request&quot;&quot;&quot;&#10;        try:&#10;            if not self.robot_config_file_path:&#10;                self.logger.error(&quot;robot_config_file_path is not set&quot;)&#10;                return&#10;            os.makedirs(os.path.dirname(self.robot_config_file_path), exist_ok=True)&#10;            with open(self.robot_config_file_path, 'w') as f:&#10;                json.dump(config, f, indent=4)&#10;        except Exception as e:&#10;            import traceback&#10;            traceback.print_exc()&#10;&#10;    def load_all_settings(self):&#10;        &quot;&quot;&quot;Load all settings from their respective JSON files. Use default values if file doesn't exist.&quot;&quot;&quot;&#10;        for key, repo in self.settings_repos.items():&#10;            filename = self.settings_file_paths.get(key) if self.settings_file_paths else None&#10;            self.logger.info(f&quot;Loading {key} settings from path: {filename}&quot;)&#10;            if filename and os.path.exists(filename):&#10;                self.logger.info(f&quot;File exists, loading settings from: {filename}&quot;)&#10;                try:&#10;                    repo.load()&#10;                except Exception:&#10;                    self.logger.exception(f&quot;Failed to load settings for {key} from {filename}&quot;)&#10;            else:&#10;                self.logger.info(f&quot;{filename} not found. Using default values for {key} settings.&quot;)&#10;                # Automatically save default settings to the missing file&#10;                try:&#10;                    repo.save()&#10;                except Exception:&#10;                    self.logger.exception(f&quot;Failed to save default settings for {key} to {filename}&quot;)&#10;&#10;    def load_settings_from_json(self, json_file, settings_obj):&#10;        &quot;&quot;&quot;&#10;        Load core settings from a JSON file into the given settings object.&#10;&#10;        Args:&#10;            json_file (str): Path to the JSON file.&#10;            settings_obj (CameraSettings): The object to load data into.&#10;        &quot;&quot;&quot;&#10;        if not json_file:&#10;            self.logger.error(&quot;load_settings_from_json called with empty json_file&quot;)&#10;            return&#10;&#10;        repo = SettingsJsonRepository(file_path=json_file, settings_object=settings_obj)&#10;        try:&#10;            repo.load()&#10;        except Exception as e:&#10;            self.logger.error(f&quot;Error loading settings from {json_file}: {e}&quot;)&#10;            self.logger.info(f&quot;Using default values for {type(settings_obj).__name__}.&quot;)&#10;&#10;    def save_settings_to_json(self, json_file, settings_obj):&#10;        &quot;&quot;&quot;&#10;              Save the provided core settings object to a JSON file.&#10;&#10;              Args:&#10;                  json_file (str): Path to the output JSON file.&#10;                  settings_obj (CameraSettings): The object to serialize.&#10;              &quot;&quot;&quot;&#10;        if not json_file:&#10;            self.logger.error(&quot;json_file path is None or empty&quot;)&#10;            return&#10;&#10;        # Delegate save to a temporary repository instance (or existing one)&#10;        repo = SettingsJsonRepository(file_path=json_file, settings_object=settings_obj)&#10;        try:&#10;            repo.save()&#10;        except Exception as e:&#10;            self.logger.error(f&quot;Error saving settings to {json_file}: {e}&quot;)&#10;            import traceback&#10;            traceback.print_exc()&#10;&#10;    def updateSettings(self, settings: dict):&#10;        &quot;&quot;&quot;&#10;               Update the relevant settings object based on the header type.&#10;&#10;               Args:&#10;                   settings (dict): A dictionary containing settings data and a &quot;header&quot; field indicating the type.&#10;&#10;               Raises:&#10;                   ValueError: If the &quot;header&quot; key is missing or invalid.&#10;               &quot;&quot;&quot;&#10;        print(f&quot;SettingsService.updateSettings called with: {settings}&quot;)&#10;        print(f&quot;Settings keys: {list(settings.keys()) if isinstance(settings, dict) else 'Not a dict'}&quot;)&#10;&#10;        if 'header' not in settings:&#10;            raise ValueError(&quot;Settings dictionary must contain a 'header' key&quot;)&#10;&#10;        header = settings['header']&#10;&#10;        if header == Constants.REQUEST_RESOURCE_CAMERA:&#10;            self.updateCameraSettings(settings)&#10;            return&#10;&#10;        # Handle application-specific settings through registry&#10;        # Convert resource names to lowercase for registry lookup&#10;        resource_map = {&#10;            &quot;Glue&quot;: &quot;glue&quot;&#10;        }&#10;&#10;        settings_type = resource_map.get(header, header.lower())&#10;&#10;        if self.settings_registry.is_type_registered(settings_type):&#10;            try:&#10;                handler = self.settings_registry.get_handler(settings_type)&#10;                success, message = handler.handle_set_settings(settings)&#10;                if not success:&#10;                    raise ValueError(f&quot;Failed to update {header} settings: {message}&quot;)&#10;            except KeyError:&#10;                raise ValueError(f&quot;Settings handler not found for type: {settings_type}&quot;)&#10;        else:&#10;            raise ValueError(f&quot;Invalid or unsupported settings header: {header}&quot;)&#10;&#10;    def updateCameraSettings(self, settings: dict):&#10;        self.logger.info(f&quot;Updating Camera Settings: {settings}&quot;)&#10;        &quot;&quot;&quot;&#10;              Update camera-specific settings and persist them to file.&#10;&#10;              Args:&#10;                  settings (dict): Dictionary containing camera settings data.&#10;              &quot;&quot;&quot;&#10;        # Handle both flat and nested input formats&#10;        self._update_camera_settings_from_data(settings)&#10;        camera_path = self.settings_file_paths.get(&quot;camera&quot;) if self.settings_file_paths else None&#10;        self.logger.info(f&quot;Saving camera settings to path: {camera_path}&quot;)&#10;        # Prefer using the repository instance if available&#10;        repo = self.settings_repos.get(&quot;camera&quot;)&#10;        if repo:&#10;            repo.save()&#10;        else:&#10;            self.save_settings_to_json(camera_path, self.camera_settings)&#10;&#10;    def _update_camera_settings_from_data(self, settings: dict):&#10;        &quot;&quot;&quot;&#10;        Update camera settings from either flat or nested dictionary format.&#10;        This handles updates from both UI changes and nested JSON structures.&#10;        &quot;&quot;&quot;&#10;        # Handle flat keys directly in the root&#10;        if CameraSettingKey.INDEX.value in settings:&#10;            self.camera_settings.set_camera_index(settings.get(CameraSettingKey.INDEX.value))&#10;        if CameraSettingKey.WIDTH.value in settings:&#10;            self.camera_settings.set_width(settings.get(CameraSettingKey.WIDTH.value))&#10;        if CameraSettingKey.HEIGHT.value in settings:&#10;            self.camera_settings.set_height(settings.get(CameraSettingKey.HEIGHT.value))&#10;        if CameraSettingKey.SKIP_FRAMES.value in settings:&#10;            self.camera_settings.set_skip_frames(settings.get(CameraSettingKey.SKIP_FRAMES.value))&#10;        if CameraSettingKey.CAPTURE_POS_OFFSET.value in settings:&#10;            self.camera_settings.set_capture_pos_offset(settings.get(CameraSettingKey.CAPTURE_POS_OFFSET.value))&#10;        if CameraSettingKey.THRESHOLD.value in settings:&#10;            self.camera_settings.set_threshold(settings.get(CameraSettingKey.THRESHOLD.value))&#10;        if CameraSettingKey.THRESHOLD_PICKUP_AREA.value in settings:&#10;            self.camera_settings.set_threshold_pickup_area(settings.get(CameraSettingKey.THRESHOLD_PICKUP_AREA.value))&#10;        if CameraSettingKey.EPSILON.value in settings:&#10;            self.camera_settings.set_epsilon(settings.get(CameraSettingKey.EPSILON.value))&#10;        if CameraSettingKey.MIN_CONTOUR_AREA.value in settings:&#10;            self.camera_settings.set_min_contour_area(settings.get(CameraSettingKey.MIN_CONTOUR_AREA.value))&#10;        if CameraSettingKey.MAX_CONTOUR_AREA.value in settings:&#10;            self.camera_settings.set_max_contour_area(settings.get(CameraSettingKey.MAX_CONTOUR_AREA.value))&#10;        if CameraSettingKey.CONTOUR_DETECTION.value in settings:&#10;            self.camera_settings.set_contour_detection(settings.get(CameraSettingKey.CONTOUR_DETECTION.value))&#10;        if CameraSettingKey.DRAW_CONTOURS.value in settings:&#10;            self.camera_settings.set_draw_contours(settings.get(CameraSettingKey.DRAW_CONTOURS.value))&#10;&#10;        # Handle nested Preprocessing section&#10;        if &quot;Preprocessing&quot; in settings:&#10;            preprocessing = settings[&quot;Preprocessing&quot;]&#10;            if CameraSettingKey.GAUSSIAN_BLUR.value in preprocessing:&#10;                self.camera_settings.set_gaussian_blur(preprocessing.get(CameraSettingKey.GAUSSIAN_BLUR.value))&#10;            if CameraSettingKey.BLUR_KERNEL_SIZE.value in preprocessing:&#10;                self.camera_settings.set_blur_kernel_size(preprocessing.get(CameraSettingKey.BLUR_KERNEL_SIZE.value))&#10;            if CameraSettingKey.THRESHOLD_TYPE.value in preprocessing:&#10;                self.camera_settings.set_threshold_type(preprocessing.get(CameraSettingKey.THRESHOLD_TYPE.value))&#10;            if CameraSettingKey.DILATE_ENABLED.value in preprocessing:&#10;                self.camera_settings.set_dilate_enabled(preprocessing.get(CameraSettingKey.DILATE_ENABLED.value))&#10;            if CameraSettingKey.DILATE_KERNEL_SIZE.value in preprocessing:&#10;                self.camera_settings.set_dilate_kernel_size(&#10;                    preprocessing.get(CameraSettingKey.DILATE_KERNEL_SIZE.value))&#10;            if CameraSettingKey.DILATE_ITERATIONS.value in preprocessing:&#10;                self.camera_settings.set_dilate_iterations(preprocessing.get(CameraSettingKey.DILATE_ITERATIONS.value))&#10;            if CameraSettingKey.ERODE_ENABLED.value in preprocessing:&#10;                self.camera_settings.set_erode_enabled(preprocessing.get(CameraSettingKey.ERODE_ENABLED.value))&#10;            if CameraSettingKey.ERODE_KERNEL_SIZE.value in preprocessing:&#10;                self.camera_settings.set_erode_kernel_size(preprocessing.get(CameraSettingKey.ERODE_KERNEL_SIZE.value))&#10;            if CameraSettingKey.ERODE_ITERATIONS.value in preprocessing:&#10;                self.camera_settings.set_erode_iterations(preprocessing.get(CameraSettingKey.ERODE_ITERATIONS.value))&#10;&#10;        # Handle nested Calibration section&#10;        if &quot;Calibration&quot; in settings:&#10;            calibration = settings[&quot;Calibration&quot;]&#10;            if CameraSettingKey.CHESSBOARD_WIDTH.value in calibration:&#10;                self.camera_settings.set_chessboard_width(calibration.get(CameraSettingKey.CHESSBOARD_WIDTH.value))&#10;            if CameraSettingKey.CHESSBOARD_HEIGHT.value in calibration:&#10;                self.camera_settings.set_chessboard_height(calibration.get(CameraSettingKey.CHESSBOARD_HEIGHT.value))&#10;            if CameraSettingKey.SQUARE_SIZE_MM.value in calibration:&#10;                self.camera_settings.set_square_size_mm(calibration.get(CameraSettingKey.SQUARE_SIZE_MM.value))&#10;            if &quot;Skip frames&quot; in calibration:  # Special mapping for nested calibration skip frames&#10;                self.camera_settings.set_calibration_skip_frames(calibration.get(&quot;Skip frames&quot;))&#10;            if CameraSettingKey.CAPTURE_POS_OFFSET.value in calibration:&#10;                self.camera_settings.set_capture_pos_offset(calibration.get(CameraSettingKey.CAPTURE_POS_OFFSET.value))&#10;&#10;        # Handle nested Brightness Control section&#10;        if &quot;Brightness Control&quot; in settings:&#10;            brightness = settings[&quot;Brightness Control&quot;]&#10;            if CameraSettingKey.BRIGHTNESS_AUTO.value in brightness:&#10;                self.camera_settings.set_brightness_auto(brightness.get(CameraSettingKey.BRIGHTNESS_AUTO.value))&#10;            if CameraSettingKey.BRIGHTNESS_KP.value in brightness:&#10;                self.camera_settings.set_brightness_kp(brightness.get(CameraSettingKey.BRIGHTNESS_KP.value))&#10;            if CameraSettingKey.BRIGHTNESS_KI.value in brightness:&#10;                self.camera_settings.set_brightness_ki(brightness.get(CameraSettingKey.BRIGHTNESS_KI.value))&#10;            if CameraSettingKey.BRIGHTNESS_KD.value in brightness:&#10;                self.camera_settings.set_brightness_kd(brightness.get(CameraSettingKey.BRIGHTNESS_KD.value))&#10;            if CameraSettingKey.TARGET_BRIGHTNESS.value in brightness:&#10;                self.camera_settings.set_target_brightness(brightness.get(CameraSettingKey.TARGET_BRIGHTNESS.value))&#10;&#10;        # Handle nested Aruco section&#10;        if &quot;Aruco&quot; in settings:&#10;            aruco = settings[&quot;Aruco&quot;]&#10;            if &quot;Enable detection&quot; in aruco:  # Special mapping for nested ArUco enabled&#10;                self.camera_settings.set_aruco_enabled(aruco.get(&quot;Enable detection&quot;))&#10;            if CameraSettingKey.ARUCO_DICTIONARY.value in aruco:&#10;                self.camera_settings.set_aruco_dictionary(aruco.get(CameraSettingKey.ARUCO_DICTIONARY.value))&#10;            if CameraSettingKey.ARUCO_FLIP_IMAGE.value in aruco:&#10;                self.camera_settings.set_aruco_flip_image(aruco.get(CameraSettingKey.ARUCO_FLIP_IMAGE.value))&#10;&#10;        # Handle flat keys that might be from UI updates (fallback for direct enum-based updates)&#10;        preprocessing_keys = [&#10;            CameraSettingKey.GAUSSIAN_BLUR, CameraSettingKey.BLUR_KERNEL_SIZE, CameraSettingKey.THRESHOLD_TYPE,&#10;            CameraSettingKey.DILATE_ENABLED, CameraSettingKey.DILATE_KERNEL_SIZE, CameraSettingKey.DILATE_ITERATIONS,&#10;            CameraSettingKey.ERODE_ENABLED, CameraSettingKey.ERODE_KERNEL_SIZE, CameraSettingKey.ERODE_ITERATIONS&#10;        ]&#10;&#10;        calibration_keys = [&#10;            CameraSettingKey.CHESSBOARD_WIDTH, CameraSettingKey.CHESSBOARD_HEIGHT,&#10;            CameraSettingKey.SQUARE_SIZE_MM, CameraSettingKey.CALIBRATION_SKIP_FRAMES&#10;        ]&#10;&#10;        brightness_keys = [&#10;            CameraSettingKey.BRIGHTNESS_AUTO, CameraSettingKey.BRIGHTNESS_KP, CameraSettingKey.BRIGHTNESS_KI,&#10;            CameraSettingKey.BRIGHTNESS_KD, CameraSettingKey.TARGET_BRIGHTNESS&#10;        ]&#10;&#10;        aruco_keys = [&#10;            CameraSettingKey.ARUCO_ENABLED, CameraSettingKey.ARUCO_DICTIONARY, CameraSettingKey.ARUCO_FLIP_IMAGE&#10;        ]&#10;&#10;" />
              <option name="updatedContent" value="import json&#10;import os&#10;&#10;&#10;from backend.system.settings.CameraSettings import CameraSettings&#10;from backend.system.settings.SettingsJsonRepository import SettingsJsonRepository&#10;from backend.system.settings.robotConfig.robotConfigModel import RobotConfig, get_default_config&#10;&#10;from core.application.interfaces.application_settings_interface import ApplicationSettingsRegistry&#10;&#10;from modules.shared.v1 import Constants&#10;from backend.system.settings.enums.CameraSettingKey import CameraSettingKey&#10;import logging&#10;&#10;&#10;&#10;class SettingsService:&#10;    &quot;&quot;&quot;&#10;      Service responsible for managing core system settings (camera and robot).&#10;      &#10;      Application-specific settings are now managed by their respective applications&#10;      through the ApplicationSettingsInterface and are accessible via the settings registry.&#10;&#10;      This class handles:&#10;      - Loading and saving core settings (camera and robot) to JSON files&#10;      - Providing settings objects for external access&#10;      - Updating core settings based on external input&#10;      - Routing application-specific settings to registered handlers&#10;&#10;      Attributes:&#10;          settings_dir (str): The root directory where settings JSON files are stored.&#10;          settings_file_paths (dict): File paths for core settings files.&#10;          settings_objects (dict): Dictionary storing core settings objects.&#10;      &quot;&quot;&quot;&#10;&#10;&#10;    def __init__(self, settings_file_paths, settings_registry: ApplicationSettingsRegistry):&#10;        &quot;&quot;&quot;&#10;               Initialize the SettingsService by creating and loading core settings (camera and robot).&#10;               Application-specific settings are managed by their respective applications.&#10;               &quot;&quot;&quot;&#10;        self.settings_file_paths = settings_file_paths&#10;        self.settings_registry = settings_registry&#10;        # robot_config_file_path is still used by existing robot config logic&#10;        self.robot_config_file_path = settings_file_paths.get(&quot;robot_config&quot;) if settings_file_paths else None&#10;        self.logger = logging.getLogger(self.__class__.__name__)&#10;&#10;        # Initialize settings directory from the first file path&#10;        if settings_file_paths:&#10;            first_path = next(iter(settings_file_paths.values()))&#10;            if first_path:&#10;                self.settings_dir = os.path.dirname(first_path)&#10;            else:&#10;                self.settings_dir = &quot;settings&quot;&#10;        else:&#10;            self.settings_dir = &quot;settings&quot;&#10;&#10;        # Initialize a dictionary to store core settings objects&#10;        self.settings_objects = {}&#10;&#10;        # Initialize and load core settings only&#10;        self.camera_settings = CameraSettings()&#10;&#10;        # Store core settings in the settings dictionary&#10;        self.settings_objects[&quot;camera&quot;] = self.camera_settings&#10;&#10;        # Create a placeholder RobotConfig instance (use defaults) and register it so a repo will be created&#10;        # We'll load the actual values via the repository afterwards which may return a new RobotConfig instance.&#10;        try:&#10;            self.robot_config = get_default_config()&#10;        except Exception:&#10;            # fallback: create a minimal RobotConfig-like empty object if get_default_config fails&#10;            self.robot_config = RobotConfig.from_dict({})&#10;        &#10;        self.settings_objects[&quot;robot_config&quot;] = self.robot_config&#10;&#10;        # Create repository instances for each settings object (may receive None file paths)&#10;        self.settings_repos = {}&#10;        for key, settings_obj in self.settings_objects.items():&#10;            file_path = self.settings_file_paths.get(key) if self.settings_file_paths else None&#10;            # Pass the settings object instance to the repository&#10;            self.settings_repos[key] = SettingsJsonRepository(file_path=file_path, settings_object=settings_obj)&#10;&#10;        # Now load robot_config via its repository (the repository handles both in-place mutation and factory returns)&#10;        robot_repo = self.settings_repos.get(&quot;robot_config&quot;)&#10;        if robot_repo:&#10;            try:&#10;                loaded_robot = robot_repo.load()&#10;                if loaded_robot is not None and loaded_robot is not self.robot_config:&#10;                    self.robot_config = loaded_robot&#10;                    robot_repo.settings_object = self.robot_config&#10;            except Exception:&#10;                self.logger.exception(&quot;Failed to load robot_config via repository; using default robot_config&quot;)&#10;&#10;        # Load core settings from JSON files, or use default values if files do not exist&#10;        self.load_all_settings()&#10;&#10;    def set_camera_index(self, index):&#10;        self.camera_settings.set_camera_index(index)&#10;&#10;    def set_camera_width(self, width):&#10;        self.camera_settings.set_width(width)&#10;&#10;    def set_camera_height(self, height):&#10;        self.camera_settings.set_height(height)&#10;&#10;    def get_camera_index(self):&#10;        return self.camera_settings.get_camera_index()&#10;&#10;    def get_camera_width(self):&#10;        return self.camera_settings.get_camera_width()&#10;&#10;    def get_camera_height(self):&#10;        return self.camera_settings.get_camera_height()&#10;&#10;    def get_camera_settings(self):&#10;        &quot;&quot;&quot;Retrieve the camera settings object.&quot;&quot;&quot;&#10;        return self.camera_settings&#10;&#10;    def getSettings(self, key):&#10;        &quot;&quot;&quot;&#10;        Retrieve settings data based on the key provided.&#10;&#10;        Args:&#10;            key (str): The key corresponding to the settings type (&quot;camera&quot;, &quot;robot&quot;, or application type).&#10;&#10;        Returns:&#10;            dict: The settings data as a dictionary.&#10;        &quot;&quot;&quot;&#10;        # Handle core settings&#10;        if key == Constants.REQUEST_RESOURCE_CAMERA:&#10;            # For camera settings, return the nested JSON structure&#10;            data = self.camera_settings.to_dict()&#10;            self.logger.debug(&quot;from Settings Service: %s&quot;, data)&#10;            return data&#10;&#10;        # Handle application-specific settings through registry&#10;        # Convert resource names to lowercase for registry lookup&#10;        resource_map = {&#10;            &quot;Glue&quot;: &quot;glue&quot;,&#10;            &quot;Paint&quot;: &quot;paint&quot;,&#10;&#10;        }&#10;&#10;        settings_type = resource_map.get(key, key.lower())&#10;&#10;        if self.settings_registry.is_type_registered(settings_type):&#10;            try:&#10;                handler = self.settings_registry.get_handler(settings_type)&#10;                return handler.handle_get_settings()&#10;            except KeyError:&#10;                self.logger.warning(f&quot;Settings handler not found for type: {settings_type}&quot;)&#10;                return {}&#10;        else:&#10;            self.logger.warning(f&quot;Unknown settings key: {key}&quot;)&#10;            return {}&#10;&#10;    def save_all_settings(self):&#10;        &quot;&quot;&quot;Save all settings to their respective files.&quot;&quot;&quot;&#10;        for key, repo in self.settings_repos.items():&#10;            # delegate to repository - repository will handle missing file path errors&#10;            try:&#10;                repo.save()&#10;            except Exception:&#10;                # repository logs its own errors; continue with other repos&#10;                continue&#10;&#10;    # MUST BE REFACTORED load_robot_config AND  // TODO: MUST BE REFACTORED&#10;    def load_robot_config(self):&#10;        &quot;&quot;&quot;Load configuration from JSON file&quot;&quot;&quot;&#10;&#10;        try:&#10;            if self.robot_config_file_path and os.path.exists(self.robot_config_file_path):&#10;                with open(self.robot_config_file_path, 'r') as f:&#10;                    data = json.load(f)&#10;                    config = RobotConfig.from_dict(data)&#10;            else:&#10;                config = get_default_config()&#10;                self.save_robot_config_to_file(config.to_dict())&#10;&#10;        except Exception as e:&#10;            raise ValueError(f&quot;Error loading robot configuration: {e}&quot;)&#10;&#10;        return config&#10;&#10;    def save_robot_config_to_file(self, config: dict):&#10;        &quot;&quot;&quot;Save configuration to JSON file and send ROBOT_UPDATE_CONFIG request&quot;&quot;&quot;&#10;        try:&#10;            if not self.robot_config_file_path:&#10;                self.logger.error(&quot;robot_config_file_path is not set&quot;)&#10;                return&#10;            os.makedirs(os.path.dirname(self.robot_config_file_path), exist_ok=True)&#10;            with open(self.robot_config_file_path, 'w') as f:&#10;                json.dump(config, f, indent=4)&#10;        except Exception as e:&#10;            import traceback&#10;            traceback.print_exc()&#10;&#10;    def load_all_settings(self):&#10;        &quot;&quot;&quot;Load all settings from their respective JSON files. Use default values if file doesn't exist.&quot;&quot;&quot;&#10;        for key, repo in self.settings_repos.items():&#10;            filename = self.settings_file_paths.get(key) if self.settings_file_paths else None&#10;            self.logger.info(f&quot;Loading {key} settings from path: {filename}&quot;)&#10;            if filename and os.path.exists(filename):&#10;                self.logger.info(f&quot;File exists, loading settings from: {filename}&quot;)&#10;                try:&#10;                    repo.load()&#10;                except Exception:&#10;                    self.logger.exception(f&quot;Failed to load settings for {key} from {filename}&quot;)&#10;            else:&#10;                self.logger.info(f&quot;{filename} not found. Using default values for {key} settings.&quot;)&#10;                # Automatically save default settings to the missing file&#10;                try:&#10;                    repo.save()&#10;                except Exception:&#10;                    self.logger.exception(f&quot;Failed to save default settings for {key} to {filename}&quot;)&#10;&#10;    def load_settings_from_json(self, json_file, settings_obj):&#10;        &quot;&quot;&quot;&#10;        Load core settings from a JSON file into the given settings object.&#10;&#10;        Args:&#10;            json_file (str): Path to the JSON file.&#10;            settings_obj (CameraSettings): The object to load data into.&#10;        &quot;&quot;&quot;&#10;        if not json_file:&#10;            self.logger.error(&quot;load_settings_from_json called with empty json_file&quot;)&#10;            return&#10;&#10;        repo = SettingsJsonRepository(file_path=json_file, settings_object=settings_obj)&#10;        try:&#10;            repo.load()&#10;        except Exception as e:&#10;            self.logger.error(f&quot;Error loading settings from {json_file}: {e}&quot;)&#10;            self.logger.info(f&quot;Using default values for {type(settings_obj).__name__}.&quot;)&#10;&#10;    def save_settings_to_json(self, json_file, settings_obj):&#10;        &quot;&quot;&quot;&#10;              Save the provided core settings object to a JSON file.&#10;&#10;              Args:&#10;                  json_file (str): Path to the output JSON file.&#10;                  settings_obj (CameraSettings): The object to serialize.&#10;              &quot;&quot;&quot;&#10;        if not json_file:&#10;            self.logger.error(&quot;json_file path is None or empty&quot;)&#10;            return&#10;&#10;        # Delegate save to a temporary repository instance (or existing one)&#10;        repo = SettingsJsonRepository(file_path=json_file, settings_object=settings_obj)&#10;        try:&#10;            repo.save()&#10;        except Exception as e:&#10;            self.logger.error(f&quot;Error saving settings to {json_file}: {e}&quot;)&#10;            import traceback&#10;            traceback.print_exc()&#10;&#10;    def updateSettings(self, settings: dict):&#10;        &quot;&quot;&quot;&#10;               Update the relevant settings object based on the header type.&#10;&#10;               Args:&#10;                   settings (dict): A dictionary containing settings data and a &quot;header&quot; field indicating the type.&#10;&#10;               Raises:&#10;                   ValueError: If the &quot;header&quot; key is missing or invalid.&#10;               &quot;&quot;&quot;&#10;        print(f&quot;SettingsService.updateSettings called with: {settings}&quot;)&#10;        print(f&quot;Settings keys: {list(settings.keys()) if isinstance(settings, dict) else 'Not a dict'}&quot;)&#10;&#10;        if 'header' not in settings:&#10;            raise ValueError(&quot;Settings dictionary must contain a 'header' key&quot;)&#10;&#10;        header = settings['header']&#10;&#10;        if header == Constants.REQUEST_RESOURCE_CAMERA:&#10;            self.updateCameraSettings(settings)&#10;            return&#10;&#10;        # Handle application-specific settings through registry&#10;        # Convert resource names to lowercase for registry lookup&#10;        resource_map = {&#10;            &quot;Glue&quot;: &quot;glue&quot;&#10;        }&#10;&#10;        settings_type = resource_map.get(header, header.lower())&#10;&#10;        if self.settings_registry.is_type_registered(settings_type):&#10;            try:&#10;                handler = self.settings_registry.get_handler(settings_type)&#10;                success, message = handler.handle_set_settings(settings)&#10;                if not success:&#10;                    raise ValueError(f&quot;Failed to update {header} settings: {message}&quot;)&#10;            except KeyError:&#10;                raise ValueError(f&quot;Settings handler not found for type: {settings_type}&quot;)&#10;        else:&#10;            raise ValueError(f&quot;Invalid or unsupported settings header: {header}&quot;)&#10;&#10;    def updateCameraSettings(self, settings: dict):&#10;        self.logger.info(f&quot;Updating Camera Settings: {settings}&quot;)&#10;        &quot;&quot;&quot;&#10;              Update camera-specific settings and persist them to file.&#10;&#10;              Args:&#10;                  settings (dict): Dictionary containing camera settings data.&#10;              &quot;&quot;&quot;&#10;        # Handle both flat and nested input formats&#10;        self._update_camera_settings_from_data(settings)&#10;        camera_path = self.settings_file_paths.get(&quot;camera&quot;) if self.settings_file_paths else None&#10;        self.logger.info(f&quot;Saving camera settings to path: {camera_path}&quot;)&#10;        # Prefer using the repository instance if available&#10;        repo = self.settings_repos.get(&quot;camera&quot;)&#10;        if repo:&#10;            repo.save()&#10;        else:&#10;            self.save_settings_to_json(camera_path, self.camera_settings)&#10;&#10;    def _update_camera_settings_from_data(self, settings: dict):&#10;        &quot;&quot;&quot;&#10;        Update camera settings from either flat or nested dictionary format.&#10;        This handles updates from both UI changes and nested JSON structures.&#10;        &quot;&quot;&quot;&#10;        # Handle flat keys directly in the root&#10;        if CameraSettingKey.INDEX.value in settings:&#10;            self.camera_settings.set_camera_index(settings.get(CameraSettingKey.INDEX.value))&#10;        if CameraSettingKey.WIDTH.value in settings:&#10;            self.camera_settings.set_width(settings.get(CameraSettingKey.WIDTH.value))&#10;        if CameraSettingKey.HEIGHT.value in settings:&#10;            self.camera_settings.set_height(settings.get(CameraSettingKey.HEIGHT.value))&#10;        if CameraSettingKey.SKIP_FRAMES.value in settings:&#10;            self.camera_settings.set_skip_frames(settings.get(CameraSettingKey.SKIP_FRAMES.value))&#10;        if CameraSettingKey.CAPTURE_POS_OFFSET.value in settings:&#10;            self.camera_settings.set_capture_pos_offset(settings.get(CameraSettingKey.CAPTURE_POS_OFFSET.value))&#10;        if CameraSettingKey.THRESHOLD.value in settings:&#10;            self.camera_settings.set_threshold(settings.get(CameraSettingKey.THRESHOLD.value))&#10;        if CameraSettingKey.THRESHOLD_PICKUP_AREA.value in settings:&#10;            self.camera_settings.set_threshold_pickup_area(settings.get(CameraSettingKey.THRESHOLD_PICKUP_AREA.value))&#10;        if CameraSettingKey.EPSILON.value in settings:&#10;            self.camera_settings.set_epsilon(settings.get(CameraSettingKey.EPSILON.value))&#10;        if CameraSettingKey.MIN_CONTOUR_AREA.value in settings:&#10;            self.camera_settings.set_min_contour_area(settings.get(CameraSettingKey.MIN_CONTOUR_AREA.value))&#10;        if CameraSettingKey.MAX_CONTOUR_AREA.value in settings:&#10;            self.camera_settings.set_max_contour_area(settings.get(CameraSettingKey.MAX_CONTOUR_AREA.value))&#10;        if CameraSettingKey.CONTOUR_DETECTION.value in settings:&#10;            self.camera_settings.set_contour_detection(settings.get(CameraSettingKey.CONTOUR_DETECTION.value))&#10;        if CameraSettingKey.DRAW_CONTOURS.value in settings:&#10;            self.camera_settings.set_draw_contours(settings.get(CameraSettingKey.DRAW_CONTOURS.value))&#10;&#10;        # Handle nested Preprocessing section&#10;        if &quot;Preprocessing&quot; in settings:&#10;            preprocessing = settings[&quot;Preprocessing&quot;]&#10;            if CameraSettingKey.GAUSSIAN_BLUR.value in preprocessing:&#10;                self.camera_settings.set_gaussian_blur(preprocessing.get(CameraSettingKey.GAUSSIAN_BLUR.value))&#10;            if CameraSettingKey.BLUR_KERNEL_SIZE.value in preprocessing:&#10;                self.camera_settings.set_blur_kernel_size(preprocessing.get(CameraSettingKey.BLUR_KERNEL_SIZE.value))&#10;            if CameraSettingKey.THRESHOLD_TYPE.value in preprocessing:&#10;                self.camera_settings.set_threshold_type(preprocessing.get(CameraSettingKey.THRESHOLD_TYPE.value))&#10;            if CameraSettingKey.DILATE_ENABLED.value in preprocessing:&#10;                self.camera_settings.set_dilate_enabled(preprocessing.get(CameraSettingKey.DILATE_ENABLED.value))&#10;            if CameraSettingKey.DILATE_KERNEL_SIZE.value in preprocessing:&#10;                self.camera_settings.set_dilate_kernel_size(&#10;                    preprocessing.get(CameraSettingKey.DILATE_KERNEL_SIZE.value))&#10;            if CameraSettingKey.DILATE_ITERATIONS.value in preprocessing:&#10;                self.camera_settings.set_dilate_iterations(preprocessing.get(CameraSettingKey.DILATE_ITERATIONS.value))&#10;            if CameraSettingKey.ERODE_ENABLED.value in preprocessing:&#10;                self.camera_settings.set_erode_enabled(preprocessing.get(CameraSettingKey.ERODE_ENABLED.value))&#10;            if CameraSettingKey.ERODE_KERNEL_SIZE.value in preprocessing:&#10;                self.camera_settings.set_erode_kernel_size(preprocessing.get(CameraSettingKey.ERODE_KERNEL_SIZE.value))&#10;            if CameraSettingKey.ERODE_ITERATIONS.value in preprocessing:&#10;                self.camera_settings.set_erode_iterations(preprocessing.get(CameraSettingKey.ERODE_ITERATIONS.value))&#10;&#10;        # Handle nested Calibration section&#10;        if &quot;Calibration&quot; in settings:&#10;            calibration = settings[&quot;Calibration&quot;]&#10;            if CameraSettingKey.CHESSBOARD_WIDTH.value in calibration:&#10;                self.camera_settings.set_chessboard_width(calibration.get(CameraSettingKey.CHESSBOARD_WIDTH.value))&#10;            if CameraSettingKey.CHESSBOARD_HEIGHT.value in calibration:&#10;                self.camera_settings.set_chessboard_height(calibration.get(CameraSettingKey.CHESSBOARD_HEIGHT.value))&#10;            if CameraSettingKey.SQUARE_SIZE_MM.value in calibration:&#10;                self.camera_settings.set_square_size_mm(calibration.get(CameraSettingKey.SQUARE_SIZE_MM.value))&#10;            if &quot;Skip frames&quot; in calibration:  # Special mapping for nested calibration skip frames&#10;                self.camera_settings.set_calibration_skip_frames(calibration.get(&quot;Skip frames&quot;))&#10;            if CameraSettingKey.CAPTURE_POS_OFFSET.value in calibration:&#10;                self.camera_settings.set_capture_pos_offset(calibration.get(CameraSettingKey.CAPTURE_POS_OFFSET.value))&#10;&#10;        # Handle nested Brightness Control section&#10;        if &quot;Brightness Control&quot; in settings:&#10;            brightness = settings[&quot;Brightness Control&quot;]&#10;            if CameraSettingKey.BRIGHTNESS_AUTO.value in brightness:&#10;                self.camera_settings.set_brightness_auto(brightness.get(CameraSettingKey.BRIGHTNESS_AUTO.value))&#10;            if CameraSettingKey.BRIGHTNESS_KP.value in brightness:&#10;                self.camera_settings.set_brightness_kp(brightness.get(CameraSettingKey.BRIGHTNESS_KP.value))&#10;            if CameraSettingKey.BRIGHTNESS_KI.value in brightness:&#10;                self.camera_settings.set_brightness_ki(brightness.get(CameraSettingKey.BRIGHTNESS_KI.value))&#10;            if CameraSettingKey.BRIGHTNESS_KD.value in brightness:&#10;                self.camera_settings.set_brightness_kd(brightness.get(CameraSettingKey.BRIGHTNESS_KD.value))&#10;            if CameraSettingKey.TARGET_BRIGHTNESS.value in brightness:&#10;                self.camera_settings.set_target_brightness(brightness.get(CameraSettingKey.TARGET_BRIGHTNESS.value))&#10;&#10;        # Handle nested Aruco section&#10;        if &quot;Aruco&quot; in settings:&#10;            aruco = settings[&quot;Aruco&quot;]&#10;            if &quot;Enable detection&quot; in aruco:  # Special mapping for nested ArUco enabled&#10;                self.camera_settings.set_aruco_enabled(aruco.get(&quot;Enable detection&quot;))&#10;            if CameraSettingKey.ARUCO_DICTIONARY.value in aruco:&#10;                self.camera_settings.set_aruco_dictionary(aruco.get(CameraSettingKey.ARUCO_DICTIONARY.value))&#10;            if CameraSettingKey.ARUCO_FLIP_IMAGE.value in aruco:&#10;                self.camera_settings.set_aruco_flip_image(aruco.get(CameraSettingKey.ARUCO_FLIP_IMAGE.value))&#10;&#10;        # Handle flat keys that might be from UI updates (fallback for direct enum-based updates)&#10;        preprocessing_keys = [&#10;            CameraSettingKey.GAUSSIAN_BLUR, CameraSettingKey.BLUR_KERNEL_SIZE, CameraSettingKey.THRESHOLD_TYPE,&#10;            CameraSettingKey.DILATE_ENABLED, CameraSettingKey.DILATE_KERNEL_SIZE, CameraSettingKey.DILATE_ITERATIONS,&#10;            CameraSettingKey.ERODE_ENABLED, CameraSettingKey.ERODE_KERNEL_SIZE, CameraSettingKey.ERODE_ITERATIONS&#10;        ]&#10;&#10;        calibration_keys = [&#10;            CameraSettingKey.CHESSBOARD_WIDTH, CameraSettingKey.CHESSBOARD_HEIGHT,&#10;            CameraSettingKey.SQUARE_SIZE_MM, CameraSettingKey.CALIBRATION_SKIP_FRAMES&#10;        ]&#10;&#10;        brightness_keys = [&#10;            CameraSettingKey.BRIGHTNESS_AUTO, CameraSettingKey.BRIGHTNESS_KP, CameraSettingKey.BRIGHTNESS_KI,&#10;            CameraSettingKey.BRIGHTNESS_KD, CameraSettingKey.TARGET_BRIGHTNESS&#10;        ]&#10;&#10;        aruco_keys = [&#10;            CameraSettingKey.ARUCO_ENABLED, CameraSettingKey.ARUCO_DICTIONARY, CameraSettingKey.ARUCO_FLIP_IMAGE&#10;        ]&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/src/core/services/vision/VisionService.py">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/core/services/vision/VisionService.py" />
              <option name="originalContent" value="import queue&#10;import time&#10;import numpy as np&#10;import cv2&#10;# from system.robot.RobotCalibrationService import CAMERA_TO_ROBOT_MATRIX_PATH&#10;from backend.system.utils import utils&#10;from modules.VisionSystem.VisionSystem import VisionSystem&#10;import os&#10;from modules.shared.MessageBroker import MessageBroker&#10;import threading&#10;CONFIG_FILE_PATH = os.path.join(os.path.dirname(__file__), '..','..','..','backend', 'system','storage', 'settings', 'camera_settings.json')&#10;&#10;from modules.shared.v1.topics import VisionTopics&#10;# PICKUP_AREA_CAMERA_TO_ROBOT_MATRIX_PATH = '/home/ilv/Cobot-Glue-Nozzle/VisionSystem/calibration/cameraCalibration/storage/calibration_result/pickupCamToRobotMatrix.npy'&#10;PICKUP_AREA_CAMERA_TO_ROBOT_MATRIX_PATH = os.path.join(os.path.dirname(__file__),'..','..', '..', 'VisionSystem', 'calibration', 'cameraCalibration', 'storage', 'calibration_result', 'pickupCamToRobotMatrix.npy')&#10;&#10;class _VisionService(VisionSystem):&#10;    &quot;&quot;&quot;&#10;        Vision service class for processing camera frames and detecting contours, workpieces, and ArUco markers.&#10;&#10;    This class extends the VisionSystem and handles real-time frame processing, contour detection,&#10;    filtering workpieces within a defined area, and interfacing with robot calibration and workpieces services.&#10;&#10;    Attributes:&#10;        MAX_QUEUE_SIZE (int): Maximum number of frames to store in the queue.&#10;        frameQueue (queue.Queue): A queue to store the most recent frames for processing.&#10;        contours (list): Detected contours in the current frame.&#10;        workAreaCorners (dict): Coordinates defining the workpieces pickup area.&#10;        filteredContours (list): Contours that are filtered based on the work area.&#10;        drawOverlay (bool): Flag to determine whether to draw overlays on the frame.&#10;        pickupCamToRobotMatrix (numpy.ndarray): Matrix to transform camera points to robot coordinates.&#10;&#10;    &quot;&quot;&quot;&#10;    def __init__(self):&#10;        &quot;&quot;&quot;&#10;            Initializes the VisionService with camera settings and prepares the frame queue and other attributes.&#10;&#10;            This constructor initializes the camera service, the frame queue to store the latest frames,&#10;            and loads the camera-to-robot matrix for transformation.&#10;&#10;            Args:&#10;                None&#10;            &quot;&quot;&quot;&#10;        super().__init__(configFilePath=CONFIG_FILE_PATH)&#10;&#10;        self.MAX_QUEUE_SIZE = 100  # Maximum number of frames to store in the queue&#10;        self.frameQueue = queue.Queue(maxsize=self.MAX_QUEUE_SIZE)&#10;        self.superRun = super().run&#10;        self.latest_frame = None&#10;        self.frame_lock = threading.Lock()&#10;&#10;        self.contours = None&#10;        self.workAreaCorners = None&#10;        self.filteredContours = None&#10;        self.pickupCamToRobotMatrix = self._loadPickupCamToRobotMatrix()&#10;        broker = MessageBroker()&#10;        broker.subscribe(VisionTopics.TRANSFORM_TO_CAMERA_POINT,self.transformRobotPointToCamera)&#10;&#10;    def _loadPickupCamToRobotMatrix(self):&#10;        &quot;&quot;&quot;&#10;             Loads the camera-to-robot transformation matrix from a predefined file.&#10;&#10;             The matrix is required for transforming the camera coordinates to the robot's coordinate system.&#10;&#10;             Returns:&#10;                 numpy.ndarray or None: The transformation matrix if successful, otherwise None.&#10;             &quot;&quot;&quot;&#10;        if not os.path.exists(PICKUP_AREA_CAMERA_TO_ROBOT_MATRIX_PATH):&#10;            print(f&quot;Error: Matrix file not found at {PICKUP_AREA_CAMERA_TO_ROBOT_MATRIX_PATH}&quot;)&#10;            self.pickupCamToRobotMatrix = None&#10;            # return None&#10;&#10;        try:&#10;            self.pickupCamToRobotMatrix = np.load(PICKUP_AREA_CAMERA_TO_ROBOT_MATRIX_PATH)&#10;            # print(&quot;Matrix loaded:&quot;, self.pickupCamToRobotMatrix)&#10;        except Exception as e:&#10;            print(f&quot;Error loading matrix: {e}&quot;)&#10;            self.pickupCamToRobotMatrix = None&#10;&#10;        return self.pickupCamToRobotMatrix&#10;&#10;    def run(self):&#10;        &quot;&quot;&quot;&#10;              Main loop that continuously processes frames from the camera.&#10;&#10;              It detects contours, applies overlays if necessary, and processes workpieces within the defined work area.&#10;&#10;              This method keeps running indefinitely, so it should be called in a separate thread or process.&#10;&#10;              Returns:&#10;                  None&#10;              &quot;&quot;&quot;&#10;        print(&quot;Starting VisionService run loop...&quot;)&#10;        broker = MessageBroker()&#10;        last_publish_time = 0&#10;        publish_interval = 1.0  # seconds)&#10;        # if self.workAreaCorners is None:&#10;        #     # print(&quot;No workAreaCorners found. Set them first.&quot;)&#10;        #     pass&#10;&#10;        while True:&#10;            self.contours, frame, _ = super().run()&#10;            # self.contours, frame, _  = self.captureFrameThreadSafe()&#10;            state = &quot;waiting_image&quot; if frame is None else &quot;ok&quot;&#10;            now = time.time()&#10;            if now - last_publish_time &gt;= publish_interval:&#10;                broker.publish(&quot;vision/state&quot;, {&quot;state&quot;: state})&#10;                last_publish_time = now&#10;            if frame is None:&#10;                continue&#10;&#10;            with self.frame_lock:&#10;                self.latest_frame = frame&#10;&#10;&#10;&#10;    def getLatestFrame(self):&#10;        &quot;&quot;&quot;&#10;            Retrieves the latest frame from the queue.&#10;&#10;            Returns:&#10;                numpy.ndarray or None: The most recent frame, or None if the queue is empty.&#10;            &quot;&quot;&quot;&#10;&#10;        with self.frame_lock:&#10;            if self.latest_frame is None:&#10;                return None&#10;            # convert to RGB before returning&#10;            return cv2.cvtColor(self.latest_frame, cv2.COLOR_BGR2RGB)&#10;&#10;        return frame&#10;&#10;    def getContours(self):&#10;        &quot;&quot;&quot;&#10;               Returns the detected contours from the most recent frame.&#10;&#10;               Returns:&#10;                   list: A list of contours detected in the most recent frame.&#10;               &quot;&quot;&quot;&#10;        return self.contours&#10;&#10;    def updateCameraSettings(self, settings: dict):&#10;        &quot;&quot;&quot;&#10;             Updates the camera settings with the provided dictionary of settings.&#10;&#10;             Args:&#10;                 settings (dict): The new camera settings to apply.&#10;&#10;             Returns:&#10;                 bool: True if the settings were updated successfully, otherwise False.&#10;             &quot;&quot;&quot;&#10;        return self.updateSettings(settings)&#10;&#10;    def getFrameWidth(self):&#10;        &quot;&quot;&quot;&#10;              Returns the width of the captured frame.&#10;&#10;              Returns:&#10;                  int: The width of the frame.&#10;              &quot;&quot;&quot;&#10;        return self.frameHeight&#10;&#10;    def getFrameHeight(self):&#10;        &quot;&quot;&quot;&#10;               Returns the height of the captured frame.&#10;&#10;               Returns:&#10;                   int: The height of the frame.&#10;               &quot;&quot;&quot;&#10;        return self.frameWidth&#10;&#10;    def getCameraToRobotMatrix(self):&#10;        &quot;&quot;&quot;&#10;              Returns the camera-to-robot transformation matrix.&#10;&#10;              Returns:&#10;                  numpy.ndarray or None: The matrix if successfully loaded, otherwise None.&#10;              &quot;&quot;&quot;&#10;        return self.cameraToRobotMatrix&#10;&#10;    def calibrateCamera(self):&#10;        &quot;&quot;&quot;&#10;               Initiates the camera calibration process.&#10;&#10;               Returns:&#10;                   bool: Calibration result indicating success or failure.&#10;               &quot;&quot;&quot;&#10;        result =  super().calibrateCamera()&#10;        print(&quot;Calibration result: &quot;, result)&#10;        return result&#10;&#10;    def calibrate(self):&#10;        &quot;&quot;&quot;&#10;        Backwards-compatible adapter: call calibrateCamera.&#10;        Some controllers expect a `calibrate()` method on the service  forward to the implemented method.&#10;        &quot;&quot;&quot;&#10;        return self.calibrateCamera()&#10;&#10;    def setRawMode(self, rawMode: bool):&#10;        &quot;&quot;&quot;&#10;                Sets the camera's raw mode, enabling or disabling it.&#10;&#10;                Args:&#10;                    rawMode (bool): True to enable raw mode, False to disable.&#10;                &quot;&quot;&quot;&#10;        print(&quot;Setting raw mode to: &quot;, rawMode)&#10;        self.rawMode = rawMode&#10;&#10;    def detectArucoMarkers(self,flip=False,image= None):&#10;        &quot;&quot;&quot;&#10;              Detects ArUco markers in the provided image.&#10;&#10;              Args:&#10;                  flip (bool): If True, the image will be flipped before processing.&#10;                  image (numpy.ndarray): The image in which to detect ArUco markers.&#10;&#10;              Returns:&#10;                  tuple: The detected ArUco marker corners, ids, and the processed image.&#10;              &quot;&quot;&quot;&#10;        return super().detectArucoMarkers(flip,image)&#10;&#10;    def captureImage(self):&#10;        &quot;&quot;&quot;&#10;              Captures an image from the camera.&#10;&#10;              Returns:&#10;                  numpy.ndarray: The captured image.&#10;              &quot;&quot;&quot;&#10;        image = super().captureImage()&#10;        return image&#10;&#10;&#10;&#10;    def detectQrCode(self):&#10;        return super().detectQrCode()&#10;&#10;    def stopContourDetection(self):&#10;        self.contourDetection = False&#10;&#10;    def startContourDetection(self):&#10;        self.contourDetection = True&#10;&#10;&#10;    def captureFrameThreadSafe(self):&#10;        &quot;&quot;&quot;&#10;        Thread-safe method to capture a single frame using the camera lock.&#10;        This prevents conflicts when multiple threads try to access camera frames.&#10;        &#10;        Returns:&#10;            tuple: (contours, frame, filtered_contours) - same as superRun() but thread-safe&#10;        &quot;&quot;&quot;&#10;        with self.frame_lock:&#10;            print(f&quot;Calling superRun() in thread {threading.current_thread().name}&quot;)&#10;            return self.superRun()&#10;&#10;    def transformRobotPointToCamera(self,message):&#10;        # message format {&quot;x&quot;: x, &quot;y&quot;: y}&#10;        x = message.get(&quot;x&quot;)&#10;        y = message.get(&quot;y&quot;)&#10;        point = (x, y)&#10;        return utils.transformSinglePointToCamera(point,self.cameraToRobotMatrix)&#10;&#10;class VisionServiceSingleton:&#10;    &quot;&quot;&quot;&#10;        A Singleton class to manage a single instance of VisionService.&#10;&#10;        This class ensures that only one instance of the VisionService is created and accessed globally.&#10;        The `get_instance` method returns the same instance every time it is called.&#10;&#10;        Methods:&#10;            get_instance():&#10;                Returns the single instance of the VisionService.&#10;        &quot;&quot;&quot;&#10;    _visionServiceInstance = None  # Static variable to hold the instance&#10;&#10;    @staticmethod&#10;    def get_instance()-&gt; _VisionService:&#10;        &quot;&quot;&quot;&#10;               Returns the singleton instance of the VisionService.&#10;&#10;               If the instance has not been created yet, it initializes the _VisionService class.&#10;&#10;               Returns:&#10;                   VisionService: The singleton instance of the VisionService.&#10;               &quot;&quot;&quot;&#10;        if VisionServiceSingleton._visionServiceInstance is None:&#10;            VisionServiceSingleton._visionServiceInstance = _VisionService()&#10;        return VisionServiceSingleton._visionServiceInstance&#10;&#10;if __name__ == &quot;__main__&quot;:&#10;    # Example usage&#10;    import cv2&#10;    vision_service = VisionServiceSingleton.get_instance()&#10;    print(&quot;After instantiation, vision_service is: &quot;, vision_service)&#10;&#10;    import threading&#10;&#10;    threading.Thread(target=vision_service.run,&#10;                     daemon=True).start()  # This will start the camera processing loop in a new thread&#10;&#10;    # You can call other methods like getLatestFrame, processContours, etc. as needed&#10;    while True:&#10;        image = vision_service.getLatestFrame()&#10;        if image is not None:&#10;            cv2.imshow(&quot;Latest Frame&quot;, image)&#10;            if cv2.waitKey(1) &amp; 0xFF == ord('q'):&#10;                break&#10;    # For example, to get the latest frame:&#10;&#10;" />
              <option name="updatedContent" value="import queue&#10;import time&#10;import numpy as np&#10;import cv2&#10;# from system.robot.RobotCalibrationService import CAMERA_TO_ROBOT_MATRIX_PATH&#10;from backend.system.utils import utils&#10;from modules.VisionSystem.VisionSystem import VisionSystem&#10;import os&#10;from modules.shared.MessageBroker import MessageBroker&#10;import threading&#10;CONFIG_FILE_PATH = os.path.join(os.path.dirname(__file__), '..','..','..','backend', 'system','storage', 'settings', 'camera_settings.json')&#10;&#10;from modules.shared.v1.topics import VisionTopics&#10;# PICKUP_AREA_CAMERA_TO_ROBOT_MATRIX_PATH = '/home/ilv/Cobot-Glue-Nozzle/VisionSystem/calibration/cameraCalibration/storage/calibration_result/pickupCamToRobotMatrix.npy'&#10;PICKUP_AREA_CAMERA_TO_ROBOT_MATRIX_PATH = os.path.join(os.path.dirname(__file__),'..','..', '..', 'VisionSystem', 'calibration', 'cameraCalibration', 'storage', 'calibration_result', 'pickupCamToRobotMatrix.npy')&#10;&#10;class _VisionService(VisionSystem):&#10;    &quot;&quot;&quot;&#10;        Vision service class for processing camera frames and detecting contours, workpieces, and ArUco markers.&#10;&#10;    This class extends the VisionSystem and handles real-time frame processing, contour detection,&#10;    filtering workpieces within a defined area, and interfacing with robot calibration and workpieces services.&#10;&#10;    Attributes:&#10;        MAX_QUEUE_SIZE (int): Maximum number of frames to store in the queue.&#10;        frameQueue (queue.Queue): A queue to store the most recent frames for processing.&#10;        contours (list): Detected contours in the current frame.&#10;        workAreaCorners (dict): Coordinates defining the workpieces pickup area.&#10;        filteredContours (list): Contours that are filtered based on the work area.&#10;        drawOverlay (bool): Flag to determine whether to draw overlays on the frame.&#10;        pickupCamToRobotMatrix (numpy.ndarray): Matrix to transform camera points to robot coordinates.&#10;&#10;    &quot;&quot;&quot;&#10;    def __init__(self):&#10;        &quot;&quot;&quot;&#10;            Initializes the VisionService with camera settings and prepares the frame queue and other attributes.&#10;&#10;            This constructor initializes the camera service, the frame queue to store the latest frames,&#10;            and loads the camera-to-robot matrix for transformation.&#10;&#10;            Args:&#10;                None&#10;            &quot;&quot;&quot;&#10;        super().__init__(configFilePath=CONFIG_FILE_PATH)&#10;&#10;        self.MAX_QUEUE_SIZE = 100  # Maximum number of frames to store in the queue&#10;        self.frameQueue = queue.Queue(maxsize=self.MAX_QUEUE_SIZE)&#10;        self.superRun = super().run&#10;        self.latest_frame = None&#10;        self.frame_lock = threading.Lock()&#10;&#10;        self.contours = None&#10;        self.workAreaCorners = None&#10;        self.filteredContours = None&#10;        self.pickupCamToRobotMatrix = self._loadPickupCamToRobotMatrix()&#10;        broker = MessageBroker()&#10;        broker.subscribe(VisionTopics.TRANSFORM_TO_CAMERA_POINT,self.transformRobotPointToCamera)&#10;&#10;    def _loadPickupCamToRobotMatrix(self):&#10;        &quot;&quot;&quot;&#10;             Loads the camera-to-robot transformation matrix from a predefined file.&#10;&#10;             The matrix is required for transforming the camera coordinates to the robot's coordinate system.&#10;&#10;             Returns:&#10;                 numpy.ndarray or None: The transformation matrix if successful, otherwise None.&#10;             &quot;&quot;&quot;&#10;        if not os.path.exists(PICKUP_AREA_CAMERA_TO_ROBOT_MATRIX_PATH):&#10;            print(f&quot;Error: Matrix file not found at {PICKUP_AREA_CAMERA_TO_ROBOT_MATRIX_PATH}&quot;)&#10;            self.pickupCamToRobotMatrix = None&#10;            # return None&#10;&#10;        try:&#10;            self.pickupCamToRobotMatrix = np.load(PICKUP_AREA_CAMERA_TO_ROBOT_MATRIX_PATH)&#10;            # print(&quot;Matrix loaded:&quot;, self.pickupCamToRobotMatrix)&#10;        except Exception as e:&#10;            print(f&quot;Error loading matrix: {e}&quot;)&#10;            self.pickupCamToRobotMatrix = None&#10;&#10;        return self.pickupCamToRobotMatrix&#10;&#10;    def run(self):&#10;        &quot;&quot;&quot;&#10;              Main loop that continuously processes frames from the camera.&#10;&#10;              It detects contours, applies overlays if necessary, and processes workpieces within the defined work area.&#10;&#10;              This method keeps running indefinitely, so it should be called in a separate thread or process.&#10;&#10;              Returns:&#10;                  None&#10;              &quot;&quot;&quot;&#10;        print(&quot;Starting VisionService run loop...&quot;)&#10;        broker = MessageBroker()&#10;        last_publish_time = 0&#10;        publish_interval = 1.0  # seconds)&#10;        # if self.workAreaCorners is None:&#10;        #     # print(&quot;No workAreaCorners found. Set them first.&quot;)&#10;        #     pass&#10;&#10;        while True:&#10;            self.contours, frame, _ = super().run()&#10;            # self.contours, frame, _  = self.captureFrameThreadSafe()&#10;            state = &quot;waiting_image&quot; if frame is None else &quot;ok&quot;&#10;            now = time.time()&#10;            if now - last_publish_time &gt;= publish_interval:&#10;                broker.publish(&quot;vision/state&quot;, {&quot;state&quot;: state})&#10;                last_publish_time = now&#10;            if frame is None:&#10;                continue&#10;&#10;            with self.frame_lock:&#10;                self.latest_frame = frame&#10;&#10;&#10;&#10;    def getLatestFrame(self):&#10;        &quot;&quot;&quot;&#10;            Retrieves the latest frame from the queue.&#10;&#10;            Returns:&#10;                numpy.ndarray or None: The most recent frame, or None if the queue is empty.&#10;            &quot;&quot;&quot;&#10;&#10;        with self.frame_lock:&#10;            if self.latest_frame is None:&#10;                return None&#10;            # convert to RGB before returning&#10;            return cv2.cvtColor(self.latest_frame, cv2.COLOR_BGR2RGB)&#10;&#10;        return frame&#10;&#10;    def getContours(self):&#10;        &quot;&quot;&quot;&#10;               Returns the detected contours from the most recent frame.&#10;&#10;               Returns:&#10;                   list: A list of contours detected in the most recent frame.&#10;               &quot;&quot;&quot;&#10;        return self.contours&#10;&#10;    def updateCameraSettings(self, settings: dict):&#10;        &quot;&quot;&quot;&#10;             Updates the camera settings with the provided dictionary of settings.&#10;&#10;             Args:&#10;                 settings (dict): The new camera settings to apply.&#10;&#10;             Returns:&#10;                 bool: True if the settings were updated successfully, otherwise False.&#10;             &quot;&quot;&quot;&#10;        return self.updateSettings(settings)&#10;&#10;    def getFrameWidth(self):&#10;        &quot;&quot;&quot;&#10;              Returns the width of the captured frame.&#10;&#10;              Returns:&#10;                  int: The width of the frame.&#10;              &quot;&quot;&quot;&#10;        return self.frameHeight&#10;&#10;    def getFrameHeight(self):&#10;        &quot;&quot;&quot;&#10;               Returns the height of the captured frame.&#10;&#10;               Returns:&#10;                   int: The height of the frame.&#10;               &quot;&quot;&quot;&#10;        return self.frameWidth&#10;&#10;    def getCameraToRobotMatrix(self):&#10;        &quot;&quot;&quot;&#10;              Returns the camera-to-robot transformation matrix.&#10;&#10;              Returns:&#10;                  numpy.ndarray or None: The matrix if successfully loaded, otherwise None.&#10;              &quot;&quot;&quot;&#10;        return self.cameraToRobotMatrix&#10;&#10;    def calibrateCamera(self):&#10;        &quot;&quot;&quot;&#10;               Initiates the camera calibration process.&#10;&#10;               Returns:&#10;                   bool: Calibration result indicating success or failure.&#10;               &quot;&quot;&quot;&#10;        result =  super().calibrateCamera()&#10;        print(&quot;Calibration result: &quot;, result)&#10;        return result&#10;&#10;    def calibrate(self):&#10;        &quot;&quot;&quot;&#10;        Backwards-compatible adapter: call calibrateCamera.&#10;        Some controllers expect a `calibrate()` method on the service  forward to the implemented method.&#10;        &quot;&quot;&quot;&#10;        return self.calibrateCamera()&#10;&#10;    def setRawMode(self, rawMode: bool):&#10;        &quot;&quot;&quot;&#10;                Sets the camera's raw mode, enabling or disabling it.&#10;&#10;                Args:&#10;                    rawMode (bool): True to enable raw mode, False to disable.&#10;                &quot;&quot;&quot;&#10;        print(&quot;Setting raw mode to: &quot;, rawMode)&#10;        self.rawMode = rawMode&#10;&#10;    def detectArucoMarkers(self,flip=False,image= None):&#10;        &quot;&quot;&quot;&#10;              Detects ArUco markers in the provided image.&#10;&#10;              Args:&#10;                  flip (bool): If True, the image will be flipped before processing.&#10;                  image (numpy.ndarray): The image in which to detect ArUco markers.&#10;&#10;              Returns:&#10;                  tuple: The detected ArUco marker corners, ids, and the processed image.&#10;              &quot;&quot;&quot;&#10;        return super().detectArucoMarkers(flip,image)&#10;&#10;    def captureImage(self):&#10;        &quot;&quot;&quot;&#10;              Captures an image from the camera.&#10;&#10;              Returns:&#10;                  numpy.ndarray: The captured image.&#10;              &quot;&quot;&quot;&#10;        image = super().captureImage()&#10;        return image&#10;&#10;&#10;&#10;    def detectQrCode(self):&#10;        return super().detectQrCode()&#10;&#10;    def stopContourDetection(self):&#10;        self.contourDetection = False&#10;&#10;    def startContourDetection(self):&#10;        self.contourDetection = True&#10;&#10;&#10;    def captureFrameThreadSafe(self):&#10;        &quot;&quot;&quot;&#10;        Thread-safe method to capture a single frame using the camera lock.&#10;        This prevents conflicts when multiple threads try to access camera frames.&#10;        &#10;        Returns:&#10;            tuple: (contours, frame, filtered_contours) - same as superRun() but thread-safe&#10;        &quot;&quot;&quot;&#10;        with self.frame_lock:&#10;            print(f&quot;Calling superRun() in thread {threading.current_thread().name}&quot;)&#10;            return self.superRun()&#10;&#10;    def transformRobotPointToCamera(self,message):&#10;        # message format {&quot;x&quot;: x, &quot;y&quot;: y}&#10;        x = message.get(&quot;x&quot;)&#10;        y = message.get(&quot;y&quot;)&#10;        point = (x, y)&#10;        return utils.transformSinglePointToCamera(point,self.cameraToRobotMatrix)&#10;&#10;class VisionServiceSingleton:&#10;    &quot;&quot;&quot;&#10;        A Singleton class to manage a single instance of VisionService.&#10;&#10;        This class ensures that only one instance of the VisionService is created and accessed globally.&#10;        The `get_instance` method returns the same instance every time it is called.&#10;&#10;        Methods:&#10;            get_instance():&#10;                Returns the single instance of the VisionService.&#10;        &quot;&quot;&quot;&#10;    _visionServiceInstance = None  # Static variable to hold the instance&#10;&#10;    @staticmethod&#10;    def get_instance()-&gt; _VisionService:&#10;        &quot;&quot;&quot;&#10;               Returns the singleton instance of the VisionService.&#10;&#10;               If the instance has not been created yet, it initializes the _VisionService class.&#10;&#10;               Returns:&#10;                   VisionService: The singleton instance of the VisionService.&#10;               &quot;&quot;&quot;&#10;        if VisionServiceSingleton._visionServiceInstance is None:&#10;            VisionServiceSingleton._visionServiceInstance = _VisionService()&#10;        return VisionServiceSingleton._visionServiceInstance&#10;&#10;if __name__ == &quot;__main__&quot;:&#10;    # Example usage&#10;    import cv2&#10;    vision_service = VisionServiceSingleton.get_instance()&#10;    print(&quot;After instantiation, vision_service is: &quot;, vision_service)&#10;&#10;    import threading&#10;&#10;    threading.Thread(target=vision_service.run,&#10;                     daemon=True).start()  # This will start the camera processing loop in a new thread&#10;&#10;    # You can call other methods like getLatestFrame, processContours, etc. as needed&#10;    while True:&#10;        image = vision_service.getLatestFrame()&#10;        if image is not None:&#10;            cv2.imshow(&quot;Latest Frame&quot;, image)&#10;            if cv2.waitKey(1) &amp; 0xFF == ord('q'):&#10;                break&#10;    # For example, to get the latest frame:&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="/tmp/test_robot_repo.py">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="/tmp/test_robot_repo.py" />
            </PendingDiffInfo>
          </value>
        </entry>
      </map>
    </option>
  </component>
</project>