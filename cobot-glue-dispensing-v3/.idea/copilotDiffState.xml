<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="CopilotDiffPersistence">
    <option name="pendingDiffs">
      <map>
        <entry key="$PROJECT_DIR$/src/applications/glue_dispensing_application/workpiece/GlueWorkpiece.py">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/applications/glue_dispensing_application/workpiece/GlueWorkpiece.py" />
              <option name="originalContent" value="import numpy as np&#10;&#10;from applications.glue_dispensing_application.workpiece.GlueWorkpieceField import GlueWorkpieceField&#10;from core.model.workpiece.Workpiece import BaseWorkpiece&#10;from modules.shared.core.interfaces.JsonSerializable import JsonSerializable&#10;from modules.shared.tools.GlueCell import GlueType&#10;from modules.shared.tools.enums.Gripper import Gripper&#10;from modules.shared.tools.enums.Program import Program&#10;from modules.shared.tools.enums.ToolID import ToolID&#10;&#10;&#10;class GlueWorkpiece(BaseWorkpiece, JsonSerializable):&#10;    &quot;&quot;&quot;&#10;        A class representing a workpieces in a glue dispensing application, including its properties such as ID,&#10;        name, description, tool, gripper, glue type, program, material, contour, offset, height, nozzles,&#10;        contour area, and spray pattern.&#10;&#10;        Inherits from BaseWorkpiece and JsonSerializable for basic workpieces functionality and serialization support.&#10;        &quot;&quot;&quot;&#10;    def __init__(self, workpieceId, name, description, toolID, gripperID, glueType, program, material, contour, offset,&#10;                 height, nozzles, contourArea, glueQty, sprayWidth, pickupPoint, sprayPattern=None):&#10;        &quot;&quot;&quot;&#10;              Initializes a Workpiece object with specified parameters.&#10;&#10;              Args:&#10;                  workpieceId (int): The unique identifier for the workpieces.&#10;                  name (str): The name of the workpieces.&#10;                  description (str): A description of the workpieces.&#10;                  toolID (ToolID): The tool ID associated with the workpieces.&#10;                  gripperID (Gripper): The gripper ID associated with the workpieces.&#10;                  glueType (GlueType): The type of glue used in the workpieces.&#10;                  program (Program): The program associated with the workpieces.&#10;                  material (str): The material of the workpieces.&#10;                  contour (list of np.ndarray): The contour points of the workpieces.&#10;                  offset (float): The offset of the workpieces.&#10;                  height (float): The height of the workpieces.&#10;                  nozzles (list): The list of nozzles associated with the workpieces.&#10;                  contourArea (float): The area of the contour.&#10;                  sprayPattern (optional, list): The spray pattern used for the workpieces. Defaults to an empty list if None.&#10;&#10;              &quot;&quot;&quot;&#10;        super().__init__(workpieceId, contour)&#10;        if sprayPattern is None:&#10;            sprayPattern = []&#10;        self.workpieceId = workpieceId&#10;        self.name = name&#10;        self.description = description&#10;        self.toolID = toolID&#10;        self.gripperID = gripperID&#10;        self.glueType = glueType&#10;        self.program = program&#10;        self.material = material&#10;        self.contour = contour  # This should be a list of nd arrays&#10;        self.offset = offset&#10;        self.height = height&#10;        self.sprayPattern = sprayPattern&#10;        self.contourArea = contourArea&#10;        self.nozzles = nozzles&#10;        self.glueQty = glueQty&#10;        self.sprayWidth = sprayWidth&#10;        self.pickupPoint = pickupPoint  # Placeholder for pickup point&#10;&#10;    def __str__(self):&#10;        return (f&quot;Workpiece(ID: {self.workpieceId}, &quot;&#10;                f&quot;Name: {self.name}, &quot;&#10;                f&quot;Description: {self.description}, &quot;&#10;                f&quot;Tool: {self.toolID.value if hasattr(self.toolID, 'value') else self.toolID}, &quot;&#10;                f&quot;Gripper: {self.gripperID.value if hasattr(self.gripperID, 'value') else self.gripperID}, &quot;&#10;                f&quot;Material: {self.material}, &quot;&#10;                f&quot;Height: {self.height}, &quot;&#10;                f&quot;ContourArea: {self.contourArea}), &quot;&#10;                f&quot;PickupPoint: {self.pickupPoint})&quot;)&#10;&#10;    def get_spray_pattern_contours(self):&#10;        &quot;&quot;&quot;&#10;        Return list of spray pattern contour entries.&#10;        Each entry is a dict: {&quot;contour&quot;: np.ndarray, &quot;settings&quot;: dict}&#10;        &quot;&quot;&quot;&#10;        contours = []&#10;        for entry in self.sprayPattern.get(&quot;Contour&quot;, []):&#10;            contour_points = np.array(entry.get(&quot;contour&quot;, []), dtype=np.float32).reshape(-1, 2)&#10;            contours.append({&#10;                &quot;contour&quot;: contour_points,&#10;                &quot;settings&quot;: entry.get(&quot;settings&quot;, {})&#10;            })&#10;        return contours&#10;&#10;&#10;    def get_spray_pattern_fills(self):&#10;        &quot;&quot;&quot;&#10;        Return list of spray pattern fill entries.&#10;        Each entry is a dict: {&quot;contou  r&quot;: np.ndarray, &quot;settings&quot;: dict}&#10;        &quot;&quot;&quot;&#10;        fills = []&#10;        for entry in self.sprayPattern.get(&quot;Fill&quot;, []):&#10;            contour_points = np.array(entry.get(&quot;contour&quot;, []), dtype=np.float32).reshape(-1, 2)&#10;            fills.append({&#10;                &quot;contour&quot;: contour_points,&#10;                &quot;settings&quot;: entry.get(&quot;settings&quot;, {})&#10;            })&#10;        return fills&#10;&#10;    def set_main_contour(self, contour):&#10;      self.contour[&quot;contour&quot;] = contour&#10;&#10;&#10;&#10;    def get_main_contour(self):&#10;        &quot;&quot;&quot;&#10;        Return the main contour without settings.&#10;        Handles both dict and direct format of self.contour.&#10;        Returns numpy array in proper format for nesting operations.&#10;        &quot;&quot;&quot;&#10;&#10;        if isinstance(self.contour, dict) and &quot;contour&quot; in self.contour:&#10;            # Handle dict format: {&quot;contour&quot;: points, &quot;settings&quot;: {...}}&#10;            contour_data = self.contour[&quot;contour&quot;]&#10;        else:&#10;            # Handle direct format: contour data directly&#10;            contour_data = self.contour&#10;&#10;        # Convert to numpy array format expected by nesting (N, 1, 2)&#10;        if isinstance(contour_data, np.ndarray):&#10;            if len(contour_data.shape) == 3 and contour_data.shape[1] == 1:&#10;                # Already in correct format (N, 1, 2)&#10;                return contour_data&#10;            elif len(contour_data.shape) == 2:&#10;                # Convert from (N, 2) to (N, 1, 2)&#10;                return contour_data.reshape(-1, 1, 2)&#10;            else:&#10;                # Flatten and reshape&#10;                return contour_data.reshape(-1, 2).reshape(-1, 1, 2)&#10;        else:&#10;            # Handle list format - convert to numpy array&#10;            flat_points = []&#10;            for point in contour_data:&#10;                if isinstance(point, (list, tuple, np.ndarray)):&#10;                    # Handle nested structures like [[[x, y]]] or [[x, y]]&#10;                    while isinstance(point, (list, tuple, np.ndarray)) and len(point) == 1:&#10;                        point = point[0]&#10;                    if len(point) &gt;= 2:&#10;                        # Recursively flatten nested coordinates&#10;                        x, y = point[0], point[1]&#10;                        while isinstance(x, (list, tuple, np.ndarray)):&#10;                            x = x[0] if len(x) &gt; 0 else 0&#10;                        while isinstance(y, (list, tuple, np.ndarray)):&#10;                            y = y[0] if len(y) &gt; 0 else 0&#10;                        flat_points.append([float(x), float(y)])&#10;&#10;            if flat_points:&#10;                return np.array(flat_points, dtype=np.float32).reshape(-1, 1, 2)&#10;            else:&#10;                return np.array([], dtype=np.float32).reshape(0, 1, 2)&#10;&#10;    def get_main_contour_settings(self):&#10;        &quot;&quot;&quot;&#10;        Return the settings associated with the main contour.&#10;        If no settings are found, return an empty dictionary.&#10;        &quot;&quot;&quot;&#10;        if isinstance(self.contour, dict) and &quot;settings&quot; in self.contour:&#10;            return self.contour[&quot;settings&quot;]&#10;        return {}&#10;&#10;    @staticmethod&#10;    def serialize(workpiece):&#10;        def convert_ndarray_to_list(obj):&#10;            if isinstance(obj, np.ndarray):&#10;                if obj.ndim == 2 and obj.shape[1] == 2:&#10;                    obj = obj.reshape(-1, 1, 2)  # ✅ normalize before list conversion&#10;                return obj.tolist()&#10;            elif isinstance(obj, dict) and &quot;contour&quot; in obj:&#10;                contour = obj[&quot;contour&quot;]&#10;                if isinstance(contour, np.ndarray) and contour.ndim == 2 and contour.shape[1] == 2:&#10;                    contour = contour.reshape(-1, 1, 2)&#10;                return {&#10;                    &quot;contour&quot;: convert_ndarray_to_list(contour),&#10;                    &quot;settings&quot;: dict(obj.get(&quot;settings&quot;, {}))&#10;                }&#10;            elif isinstance(obj, list):&#10;                return [convert_ndarray_to_list(item) for item in obj]&#10;            return obj&#10;&#10;        # ✅ Handle dict contour directly&#10;        contour_data = convert_ndarray_to_list(workpiece.contour)&#10;&#10;        if isinstance(workpiece.sprayPattern, dict):&#10;            spray_pattern_dict = {&#10;                key: [convert_ndarray_to_list(seg) for seg in val]&#10;                for key, val in workpiece.sprayPattern.items()&#10;            }&#10;        else:&#10;            spray_pattern_dict = convert_ndarray_to_list(workpiece.sprayPattern)&#10;&#10;        workpiece.contour = contour_data&#10;        workpiece.sprayPattern = spray_pattern_dict&#10;        return workpiece.to_dict()&#10;&#10;    @staticmethod&#10;    def deserialize(data):&#10;        def convert_list_to_ndarray(obj):&#10;            if isinstance(obj, dict) and &quot;contour&quot; in obj:&#10;                arr = np.array(obj[&quot;contour&quot;], dtype=np.float32)&#10;&#10;                # ✅ Normalize shape to (N, 1, 2)&#10;                if arr.ndim == 1 and arr.shape[0] == 2:&#10;                    arr = arr.reshape(1, 1, 2)  # single point → (1, 1, 2)&#10;                elif arr.ndim == 2 and arr.shape[1] == 2:&#10;                    arr = arr.reshape(-1, 1, 2)  # (N, 2) → (N, 1, 2)&#10;&#10;                return {&#10;                    &quot;contour&quot;: arr,&#10;                    &quot;settings&quot;: obj.get(&quot;settings&quot;, {})&#10;                }&#10;&#10;            elif isinstance(obj, list):&#10;                return [convert_list_to_ndarray(item) for item in obj]&#10;&#10;            return obj&#10;&#10;        # ----- Main contour -----&#10;        raw_contour = data.get(GlueWorkpieceField.CONTOUR.value, [])&#10;&#10;        if isinstance(raw_contour, dict):&#10;            contour = convert_list_to_ndarray(raw_contour)&#10;        elif isinstance(raw_contour, list):&#10;            contour = [convert_list_to_ndarray(seg) for seg in raw_contour]&#10;        else:&#10;            contour = raw_contour  # unexpected type, leave as-is&#10;&#10;        # ----- Spray pattern -----&#10;        raw_spray_pattern = data.get(GlueWorkpieceField.SPRAY_PATTERN.value, {})&#10;        spray_pattern = {}&#10;&#10;        if isinstance(raw_spray_pattern, dict):&#10;            for key, pattern in raw_spray_pattern.items():&#10;                spray_pattern[key] = [convert_list_to_ndarray(seg) for seg in pattern]&#10;        else:&#10;            spray_pattern = raw_spray_pattern&#10;&#10;        # ----- Build workpiece -----&#10;        workpiece = GlueWorkpiece.from_dict(data)&#10;        workpiece.contour = contour&#10;        workpiece.sprayPattern = spray_pattern&#10;        return workpiece&#10;&#10;    def to_dict(self)-&gt; dict:&#10;        &quot;&quot;&quot;&#10;                Convert the Workpiece object into a dictionary representation.&#10;&#10;                Returns:&#10;                    dict: A dictionary containing the Workpiece's properties, suitable for serialization or storage.&#10;                &quot;&quot;&quot;&#10;        return {&#10;            GlueWorkpieceField.WORKPIECE_ID.value: self.workpieceId,&#10;            GlueWorkpieceField.NAME.value: self.name,&#10;            GlueWorkpieceField.DESCRIPTION.value: self.description,&#10;            GlueWorkpieceField.TOOL_ID.value: self.toolID.value,&#10;            GlueWorkpieceField.GRIPPER_ID.value: self.gripperID.value,&#10;            GlueWorkpieceField.GLUE_TYPE.value: self.glueType.value,&#10;            GlueWorkpieceField.PROGRAM.value: self.program.value,&#10;            GlueWorkpieceField.MATERIAL.value: self.material,&#10;            GlueWorkpieceField.CONTOUR.value: self.contour,&#10;            GlueWorkpieceField.OFFSET.value: self.offset,&#10;            GlueWorkpieceField.HEIGHT.value: self.height,&#10;            GlueWorkpieceField.GLUE_QTY.value: self.glueQty,&#10;            GlueWorkpieceField.SPRAY_WIDTH.value: self.sprayWidth,&#10;            GlueWorkpieceField.PICKUP_POINT.value: self.pickupPoint,&#10;            GlueWorkpieceField.SPRAY_PATTERN.value: self.sprayPattern,&#10;            GlueWorkpieceField.CONTOUR_AREA.value: self.contourArea,&#10;            GlueWorkpieceField.NOZZLES.value: self.nozzles&#10;&#10;        }&#10;&#10;    @staticmethod&#10;    def flatten_spray_pattern(obj):&#10;        &quot;&quot;&quot;&#10;             Flatten nested spray pattern lists into a single list.&#10;&#10;             Args:&#10;                 obj (list): The spray pattern (possibly nested) to be flattened.&#10;&#10;             Returns:&#10;                 list: A flattened list containing all points from the spray pattern.&#10;             &quot;&quot;&quot;&#10;        if isinstance(obj, list):&#10;            flat_obj = []&#10;            for item in obj:&#10;                if isinstance(item, list):&#10;                    flat_obj.extend(GlueWorkpiece.flatten_spray_pattern(item))&#10;                else:&#10;                    flat_obj.append(item)&#10;            return flat_obj&#10;        return [obj]&#10;&#10;    @staticmethod&#10;    def reshape_spray_pattern(obj):&#10;        &quot;&quot;&quot;&#10;        Reshape spray pattern list into list of (N, 1, 2) numpy arrays.&#10;&#10;        Args:&#10;            obj (list): The spray pattern, either a single contour or a list of contours.&#10;&#10;        Returns:&#10;            list: A list of numpy arrays representing the reshaped spray pattern contours.&#10;&#10;        Raises:&#10;            ValueError: If the spray pattern format is invalid or unrecognized.&#10;        &quot;&quot;&quot;&#10;        if not obj:&#10;            return []&#10;&#10;        # If it's a single contour, flatten and reshape it&#10;        if all(isinstance(pt, (list, np.ndarray)) and len(pt) == 2 for pt in obj):&#10;            grouped = np.array(obj, dtype=np.float32).reshape(-1, 1, 2)&#10;            return [grouped]&#10;&#10;        # If it's a list of contours&#10;        if isinstance(obj, list) and all(isinstance(c, list) for c in obj):&#10;            result = []&#10;            for contour in obj:&#10;                if not contour:&#10;                    continue&#10;                flat = GlueWorkpiece.flatten_spray_pattern(contour)&#10;                if all(isinstance(x, (int, float)) for x in flat):&#10;                    grouped = [[flat[i], flat[i + 1]] for i in range(0, len(flat), 2)]&#10;                elif all(isinstance(x, list) and len(x) == 2 for x in flat):&#10;                    grouped = flat&#10;                else:&#10;                    raise ValueError(f&quot;Invalid spray pattern shape: {flat}&quot;)&#10;                result.append(np.array(grouped, dtype=np.float32).reshape(-1, 1, 2))&#10;            return result&#10;&#10;        raise ValueError(f&quot;Unknown spray pattern format: {obj}&quot;)&#10;&#10;    @staticmethod&#10;    def from_dict(data: dict):&#10;        &quot;&quot;&quot;&#10;        Deserialize a dictionary into a Workpiece object.&#10;&#10;        Args:&#10;          data (dict): A dictionary representation of a Workpiece.&#10;&#10;        Returns:&#10;          GlueWorkpiece: The reconstructed Workpiece object.&#10;        &quot;&quot;&quot;&#10;        return GlueWorkpiece(&#10;            workpieceId=data[GlueWorkpieceField.WORKPIECE_ID.value],&#10;            name=data[GlueWorkpieceField.NAME.value],&#10;            description=data[GlueWorkpieceField.DESCRIPTION.value],&#10;            toolID=ToolID(data[GlueWorkpieceField.TOOL_ID.value]),&#10;            gripperID=Gripper(data[GlueWorkpieceField.GRIPPER_ID.value]),&#10;            glueType=GlueType(data[GlueWorkpieceField.GLUE_TYPE.value]),&#10;            program=Program(data[GlueWorkpieceField.PROGRAM.value]),&#10;            material=data[GlueWorkpieceField.MATERIAL.value],&#10;            contour=data[GlueWorkpieceField.CONTOUR.value],&#10;            offset=data[GlueWorkpieceField.OFFSET.value],&#10;            height=data.get(GlueWorkpieceField.HEIGHT.value, 4),&#10;            pickupPoint=data.get(GlueWorkpieceField.PICKUP_POINT.value, None),&#10;            nozzles=data.get(GlueWorkpieceField.NOZZLES.value, []),  # Setting nozzles to empty list if missing&#10;            contourArea=data[GlueWorkpieceField.CONTOUR_AREA.value],&#10;            glueQty=data[GlueWorkpieceField.GLUE_QTY.value],&#10;            sprayWidth=data[GlueWorkpieceField.SPRAY_WIDTH.value],&#10;            sprayPattern=data.get(GlueWorkpieceField.SPRAY_PATTERN.value, []),&#10;&#10;            # Setting spray pattern to empty list if missing&#10;        )&#10;" />
              <option name="updatedContent" value="import numpy as np&#10;&#10;from applications.glue_dispensing_application.workpiece.GlueWorkpieceField import GlueWorkpieceField&#10;from core.model.workpiece.Workpiece import BaseWorkpiece&#10;from modules.shared.core.interfaces.JsonSerializable import JsonSerializable&#10;from modules.shared.tools.GlueCell import GlueType&#10;from modules.shared.tools.enums.Gripper import Gripper&#10;from modules.shared.tools.enums.Program import Program&#10;from modules.shared.tools.enums.ToolID import ToolID&#10;&#10;&#10;class GlueWorkpiece(BaseWorkpiece, JsonSerializable):&#10;    &quot;&quot;&quot;&#10;        A class representing a workpieces in a glue dispensing application, including its properties such as ID,&#10;        name, description, tool, gripper, glue type, program, material, contour, offset, height, nozzles,&#10;        contour area, and spray pattern.&#10;&#10;        Inherits from BaseWorkpiece and JsonSerializable for basic workpieces functionality and serialization support.&#10;        &quot;&quot;&quot;&#10;    def __init__(self, workpieceId, name, description, toolID, gripperID, glueType, program, material, contour, offset,&#10;                 height, nozzles, contourArea, glueQty, sprayWidth, pickupPoint, sprayPattern=None):&#10;        &quot;&quot;&quot;&#10;              Initializes a Workpiece object with specified parameters.&#10;&#10;              Args:&#10;                  workpieceId (int): The unique identifier for the workpieces.&#10;                  name (str): The name of the workpieces.&#10;                  description (str): A description of the workpieces.&#10;                  toolID (ToolID): The tool ID associated with the workpieces.&#10;                  gripperID (Gripper): The gripper ID associated with the workpieces.&#10;                  glueType (GlueType): The type of glue used in the workpieces.&#10;                  program (Program): The program associated with the workpieces.&#10;                  material (str): The material of the workpieces.&#10;                  contour (list of np.ndarray): The contour points of the workpieces.&#10;                  offset (float): The offset of the workpieces.&#10;                  height (float): The height of the workpieces.&#10;                  nozzles (list): The list of nozzles associated with the workpieces.&#10;                  contourArea (float): The area of the contour.&#10;                  sprayPattern (optional, list): The spray pattern used for the workpieces. Defaults to an empty list if None.&#10;&#10;              &quot;&quot;&quot;&#10;        super().__init__(workpieceId, contour)&#10;        if sprayPattern is None:&#10;            sprayPattern = []&#10;        self.workpieceId = workpieceId&#10;        self.name = name&#10;        self.description = description&#10;        self.toolID = toolID&#10;        self.gripperID = gripperID&#10;        self.glueType = glueType&#10;        self.program = program&#10;        self.material = material&#10;        self.contour = contour  # This should be a list of nd arrays&#10;        self.offset = offset&#10;        self.height = height&#10;        self.sprayPattern = sprayPattern&#10;        self.contourArea = contourArea&#10;        self.nozzles = nozzles&#10;        self.glueQty = glueQty&#10;        self.sprayWidth = sprayWidth&#10;        self.pickupPoint = pickupPoint  # Placeholder for pickup point&#10;&#10;    def __str__(self):&#10;        return (f&quot;Workpiece(ID: {self.workpieceId}, &quot;&#10;                f&quot;Name: {self.name}, &quot;&#10;                f&quot;Description: {self.description}, &quot;&#10;                f&quot;Tool: {self.toolID.value if hasattr(self.toolID, 'value') else self.toolID}, &quot;&#10;                f&quot;Gripper: {self.gripperID.value if hasattr(self.gripperID, 'value') else self.gripperID}, &quot;&#10;                f&quot;Material: {self.material}, &quot;&#10;                f&quot;Height: {self.height}, &quot;&#10;                f&quot;ContourArea: {self.contourArea}), &quot;&#10;                f&quot;PickupPoint: {self.pickupPoint})&quot;)&#10;&#10;    def get_spray_pattern_contours(self):&#10;        &quot;&quot;&quot;&#10;        Return list of spray pattern contour entries.&#10;        Each entry is a dict: {&quot;contour&quot;: np.ndarray, &quot;settings&quot;: dict}&#10;        &quot;&quot;&quot;&#10;        contours = []&#10;        for entry in self.sprayPattern.get(&quot;Contour&quot;, []):&#10;            contour_points = np.array(entry.get(&quot;contour&quot;, []), dtype=np.float32).reshape(-1, 2)&#10;            contours.append({&#10;                &quot;contour&quot;: contour_points,&#10;                &quot;settings&quot;: entry.get(&quot;settings&quot;, {})&#10;            })&#10;        return contours&#10;&#10;&#10;    def get_spray_pattern_fills(self):&#10;        &quot;&quot;&quot;&#10;        Return list of spray pattern fill entries.&#10;        Each entry is a dict: {&quot;contou  r&quot;: np.ndarray, &quot;settings&quot;: dict}&#10;        &quot;&quot;&quot;&#10;        fills = []&#10;        for entry in self.sprayPattern.get(&quot;Fill&quot;, []):&#10;            contour_points = np.array(entry.get(&quot;contour&quot;, []), dtype=np.float32).reshape(-1, 2)&#10;            fills.append({&#10;                &quot;contour&quot;: contour_points,&#10;                &quot;settings&quot;: entry.get(&quot;settings&quot;, {})&#10;            })&#10;        return fills&#10;&#10;    def set_main_contour(self, contour):&#10;      self.contour[&quot;contour&quot;] = contour&#10;&#10;&#10;&#10;    def get_main_contour(self):&#10;        &quot;&quot;&quot;&#10;        Return the main contour without settings.&#10;        Handles both dict and direct format of self.contour.&#10;        Returns numpy array in proper format for nesting operations.&#10;        &quot;&quot;&quot;&#10;&#10;        if isinstance(self.contour, dict) and &quot;contour&quot; in self.contour:&#10;            # Handle dict format: {&quot;contour&quot;: points, &quot;settings&quot;: {...}}&#10;            contour_data = self.contour[&quot;contour&quot;]&#10;        else:&#10;            # Handle direct format: contour data directly&#10;            contour_data = self.contour&#10;&#10;        # Convert to numpy array format expected by nesting (N, 1, 2)&#10;        if isinstance(contour_data, np.ndarray):&#10;            if len(contour_data.shape) == 3 and contour_data.shape[1] == 1:&#10;                # Already in correct format (N, 1, 2)&#10;                return contour_data&#10;            elif len(contour_data.shape) == 2:&#10;                # Convert from (N, 2) to (N, 1, 2)&#10;                return contour_data.reshape(-1, 1, 2)&#10;            else:&#10;                # Flatten and reshape&#10;                return contour_data.reshape(-1, 2).reshape(-1, 1, 2)&#10;        else:&#10;            # Handle list format - convert to numpy array&#10;            flat_points = []&#10;            for point in contour_data:&#10;                if isinstance(point, (list, tuple, np.ndarray)):&#10;                    # Handle nested structures like [[[x, y]]] or [[x, y]]&#10;                    while isinstance(point, (list, tuple, np.ndarray)) and len(point) == 1:&#10;                        point = point[0]&#10;                    if len(point) &gt;= 2:&#10;                        # Recursively flatten nested coordinates&#10;                        x, y = point[0], point[1]&#10;                        while isinstance(x, (list, tuple, np.ndarray)):&#10;                            x = x[0] if len(x) &gt; 0 else 0&#10;                        while isinstance(y, (list, tuple, np.ndarray)):&#10;                            y = y[0] if len(y) &gt; 0 else 0&#10;                        flat_points.append([float(x), float(y)])&#10;&#10;            if flat_points:&#10;                return np.array(flat_points, dtype=np.float32).reshape(-1, 1, 2)&#10;            else:&#10;                return np.array([], dtype=np.float32).reshape(0, 1, 2)&#10;&#10;    def get_main_contour_settings(self):&#10;        &quot;&quot;&quot;&#10;        Return the settings associated with the main contour.&#10;        If no settings are found, return an empty dictionary.&#10;        &quot;&quot;&quot;&#10;        if isinstance(self.contour, dict) and &quot;settings&quot; in self.contour:&#10;            return self.contour[&quot;settings&quot;]&#10;        return {}&#10;&#10;    @staticmethod&#10;    def serialize(workpiece):&#10;        def convert_ndarray_to_list(obj):&#10;            if isinstance(obj, np.ndarray):&#10;                if obj.ndim == 2 and obj.shape[1] == 2:&#10;                    obj = obj.reshape(-1, 1, 2)  # ✅ normalize before list conversion&#10;                return obj.tolist()&#10;            elif isinstance(obj, dict) and &quot;contour&quot; in obj:&#10;                contour = obj[&quot;contour&quot;]&#10;                if isinstance(contour, np.ndarray) and contour.ndim == 2 and contour.shape[1] == 2:&#10;                    contour = contour.reshape(-1, 1, 2)&#10;                return {&#10;                    &quot;contour&quot;: convert_ndarray_to_list(contour),&#10;                    &quot;settings&quot;: dict(obj.get(&quot;settings&quot;, {}))&#10;                }&#10;            elif isinstance(obj, list):&#10;                return [convert_ndarray_to_list(item) for item in obj]&#10;            return obj&#10;&#10;        # ✅ Handle dict contour directly&#10;        contour_data = convert_ndarray_to_list(workpiece.contour)&#10;&#10;        if isinstance(workpiece.sprayPattern, dict):&#10;            spray_pattern_dict = {&#10;                key: [convert_ndarray_to_list(seg) for seg in val]&#10;                for key, val in workpiece.sprayPattern.items()&#10;            }&#10;        else:&#10;            spray_pattern_dict = convert_ndarray_to_list(workpiece.sprayPattern)&#10;&#10;        workpiece.contour = contour_data&#10;        workpiece.sprayPattern = spray_pattern_dict&#10;        return workpiece.to_dict()&#10;&#10;    @staticmethod&#10;    def deserialize(data):&#10;        def convert_list_to_ndarray(obj):&#10;            if isinstance(obj, dict) and &quot;contour&quot; in obj:&#10;                arr = np.array(obj[&quot;contour&quot;], dtype=np.float32)&#10;&#10;                # ✅ Normalize shape to (N, 1, 2)&#10;                if arr.ndim == 1 and arr.shape[0] == 2:&#10;                    arr = arr.reshape(1, 1, 2)  # single point → (1, 1, 2)&#10;                elif arr.ndim == 2 and arr.shape[1] == 2:&#10;                    arr = arr.reshape(-1, 1, 2)  # (N, 2) → (N, 1, 2)&#10;&#10;                return {&#10;                    &quot;contour&quot;: arr,&#10;                    &quot;settings&quot;: obj.get(&quot;settings&quot;, {})&#10;                }&#10;&#10;            elif isinstance(obj, list):&#10;                return [convert_list_to_ndarray(item) for item in obj]&#10;&#10;            return obj&#10;&#10;        # ----- Main contour -----&#10;        raw_contour = data.get(GlueWorkpieceField.CONTOUR.value, [])&#10;&#10;        if isinstance(raw_contour, dict):&#10;            contour = convert_list_to_ndarray(raw_contour)&#10;        elif isinstance(raw_contour, list):&#10;            contour = [convert_list_to_ndarray(seg) for seg in raw_contour]&#10;        else:&#10;            contour = raw_contour  # unexpected type, leave as-is&#10;&#10;        # ----- Spray pattern -----&#10;        raw_spray_pattern = data.get(GlueWorkpieceField.SPRAY_PATTERN.value, {})&#10;        spray_pattern = {}&#10;&#10;        if isinstance(raw_spray_pattern, dict):&#10;            for key, pattern in raw_spray_pattern.items():&#10;                spray_pattern[key] = [convert_list_to_ndarray(seg) for seg in pattern]&#10;        else:&#10;            spray_pattern = raw_spray_pattern&#10;&#10;        # ----- Build workpiece -----&#10;        workpiece = GlueWorkpiece.from_dict(data)&#10;        workpiece.contour = contour&#10;        workpiece.sprayPattern = spray_pattern&#10;        return workpiece&#10;&#10;    def to_dict(self)-&gt; dict:&#10;        &quot;&quot;&quot;&#10;                Convert the Workpiece object into a dictionary representation.&#10;&#10;                Returns:&#10;                    dict: A dictionary containing the Workpiece's properties, suitable for serialization or storage.&#10;                &quot;&quot;&quot;&#10;        return {&#10;            GlueWorkpieceField.WORKPIECE_ID.value: self.workpieceId,&#10;            GlueWorkpieceField.NAME.value: self.name,&#10;            GlueWorkpieceField.DESCRIPTION.value: self.description,&#10;            GlueWorkpieceField.TOOL_ID.value: self.toolID.value,&#10;            GlueWorkpieceField.GRIPPER_ID.value: self.gripperID.value,&#10;            GlueWorkpieceField.GLUE_TYPE.value: self.glueType.value,&#10;            GlueWorkpieceField.PROGRAM.value: self.program.value,&#10;            GlueWorkpieceField.MATERIAL.value: self.material,&#10;            GlueWorkpieceField.CONTOUR.value: self.contour,&#10;            GlueWorkpieceField.OFFSET.value: self.offset,&#10;            GlueWorkpieceField.HEIGHT.value: self.height,&#10;            GlueWorkpieceField.GLUE_QTY.value: self.glueQty,&#10;            GlueWorkpieceField.SPRAY_WIDTH.value: self.sprayWidth,&#10;            GlueWorkpieceField.PICKUP_POINT.value: self.pickupPoint,&#10;            GlueWorkpieceField.SPRAY_PATTERN.value: self.sprayPattern,&#10;            GlueWorkpieceField.CONTOUR_AREA.value: self.contourArea,&#10;            GlueWorkpieceField.NOZZLES.value: self.nozzles&#10;&#10;        }&#10;&#10;    @staticmethod&#10;    def flatten_spray_pattern(obj):&#10;        &quot;&quot;&quot;&#10;             Flatten nested spray pattern lists into a single list.&#10;&#10;             Args:&#10;                 obj (list): The spray pattern (possibly nested) to be flattened.&#10;&#10;             Returns:&#10;                 list: A flattened list containing all points from the spray pattern.&#10;             &quot;&quot;&quot;&#10;        if isinstance(obj, list):&#10;            flat_obj = []&#10;            for item in obj:&#10;                if isinstance(item, list):&#10;                    flat_obj.extend(GlueWorkpiece.flatten_spray_pattern(item))&#10;                else:&#10;                    flat_obj.append(item)&#10;            return flat_obj&#10;        return [obj]&#10;&#10;    @staticmethod&#10;    def reshape_spray_pattern(obj):&#10;        &quot;&quot;&quot;&#10;        Reshape spray pattern list into list of (N, 1, 2) numpy arrays.&#10;&#10;        Args:&#10;            obj (list): The spray pattern, either a single contour or a list of contours.&#10;&#10;        Returns:&#10;            list: A list of numpy arrays representing the reshaped spray pattern contours.&#10;&#10;        Raises:&#10;            ValueError: If the spray pattern format is invalid or unrecognized.&#10;        &quot;&quot;&quot;&#10;        if not obj:&#10;            return []&#10;&#10;        # If it's a single contour, flatten and reshape it&#10;        if all(isinstance(pt, (list, np.ndarray)) and len(pt) == 2 for pt in obj):&#10;            grouped = np.array(obj, dtype=np.float32).reshape(-1, 1, 2)&#10;            return [grouped]&#10;&#10;        # If it's a list of contours&#10;        if isinstance(obj, list) and all(isinstance(c, list) for c in obj):&#10;            result = []&#10;            for contour in obj:&#10;                if not contour:&#10;                    continue&#10;                flat = GlueWorkpiece.flatten_spray_pattern(contour)&#10;                if all(isinstance(x, (int, float)) for x in flat):&#10;                    grouped = [[flat[i], flat[i + 1]] for i in range(0, len(flat), 2)]&#10;                elif all(isinstance(x, list) and len(x) == 2 for x in flat):&#10;                    grouped = flat&#10;                else:&#10;                    raise ValueError(f&quot;Invalid spray pattern shape: {flat}&quot;)&#10;                result.append(np.array(grouped, dtype=np.float32).reshape(-1, 1, 2))&#10;            return result&#10;&#10;        raise ValueError(f&quot;Unknown spray pattern format: {obj}&quot;)&#10;&#10;    @staticmethod&#10;    def from_dict(data: dict):&#10;        &quot;&quot;&quot;&#10;        Deserialize a dictionary into a Workpiece object.&#10;&#10;        Args:&#10;          data (dict): A dictionary representation of a Workpiece.&#10;&#10;        Returns:&#10;          GlueWorkpiece: The reconstructed Workpiece object.&#10;        &quot;&quot;&quot;&#10;        return GlueWorkpiece(&#10;            workpieceId=data[GlueWorkpieceField.WORKPIECE_ID.value],&#10;            name=data[GlueWorkpieceField.NAME.value],&#10;            description=data[GlueWorkpieceField.DESCRIPTION.value],&#10;            toolID=ToolID(data[GlueWorkpieceField.TOOL_ID.value]),&#10;            gripperID=Gripper(data[GlueWorkpieceField.GRIPPER_ID.value]),&#10;            glueType=GlueType(data[GlueWorkpieceField.GLUE_TYPE.value]),&#10;            program=Program(data[GlueWorkpieceField.PROGRAM.value]),&#10;            material=data[GlueWorkpieceField.MATERIAL.value],&#10;            contour=data[GlueWorkpieceField.CONTOUR.value],&#10;            offset=data[GlueWorkpieceField.OFFSET.value],&#10;            height=data.get(GlueWorkpieceField.HEIGHT.value, 4),&#10;            pickupPoint=data.get(GlueWorkpieceField.PICKUP_POINT.value, None),&#10;            nozzles=data.get(GlueWorkpieceField.NOZZLES.value, []),  # Setting nozzles to empty list if missing&#10;            contourArea=data[GlueWorkpieceField.CONTOUR_AREA.value],&#10;            glueQty=data[GlueWorkpieceField.GLUE_QTY.value],&#10;            sprayWidth=data[GlueWorkpieceField.SPRAY_WIDTH.value],&#10;            sprayPattern=data.get(GlueWorkpieceField.SPRAY_PATTERN.value, []),&#10;&#10;            # Setting spray pattern to empty list if missing&#10;        )&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/src/core/application/ApplicationContext.py">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/core/application/ApplicationContext.py" />
              <option name="originalContent" value="&quot;&quot;&quot;&#10;Application Context Manager&#10;&#10;This module provides a global context for the current running application,&#10;allowing base services to access application-specific core settings.&#10;&quot;&quot;&quot;&#10;&#10;import threading&#10;from typing import Optional&#10;from core.application.ApplicationStorageResolver import get_application_storage_resolver&#10;&#10;&#10;class ApplicationContext:&#10;    &quot;&quot;&quot;&#10;    Global context manager for the current running application.&#10;    &#10;    This class provides a thread-safe way to set and get the current&#10;    application name, allowing base services to access core settings&#10;    from the correct application storage location.&#10;    &quot;&quot;&quot;&#10;    &#10;    _instance: Optional['ApplicationContext'] = None&#10;    _lock = threading.Lock()&#10;    &#10;    def __init__(self):&#10;        &quot;&quot;&quot;Initialize the application context.&quot;&quot;&quot;&#10;        self._current_app_name: Optional[str] = None&#10;        self._app_lock = threading.Lock()&#10;        self._storage_resolver = get_application_storage_resolver()&#10;    &#10;    def set_current_application(self, app_type) -&gt; None:&#10;        &quot;&quot;&quot;&#10;        Set the current running application.&#10;        &#10;        Args:&#10;            app_type: ApplicationType enum or string name of the current application&#10;        &quot;&quot;&quot;&#10;        from core.base_robot_application import ApplicationType&#10;        &#10;        # Handle both enum and string inputs for backward compatibility&#10;        if isinstance(app_type, ApplicationType):&#10;            app_name = app_type.value&#10;        else:&#10;            app_name = app_type  # Assume it's already a string&#10;            &#10;        with self._app_lock:&#10;            self._current_app_name = app_name&#10;            print(f&quot;ApplicationContext: Current application set to '{app_name}'&quot;)&#10;    &#10;    def get_current_application(self) -&gt; Optional[str]:&#10;        &quot;&quot;&quot;&#10;        Get the current running application name.&#10;        &#10;        Returns:&#10;            str or None: The current application name, or None if not set&#10;        &quot;&quot;&quot;&#10;        with self._app_lock:&#10;            return self._current_app_name&#10;    &#10;    def get_core_settings_path(self, settings_filename: str, create_if_missing: bool = False) -&gt; Optional[str]:&#10;        &quot;&quot;&quot;&#10;        Get the path to a core settings file in the current application's storage.&#10;        &#10;        Core settings are settings that all applications need (camera_settings.json, robot_config.json).&#10;        &#10;        Args:&#10;            settings_filename: Name of the settings file (e.g., 'camera_settings.json')&#10;            create_if_missing: Whether to create directories if they don't exist&#10;            &#10;        Returns:&#10;            str or None: Full path to the core settings file, or None if no application is set&#10;        &quot;&quot;&quot;&#10;        current_app = self.get_current_application()&#10;        if current_app is None:&#10;            print(f&quot;ApplicationContext: No current application set, cannot get core settings path for '{settings_filename}'&quot;)&#10;            return None&#10;        &#10;        # Extract settings type from filename (remove .json extension)&#10;        settings_type = settings_filename.replace('.json', '')&#10;        &#10;        settings_path = self._storage_resolver.get_settings_path(&#10;            current_app, settings_type, create_if_missing&#10;        )&#10;        &#10;        return settings_path&#10;    &#10;    def get_workpiece_storage_path(self, create_if_missing: bool = False) -&gt; Optional[str]:&#10;        &quot;&quot;&quot;&#10;        Get the path to the workpiece storage directory for the current application.&#10;        &#10;        Args:&#10;            create_if_missing: Whether to create directories if they don't exist&#10;            &#10;        Returns:&#10;            str or None: Full path to the workpiece storage directory, or None if no application is set&#10;        &quot;&quot;&quot;&#10;        current_app = self.get_current_application()&#10;        if current_app is None:&#10;            print(f&quot;ApplicationContext: No current application set, cannot get workpiece storage path&quot;)&#10;            return None&#10;        &#10;        workpiece_path = self._storage_resolver.get_workpiece_storage_path(&#10;            current_app, create_if_missing&#10;        )&#10;        &#10;        return workpiece_path&#10;    &#10;    def is_application_set(self) -&gt; bool:&#10;        &quot;&quot;&quot;&#10;        Check if a current application has been set.&#10;        &#10;        Returns:&#10;            bool: True if an application is set, False otherwise&#10;        &quot;&quot;&quot;&#10;        return self.get_current_application() is not None&#10;&#10;&#10;class ApplicationContextSingleton:&#10;    &quot;&quot;&quot;Singleton wrapper for ApplicationContext.&quot;&quot;&quot;&#10;    &#10;    _instance: Optional[ApplicationContext] = None&#10;    _lock = threading.Lock()&#10;    &#10;    @classmethod&#10;    def get_instance(cls) -&gt; ApplicationContext:&#10;        &quot;&quot;&quot;&#10;        Get the singleton ApplicationContext instance.&#10;        &#10;        Returns:&#10;            ApplicationContext: The singleton instance&#10;        &quot;&quot;&quot;&#10;        if cls._instance is None:&#10;            with cls._lock:&#10;                if cls._instance is None:&#10;                    cls._instance = ApplicationContext()&#10;        return cls._instance&#10;&#10;&#10;# Convenience functions&#10;def set_current_application(app_type) -&gt; None:&#10;    &quot;&quot;&quot;&#10;    Set the current running application.&#10;    &#10;    Args:&#10;        app_type: ApplicationType enum or string name of the current application&#10;    &quot;&quot;&quot;&#10;    context = ApplicationContextSingleton.get_instance()&#10;    context.set_current_application(app_type)&#10;&#10;&#10;def get_current_application() -&gt; Optional[str]:&#10;    &quot;&quot;&quot;&#10;    Get the current running application name.&#10;    &#10;    Returns:&#10;        str or None: The current application name&#10;    &quot;&quot;&quot;&#10;    context = ApplicationContextSingleton.get_instance()&#10;    return context.get_current_application()&#10;&#10;&#10;def get_core_settings_path(settings_filename: str, create_if_missing: bool = False) -&gt; Optional[str]:&#10;    &quot;&quot;&quot;&#10;    Get the path to a core settings file in the current application's storage.&#10;    &#10;    Args:&#10;        settings_filename: Name of the settings file (e.g., 'camera_settings.json')&#10;        create_if_missing: Whether to create directories if they don't exist&#10;        &#10;    Returns:&#10;        str or None: Full path to the core settings file&#10;    &quot;&quot;&quot;&#10;    context = ApplicationContextSingleton.get_instance()&#10;    return context.get_core_settings_path(settings_filename, create_if_missing)&#10;&#10;&#10;def get_workpiece_storage_path(create_if_missing: bool = False) -&gt; Optional[str]:&#10;    &quot;&quot;&quot;&#10;    Get the path to the workpiece storage directory for the current application.&#10;    &#10;    Args:&#10;        create_if_missing: Whether to create directories if they don't exist&#10;        &#10;    Returns:&#10;        str or None: Full path to the workpiece storage directory&#10;    &quot;&quot;&quot;&#10;    context = ApplicationContextSingleton.get_instance()&#10;    return context.get_workpiece_storage_path(create_if_missing)&#10;&#10;&#10;def is_application_context_set() -&gt; bool:&#10;    &quot;&quot;&quot;&#10;    Check if a current application has been set.&#10;    &#10;    Returns:&#10;        bool: True if an application is set, False otherwise&#10;    &quot;&quot;&quot;&#10;    context = ApplicationContextSingleton.get_instance()&#10;    return context.is_application_set()&#10;&#10;&#10;def get_application_settings_tabs() -&gt; list:&#10;    &quot;&quot;&quot;&#10;    Get the settings tabs needed by the current application.&#10;    &#10;    Returns:&#10;        list: List of settings tab names needed by current application, &#10;              or default [&quot;camera&quot;, &quot;robot&quot;] if no application is set&#10;    &quot;&quot;&quot;&#10;    from core.base_robot_application import ApplicationType&#10;    &#10;    try:&#10;        current_app_name = get_current_application()&#10;        if current_app_name is None:&#10;            return [&quot;camera&quot;, &quot;robot&quot;]  # Default tabs&#10;        &#10;        # Create ApplicationType enum directly from the current app name&#10;        app_type = ApplicationType(current_app_name)&#10;        &#10;        # Get the registered application class and its metadata&#10;        if app_type == ApplicationType.GLUE_DISPENSING:&#10;            from applications.glue_dispensing_application.GlueDispensingApplication import GlueSprayingApplication&#10;            metadata = GlueSprayingApplication.get_metadata()&#10;            return metadata.settings_tabs&#10;        elif app_type == ApplicationType.TEST_APPLICATION:&#10;            from applications.test_application.test_application import TestApplication&#10;            metadata = TestApplication.get_metadata()&#10;            return metadata.settings_tabs&#10;        else:&#10;            return [&quot;camera&quot;, &quot;robot&quot;]  # Default tabs&#10;            &#10;    except Exception as e:&#10;        print(f&quot;Error getting application settings tabs: {e}&quot;)&#10;        return [&quot;camera&quot;, &quot;robot&quot;]  # Fallback to default tabs&#10;&#10;&#10;def get_application_required_plugins() -&gt; list:&#10;    &quot;&quot;&quot;&#10;    Get the plugin dependencies needed by the current application.&#10;    &#10;    Returns:&#10;        list: List of plugin identifiers needed by current application,&#10;              or default plugins if no application is set&#10;    &quot;&quot;&quot;&#10;    from core.base_robot_application import ApplicationType&#10;    &#10;    try:&#10;        current_app_name = get_current_application()&#10;        if current_app_name is None:&#10;            # Default plugins for all applications&#10;            return [&quot;dashboard&quot;, &quot;settings&quot;, &quot;gallery&quot;]&#10;        &#10;        # Create ApplicationType enum directly from the current app name&#10;        app_type = ApplicationType(current_app_name)&#10;        &#10;        # Get the registered application class and its metadata&#10;        if app_type == ApplicationType.GLUE_DISPENSING:&#10;            from applications.glue_dispensing_application.GlueDispensingApplication import GlueSprayingApplication&#10;            metadata = GlueSprayingApplication.get_metadata()&#10;            return metadata.get_required_plugins()&#10;        elif app_type == ApplicationType.TEST_APPLICATION:&#10;            from applications.test_application.test_application import TestApplication&#10;            metadata = TestApplication.get_metadata()&#10;            return metadata.get_required_plugins()&#10;        elif app_type == ApplicationType.PAINT_APPLICATION:&#10;            from applications.edge_painting_application.application import EdgePaintingApplication&#10;            metadata = EdgePaintingApplication.get_metadata()&#10;            return metadata.get_required_plugins()&#10;        else:&#10;            # Default plugins for unknown applications&#10;            return [&quot;dashboard&quot;, &quot;settings&quot;, &quot;gallery&quot;]&#10;            &#10;    except Exception as e:&#10;        print(f&quot;Error getting application required plugins: {e}&quot;)&#10;        return [&quot;dashboard&quot;, &quot;settings&quot;, &quot;gallery&quot;]  # Fallback to default plugins&#10;&#10;&#10;if __name__ == &quot;__main__&quot;:&#10;    # Test the application context&#10;    print(&quot;=== ApplicationContext Test ===&quot;)&#10;    &#10;    # Test setting application&#10;    set_current_application(&quot;glue_dispensing_application&quot;)&#10;    print(f&quot;Current application: {get_current_application()}&quot;)&#10;    &#10;    # Test getting core settings paths&#10;    camera_path = get_core_settings_path(&quot;camera_settings.json&quot;)&#10;    robot_path = get_core_settings_path(&quot;robot_config.json&quot;)&#10;    &#10;    print(f&quot;Camera settings path: {camera_path}&quot;)&#10;    print(f&quot;Robot config path: {robot_path}&quot;)&#10;    &#10;    # Test context check&#10;    print(f&quot;Is context set: {is_application_context_set()}&quot;)" />
              <option name="updatedContent" value="&quot;&quot;&quot;&#10;Application Context Manager&#10;&#10;This module provides a global context for the current running application,&#10;allowing base services to access application-specific core settings.&#10;&quot;&quot;&quot;&#10;&#10;import threading&#10;from typing import Optional&#10;from core.application.ApplicationStorageResolver import get_application_storage_resolver&#10;&#10;&#10;class ApplicationContext:&#10;    &quot;&quot;&quot;&#10;    Global context manager for the current running application.&#10;    &#10;    This class provides a thread-safe way to set and get the current&#10;    application name, allowing base services to access core settings&#10;    from the correct application storage location.&#10;    &quot;&quot;&quot;&#10;    &#10;    _instance: Optional['ApplicationContext'] = None&#10;    _lock = threading.Lock()&#10;    &#10;    def __init__(self):&#10;        &quot;&quot;&quot;Initialize the application context.&quot;&quot;&quot;&#10;        self._current_app_name: Optional[str] = None&#10;        self._app_lock = threading.Lock()&#10;        self._storage_resolver = get_application_storage_resolver()&#10;    &#10;    def set_current_application(self, app_type) -&gt; None:&#10;        &quot;&quot;&quot;&#10;        Set the current running application.&#10;        &#10;        Args:&#10;            app_type: ApplicationType enum or string name of the current application&#10;        &quot;&quot;&quot;&#10;        from core.base_robot_application import ApplicationType&#10;        &#10;        # Handle both enum and string inputs for backward compatibility&#10;        if isinstance(app_type, ApplicationType):&#10;            app_name = app_type.value&#10;        else:&#10;            app_name = app_type  # Assume it's already a string&#10;            &#10;        with self._app_lock:&#10;            self._current_app_name = app_name&#10;            print(f&quot;ApplicationContext: Current application set to '{app_name}'&quot;)&#10;    &#10;    def get_current_application(self) -&gt; Optional[str]:&#10;        &quot;&quot;&quot;&#10;        Get the current running application name.&#10;        &#10;        Returns:&#10;            str or None: The current application name, or None if not set&#10;        &quot;&quot;&quot;&#10;        with self._app_lock:&#10;            return self._current_app_name&#10;    &#10;    def get_core_settings_path(self, settings_filename: str, create_if_missing: bool = False) -&gt; Optional[str]:&#10;        &quot;&quot;&quot;&#10;        Get the path to a core settings file in the current application's storage.&#10;        &#10;        Core settings are settings that all applications need (camera_settings.json, robot_config.json).&#10;        &#10;        Args:&#10;            settings_filename: Name of the settings file (e.g., 'camera_settings.json')&#10;            create_if_missing: Whether to create directories if they don't exist&#10;            &#10;        Returns:&#10;            str or None: Full path to the core settings file, or None if no application is set&#10;        &quot;&quot;&quot;&#10;        current_app = self.get_current_application()&#10;        if current_app is None:&#10;            print(f&quot;ApplicationContext: No current application set, cannot get core settings path for '{settings_filename}'&quot;)&#10;            return None&#10;        &#10;        # Extract settings type from filename (remove .json extension)&#10;        settings_type = settings_filename.replace('.json', '')&#10;        &#10;        settings_path = self._storage_resolver.get_settings_path(&#10;            current_app, settings_type, create_if_missing&#10;        )&#10;        &#10;        return settings_path&#10;    &#10;    def get_workpiece_storage_path(self, create_if_missing: bool = False) -&gt; Optional[str]:&#10;        &quot;&quot;&quot;&#10;        Get the path to the workpiece storage directory for the current application.&#10;        &#10;        Args:&#10;            create_if_missing: Whether to create directories if they don't exist&#10;            &#10;        Returns:&#10;            str or None: Full path to the workpiece storage directory, or None if no application is set&#10;        &quot;&quot;&quot;&#10;        current_app = self.get_current_application()&#10;        if current_app is None:&#10;            print(f&quot;ApplicationContext: No current application set, cannot get workpiece storage path&quot;)&#10;            return None&#10;        &#10;        workpiece_path = self._storage_resolver.get_workpiece_storage_path(&#10;            current_app, create_if_missing&#10;        )&#10;        &#10;        return workpiece_path&#10;    &#10;    def is_application_set(self) -&gt; bool:&#10;        &quot;&quot;&quot;&#10;        Check if a current application has been set.&#10;        &#10;        Returns:&#10;            bool: True if an application is set, False otherwise&#10;        &quot;&quot;&quot;&#10;        return self.get_current_application() is not None&#10;&#10;&#10;class ApplicationContextSingleton:&#10;    &quot;&quot;&quot;Singleton wrapper for ApplicationContext.&quot;&quot;&quot;&#10;    &#10;    _instance: Optional[ApplicationContext] = None&#10;    _lock = threading.Lock()&#10;    &#10;    @classmethod&#10;    def get_instance(cls) -&gt; ApplicationContext:&#10;        &quot;&quot;&quot;&#10;        Get the singleton ApplicationContext instance.&#10;        &#10;        Returns:&#10;            ApplicationContext: The singleton instance&#10;        &quot;&quot;&quot;&#10;        if cls._instance is None:&#10;            with cls._lock:&#10;                if cls._instance is None:&#10;                    cls._instance = ApplicationContext()&#10;        return cls._instance&#10;&#10;&#10;# Convenience functions&#10;def set_current_application(app_type) -&gt; None:&#10;    &quot;&quot;&quot;&#10;    Set the current running application.&#10;    &#10;    Args:&#10;        app_type: ApplicationType enum or string name of the current application&#10;    &quot;&quot;&quot;&#10;    context = ApplicationContextSingleton.get_instance()&#10;    context.set_current_application(app_type)&#10;&#10;&#10;def get_current_application() -&gt; Optional[str]:&#10;    &quot;&quot;&quot;&#10;    Get the current running application name.&#10;    &#10;    Returns:&#10;        str or None: The current application name&#10;    &quot;&quot;&quot;&#10;    context = ApplicationContextSingleton.get_instance()&#10;    return context.get_current_application()&#10;&#10;&#10;def get_core_settings_path(settings_filename: str, create_if_missing: bool = False) -&gt; Optional[str]:&#10;    &quot;&quot;&quot;&#10;    Get the path to a core settings file in the current application's storage.&#10;    &#10;    Args:&#10;        settings_filename: Name of the settings file (e.g., 'camera_settings.json')&#10;        create_if_missing: Whether to create directories if they don't exist&#10;        &#10;    Returns:&#10;        str or None: Full path to the core settings file&#10;    &quot;&quot;&quot;&#10;    context = ApplicationContextSingleton.get_instance()&#10;    return context.get_core_settings_path(settings_filename, create_if_missing)&#10;&#10;&#10;def get_workpiece_storage_path(create_if_missing: bool = False) -&gt; Optional[str]:&#10;    &quot;&quot;&quot;&#10;    Get the path to the workpiece storage directory for the current application.&#10;    &#10;    Args:&#10;        create_if_missing: Whether to create directories if they don't exist&#10;        &#10;    Returns:&#10;        str or None: Full path to the workpiece storage directory&#10;    &quot;&quot;&quot;&#10;    context = ApplicationContextSingleton.get_instance()&#10;    return context.get_workpiece_storage_path(create_if_missing)&#10;&#10;&#10;def is_application_context_set() -&gt; bool:&#10;    &quot;&quot;&quot;&#10;    Check if a current application has been set.&#10;    &#10;    Returns:&#10;        bool: True if an application is set, False otherwise&#10;    &quot;&quot;&quot;&#10;    context = ApplicationContextSingleton.get_instance()&#10;    return context.is_application_set()&#10;&#10;&#10;def get_application_settings_tabs() -&gt; list:&#10;    &quot;&quot;&quot;&#10;    Get the settings tabs needed by the current application.&#10;    &#10;    Returns:&#10;        list: List of settings tab names needed by current application, &#10;              or default [&quot;camera&quot;, &quot;robot&quot;] if no application is set&#10;    &quot;&quot;&quot;&#10;    from core.base_robot_application import ApplicationType&#10;    &#10;    try:&#10;        current_app_name = get_current_application()&#10;        if current_app_name is None:&#10;            return [&quot;camera&quot;, &quot;robot&quot;]  # Default tabs&#10;        &#10;        # Create ApplicationType enum directly from the current app name&#10;        app_type = ApplicationType(current_app_name)&#10;        &#10;        # Get the registered application class and its metadata&#10;        if app_type == ApplicationType.GLUE_DISPENSING:&#10;            from applications.glue_dispensing_application.GlueDispensingApplication import GlueSprayingApplication&#10;            metadata = GlueSprayingApplication.get_metadata()&#10;            return metadata.settings_tabs&#10;        elif app_type == ApplicationType.TEST_APPLICATION:&#10;            from applications.test_application.test_application import TestApplication&#10;            metadata = TestApplication.get_metadata()&#10;            return metadata.settings_tabs&#10;        else:&#10;            return [&quot;camera&quot;, &quot;robot&quot;]  # Default tabs&#10;            &#10;    except Exception as e:&#10;        print(f&quot;Error getting application settings tabs: {e}&quot;)&#10;        return [&quot;camera&quot;, &quot;robot&quot;]  # Fallback to default tabs&#10;&#10;&#10;def get_application_required_plugins() -&gt; list:&#10;    &quot;&quot;&quot;&#10;    Get the plugin dependencies needed by the current application.&#10;    &#10;    Returns:&#10;        list: List of plugin identifiers needed by current application,&#10;              or default plugins if no application is set&#10;    &quot;&quot;&quot;&#10;    from core.base_robot_application import ApplicationType&#10;    &#10;    try:&#10;        current_app_name = get_current_application()&#10;        if current_app_name is None:&#10;            # Default plugins for all applications&#10;            return [&quot;dashboard&quot;, &quot;settings&quot;, &quot;gallery&quot;]&#10;        &#10;        # Create ApplicationType enum directly from the current app name&#10;        app_type = ApplicationType(current_app_name)&#10;        &#10;        # Get the registered application class and its metadata&#10;        if app_type == ApplicationType.GLUE_DISPENSING:&#10;            from applications.glue_dispensing_application.GlueDispensingApplication import GlueSprayingApplication&#10;            metadata = GlueSprayingApplication.get_metadata()&#10;            return metadata.get_required_plugins()&#10;        elif app_type == ApplicationType.TEST_APPLICATION:&#10;            from applications.test_application.test_application import TestApplication&#10;            metadata = TestApplication.get_metadata()&#10;            return metadata.get_required_plugins()&#10;        elif app_type == ApplicationType.PAINT_APPLICATION:&#10;            from applications.edge_painting_application.application import EdgePaintingApplication&#10;            metadata = EdgePaintingApplication.get_metadata()&#10;            return metadata.get_required_plugins()&#10;        else:&#10;            # Default plugins for unknown applications&#10;            return [&quot;dashboard&quot;, &quot;settings&quot;, &quot;gallery&quot;]&#10;            &#10;    except Exception as e:&#10;        print(f&quot;Error getting application required plugins: {e}&quot;)&#10;        return [&quot;dashboard&quot;, &quot;settings&quot;, &quot;gallery&quot;]  # Fallback to default plugins&#10;&#10;&#10;if __name__ == &quot;__main__&quot;:&#10;    # Test the application context&#10;    print(&quot;=== ApplicationContext Test ===&quot;)&#10;    &#10;    # Test setting application&#10;    set_current_application(&quot;glue_dispensing_application&quot;)&#10;    print(f&quot;Current application: {get_current_application()}&quot;)&#10;    &#10;    # Test getting core settings paths&#10;    camera_path = get_core_settings_path(&quot;camera_settings.json&quot;)&#10;    robot_path = get_core_settings_path(&quot;robot_config.json&quot;)&#10;    &#10;    print(f&quot;Camera settings path: {camera_path}&quot;)&#10;    print(f&quot;Robot config path: {robot_path}&quot;)&#10;    &#10;    # Test context check&#10;    print(f&quot;Is context set: {is_application_context_set()}&quot;)" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/src/core/application/interfaces/robot_application_interface.py">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/core/application/interfaces/robot_application_interface.py" />
              <option name="originalContent" value="&quot;&quot;&quot;&#10;Robot Application Interface&#10;&#10;This module defines the standard interface that all robot applications must implement.&#10;It provides a contract for operation control, calibration, workpiece handling, and configuration.&#10;&quot;&quot;&quot;&#10;&#10;from abc import ABC, abstractmethod&#10;from typing import Dict, Any, List&#10;from enum import Enum&#10;&#10;from core.base_robot_application import ApplicationType&#10;from core.operation_state_management import OperationResult&#10;&#10;&#10;class CalibrationStatus(Enum):&#10;    &quot;&quot;&quot;Calibration status indicators&quot;&quot;&quot;&#10;    NOT_CALIBRATED = &quot;not_calibrated&quot;&#10;    IN_PROGRESS = &quot;in_progress&quot;&#10;    CALIBRATED = &quot;calibrated&quot;&#10;    FAILED = &quot;failed&quot;&#10;    EXPIRED = &quot;expired&quot;&#10;&#10;&#10;class WorkpieceProcessingResult(Enum):&#10;    &quot;&quot;&quot;Results of workpiece processing operations&quot;&quot;&quot;&#10;    SUCCESS = &quot;success&quot;&#10;    FAILED = &quot;failed&quot;&#10;    PARTIAL = &quot;partial&quot;&#10;    CANCELLED = &quot;cancelled&quot;&#10;    ERROR = &quot;error&quot;&#10;&#10;&#10;class RobotApplicationInterface(ABC):&#10;    &quot;&quot;&quot;&#10;    Standard interface that all robot applications must implement.&#10;    &#10;    This interface defines the contract for:&#10;    - Operation control (start, stop, pause, resume)&#10;    - Calibration management (robot, camera, tools)&#10;    - Workpiece handling and processing&#10;    - Configuration and settings management&#10;    - Status monitoring and reporting&#10;    &quot;&quot;&quot;&#10;    &#10;    # ========== Core Operation Control ==========&#10;    &#10;    @abstractmethod&#10;    def start(self, **kwargs) -&gt; OperationResult:&#10;        &quot;&quot;&quot;&#10;        Start the robot application operation.&#10;        &#10;        Args:&#10;            mode: Operation mode (automatic, manual, etc.)&#10;            **kwargs: Additional application-specific parameters&#10;            &#10;        Returns:&#10;            Dict containing operation result and status&#10;        &quot;&quot;&quot;&#10;        pass&#10;    &#10;    @abstractmethod&#10;    def stop(self, emergency: bool = False) -&gt; OperationResult:&#10;        &quot;&quot;&quot;&#10;        Stop the robot application operation.&#10;        &#10;        Args:&#10;            emergency: Whether this is an emergency stop&#10;            &#10;        Returns:&#10;            Dict containing operation result&#10;        &quot;&quot;&quot;&#10;        pass&#10;&#10;    @abstractmethod&#10;    def pause(self) -&gt; OperationResult:&#10;        &quot;&quot;&quot;&#10;        Pause the robot application operation.&#10;        &#10;        Returns:&#10;            Dict containing operation result&#10;        &quot;&quot;&quot;&#10;        pass&#10;    &#10;    @abstractmethod&#10;    def resume(self) -&gt; OperationResult:&#10;        &quot;&quot;&quot;&#10;        Resume the robot application operation.&#10;        &#10;        Returns:&#10;            Dict containing operation result&#10;        &quot;&quot;&quot;&#10;        pass&#10;    &#10;    @abstractmethod&#10;    def reset(self) -&gt; OperationResult:&#10;        &quot;&quot;&quot;&#10;        Reset the robot application to initial state.&#10;        &#10;        Returns:&#10;            Dict containing operation result&#10;        &quot;&quot;&quot;&#10;        pass&#10;    &#10;    # ========== Calibration Management ==========&#10;    &#10;    @abstractmethod&#10;    def calibrate_robot(self) -&gt; OperationResult:&#10;        &quot;&quot;&quot;&#10;        Calibrate the robot coordinate system.&#10;        &#10;&#10;        Returns:&#10;            Dict containing calibration result and status&#10;        &quot;&quot;&quot;&#10;        pass&#10;    &#10;    @abstractmethod&#10;    def calibrate_camera(self) -&gt; OperationResult:&#10;        &quot;&quot;&quot;&#10;        Calibrate the camera system.&#10;        &#10;&#10;        Returns:&#10;            Dict containing calibration result and status&#10;        &quot;&quot;&quot;&#10;        pass&#10;&#10;&#10;    # ========== Tool and Hardware Control ==========&#10;&#10;    @abstractmethod&#10;    def home_robot(self) -&gt; OperationResult:&#10;        &quot;&quot;&quot;&#10;        Move robot to home position.&#10;        &#10;        Returns:&#10;            Dict containing operation result&#10;        &quot;&quot;&quot;&#10;        pass&#10;&#10;# ========== Helper Data Classes ==========&#10;&#10;class ApplicationInfo:&#10;    &quot;&quot;&quot;Information about a robot application&quot;&quot;&quot;&#10;    &#10;    def __init__(self, &#10;                 app_type: ApplicationType, &#10;                 name: str, &#10;                 version: str,&#10;                 description: str,&#10;                 supported_operations: List[str],&#10;                 supported_tools: List[str],&#10;                 supported_workpieces: List[str]):&#10;        self.app_type = app_type&#10;        self.name = name&#10;        self.version = version&#10;        self.description = description&#10;        self.supported_operations = supported_operations&#10;        self.supported_tools = supported_tools&#10;        self.supported_workpieces = supported_workpieces&#10;    &#10;    def to_dict(self) -&gt; Dict[str, Any]:&#10;        &quot;&quot;&quot;Convert to dictionary representation&quot;&quot;&quot;&#10;        return {&#10;            &quot;type&quot;: self.app_type.value,&#10;            &quot;name&quot;: self.name,&#10;            &quot;version&quot;: self.version,&#10;            &quot;description&quot;: self.description,&#10;            &quot;supported_operations&quot;: self.supported_operations,&#10;            &quot;supported_tools&quot;: self.supported_tools,&#10;            &quot;supported_workpieces&quot;: self.supported_workpieces&#10;        }&#10;" />
              <option name="updatedContent" value="&quot;&quot;&quot;&#10;Robot Application Interface&#10;&#10;This module defines the standard interface that all robot applications must implement.&#10;It provides a contract for operation control, calibration, workpiece handling, and configuration.&#10;&quot;&quot;&quot;&#10;&#10;from abc import ABC, abstractmethod&#10;from typing import Dict, Any, List&#10;from enum import Enum&#10;&#10;from core.base_robot_application import ApplicationType&#10;from core.operation_state_management import OperationResult&#10;&#10;&#10;class CalibrationStatus(Enum):&#10;    &quot;&quot;&quot;Calibration status indicators&quot;&quot;&quot;&#10;    NOT_CALIBRATED = &quot;not_calibrated&quot;&#10;    IN_PROGRESS = &quot;in_progress&quot;&#10;    CALIBRATED = &quot;calibrated&quot;&#10;    FAILED = &quot;failed&quot;&#10;    EXPIRED = &quot;expired&quot;&#10;&#10;&#10;class WorkpieceProcessingResult(Enum):&#10;    &quot;&quot;&quot;Results of workpiece processing operations&quot;&quot;&quot;&#10;    SUCCESS = &quot;success&quot;&#10;    FAILED = &quot;failed&quot;&#10;    PARTIAL = &quot;partial&quot;&#10;    CANCELLED = &quot;cancelled&quot;&#10;    ERROR = &quot;error&quot;&#10;&#10;&#10;class RobotApplicationInterface(ABC):&#10;    &quot;&quot;&quot;&#10;    Standard interface that all robot applications must implement.&#10;    &#10;    This interface defines the contract for:&#10;    - Operation control (start, stop, pause, resume)&#10;    - Calibration management (robot, camera, tools)&#10;    - Workpiece handling and processing&#10;    - Configuration and settings management&#10;    - Status monitoring and reporting&#10;    &quot;&quot;&quot;&#10;    &#10;    # ========== Core Operation Control ==========&#10;    &#10;    @abstractmethod&#10;    def start(self, **kwargs) -&gt; OperationResult:&#10;        &quot;&quot;&quot;&#10;        Start the robot application operation.&#10;        &#10;        Args:&#10;            mode: Operation mode (automatic, manual, etc.)&#10;            **kwargs: Additional application-specific parameters&#10;            &#10;        Returns:&#10;            Dict containing operation result and status&#10;        &quot;&quot;&quot;&#10;        pass&#10;    &#10;    @abstractmethod&#10;    def stop(self, emergency: bool = False) -&gt; OperationResult:&#10;        &quot;&quot;&quot;&#10;        Stop the robot application operation.&#10;        &#10;        Args:&#10;            emergency: Whether this is an emergency stop&#10;            &#10;        Returns:&#10;            Dict containing operation result&#10;        &quot;&quot;&quot;&#10;        pass&#10;&#10;    @abstractmethod&#10;    def pause(self) -&gt; OperationResult:&#10;        &quot;&quot;&quot;&#10;        Pause the robot application operation.&#10;        &#10;        Returns:&#10;            Dict containing operation result&#10;        &quot;&quot;&quot;&#10;        pass&#10;    &#10;    @abstractmethod&#10;    def resume(self) -&gt; OperationResult:&#10;        &quot;&quot;&quot;&#10;        Resume the robot application operation.&#10;        &#10;        Returns:&#10;            Dict containing operation result&#10;        &quot;&quot;&quot;&#10;        pass&#10;    &#10;    @abstractmethod&#10;    def reset(self) -&gt; OperationResult:&#10;        &quot;&quot;&quot;&#10;        Reset the robot application to initial state.&#10;        &#10;        Returns:&#10;            Dict containing operation result&#10;        &quot;&quot;&quot;&#10;        pass&#10;    &#10;    # ========== Calibration Management ==========&#10;    &#10;    @abstractmethod&#10;    def calibrate_robot(self) -&gt; OperationResult:&#10;        &quot;&quot;&quot;&#10;        Calibrate the robot coordinate system.&#10;        &#10;&#10;        Returns:&#10;            Dict containing calibration result and status&#10;        &quot;&quot;&quot;&#10;        pass&#10;    &#10;    @abstractmethod&#10;    def calibrate_camera(self) -&gt; OperationResult:&#10;        &quot;&quot;&quot;&#10;        Calibrate the camera system.&#10;        &#10;&#10;        Returns:&#10;            Dict containing calibration result and status&#10;        &quot;&quot;&quot;&#10;        pass&#10;&#10;&#10;    # ========== Tool and Hardware Control ==========&#10;&#10;    @abstractmethod&#10;    def home_robot(self) -&gt; OperationResult:&#10;        &quot;&quot;&quot;&#10;        Move robot to home position.&#10;        &#10;        Returns:&#10;            Dict containing operation result&#10;        &quot;&quot;&quot;&#10;        pass&#10;&#10;# ========== Helper Data Classes ==========&#10;&#10;class ApplicationInfo:&#10;    &quot;&quot;&quot;Information about a robot application&quot;&quot;&quot;&#10;    &#10;    def __init__(self, &#10;                 app_type: ApplicationType, &#10;                 name: str, &#10;                 version: str,&#10;                 description: str,&#10;                 supported_operations: List[str],&#10;                 supported_tools: List[str],&#10;                 supported_workpieces: List[str]):&#10;        self.app_type = app_type&#10;        self.name = name&#10;        self.version = version&#10;        self.description = description&#10;        self.supported_operations = supported_operations&#10;        self.supported_tools = supported_tools&#10;        self.supported_workpieces = supported_workpieces&#10;    &#10;    def to_dict(self) -&gt; Dict[str, Any]:&#10;        &quot;&quot;&quot;Convert to dictionary representation&quot;&quot;&quot;&#10;        return {&#10;            &quot;type&quot;: self.app_type.value,&#10;            &quot;name&quot;: self.name,&#10;            &quot;version&quot;: self.version,&#10;            &quot;description&quot;: self.description,&#10;            &quot;supported_operations&quot;: self.supported_operations,&#10;            &quot;supported_tools&quot;: self.supported_tools,&#10;            &quot;supported_workpieces&quot;: self.supported_workpieces&#10;        }" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="/tmp/test_robot_repo.py">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="/tmp/test_robot_repo.py" />
            </PendingDiffInfo>
          </value>
        </entry>
      </map>
    </option>
  </component>
</project>