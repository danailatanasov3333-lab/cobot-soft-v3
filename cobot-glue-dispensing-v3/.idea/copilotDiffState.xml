<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="CopilotDiffPersistence">
    <option name="pendingDiffs">
      <map>
        <entry key="$PROJECT_DIR$/src/applications/glue_dispensing_application/workpiece/GlueWorkpiece.py">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/applications/glue_dispensing_application/workpiece/GlueWorkpiece.py" />
              <option name="originalContent" value="import numpy as np&#10;&#10;from applications.glue_dispensing_application.workpiece.GlueWorkpieceField import GlueWorkpieceField&#10;from core.model.workpiece.Workpiece import BaseWorkpiece&#10;from modules.shared.core.interfaces.JsonSerializable import JsonSerializable&#10;from modules.shared.tools.GlueCell import GlueType&#10;from modules.shared.tools.enums.Gripper import Gripper&#10;from modules.shared.tools.enums.Program import Program&#10;from modules.shared.tools.enums.ToolID import ToolID&#10;&#10;&#10;class GlueWorkpiece(BaseWorkpiece, JsonSerializable):&#10;    &quot;&quot;&quot;&#10;        A class representing a workpieces in a glue dispensing application, including its properties such as ID,&#10;        name, description, tool, gripper, glue type, program, material, contour, offset, height, nozzles,&#10;        contour area, and spray pattern.&#10;&#10;        Inherits from BaseWorkpiece and JsonSerializable for basic workpieces functionality and serialization support.&#10;        &quot;&quot;&quot;&#10;    def __init__(self, workpieceId, name, description, toolID, gripperID, glueType, program, material, contour, offset,&#10;                 height, nozzles, contourArea, glueQty, sprayWidth, pickupPoint, sprayPattern=None):&#10;        &quot;&quot;&quot;&#10;              Initializes a Workpiece object with specified parameters.&#10;&#10;              Args:&#10;                  workpieceId (int): The unique identifier for the workpieces.&#10;                  name (str): The name of the workpieces.&#10;                  description (str): A description of the workpieces.&#10;                  toolID (ToolID): The tool ID associated with the workpieces.&#10;                  gripperID (Gripper): The gripper ID associated with the workpieces.&#10;                  glueType (GlueType): The type of glue used in the workpieces.&#10;                  program (Program): The program associated with the workpieces.&#10;                  material (str): The material of the workpieces.&#10;                  contour (list of np.ndarray): The contour points of the workpieces.&#10;                  offset (float): The offset of the workpieces.&#10;                  height (float): The height of the workpieces.&#10;                  nozzles (list): The list of nozzles associated with the workpieces.&#10;                  contourArea (float): The area of the contour.&#10;                  sprayPattern (optional, list): The spray pattern used for the workpieces. Defaults to an empty list if None.&#10;&#10;              &quot;&quot;&quot;&#10;        super().__init__(workpieceId, contour)&#10;        if sprayPattern is None:&#10;            sprayPattern = []&#10;        self.workpieceId = workpieceId&#10;        self.name = name&#10;        self.description = description&#10;        self.toolID = toolID&#10;        self.gripperID = gripperID&#10;        self.glueType = glueType&#10;        self.program = program&#10;        self.material = material&#10;        self.contour = contour  # This should be a list of nd arrays&#10;        self.offset = offset&#10;        self.height = height&#10;        self.sprayPattern = sprayPattern&#10;        self.contourArea = contourArea&#10;        self.nozzles = nozzles&#10;        self.glueQty = glueQty&#10;        self.sprayWidth = sprayWidth&#10;        self.pickupPoint = pickupPoint  # Placeholder for pickup point&#10;&#10;    def __str__(self):&#10;        return (f&quot;Workpiece(ID: {self.workpieceId}, &quot;&#10;                f&quot;Name: {self.name}, &quot;&#10;                f&quot;Description: {self.description}, &quot;&#10;                f&quot;Tool: {self.toolID.value if hasattr(self.toolID, 'value') else self.toolID}, &quot;&#10;                f&quot;Gripper: {self.gripperID.value if hasattr(self.gripperID, 'value') else self.gripperID}, &quot;&#10;                f&quot;Material: {self.material}, &quot;&#10;                f&quot;Height: {self.height}, &quot;&#10;                f&quot;ContourArea: {self.contourArea}), &quot;&#10;                f&quot;PickupPoint: {self.pickupPoint})&quot;)&#10;&#10;    def get_spray_pattern_contours(self):&#10;        &quot;&quot;&quot;&#10;        Return list of spray pattern contour entries.&#10;        Each entry is a dict: {&quot;contour&quot;: np.ndarray, &quot;settings&quot;: dict}&#10;        &quot;&quot;&quot;&#10;        contours = []&#10;        for entry in self.sprayPattern.get(&quot;Contour&quot;, []):&#10;            contour_points = np.array(entry.get(&quot;contour&quot;, []), dtype=np.float32).reshape(-1, 2)&#10;            contours.append({&#10;                &quot;contour&quot;: contour_points,&#10;                &quot;settings&quot;: entry.get(&quot;settings&quot;, {})&#10;            })&#10;        return contours&#10;&#10;&#10;    def get_spray_pattern_fills(self):&#10;        &quot;&quot;&quot;&#10;        Return list of spray pattern fill entries.&#10;        Each entry is a dict: {&quot;contou  r&quot;: np.ndarray, &quot;settings&quot;: dict}&#10;        &quot;&quot;&quot;&#10;        fills = []&#10;        for entry in self.sprayPattern.get(&quot;Fill&quot;, []):&#10;            contour_points = np.array(entry.get(&quot;contour&quot;, []), dtype=np.float32).reshape(-1, 2)&#10;            fills.append({&#10;                &quot;contour&quot;: contour_points,&#10;                &quot;settings&quot;: entry.get(&quot;settings&quot;, {})&#10;            })&#10;        return fills&#10;&#10;    def set_main_contour(self, contour):&#10;      self.contour[&quot;contour&quot;] = contour&#10;&#10;&#10;&#10;    def get_main_contour(self):&#10;        &quot;&quot;&quot;&#10;        Return the main contour without settings.&#10;        Handles both dict and direct format of self.contour.&#10;        Returns numpy array in proper format for nesting operations.&#10;        &quot;&quot;&quot;&#10;&#10;        if isinstance(self.contour, dict) and &quot;contour&quot; in self.contour:&#10;            # Handle dict format: {&quot;contour&quot;: points, &quot;settings&quot;: {...}}&#10;            contour_data = self.contour[&quot;contour&quot;]&#10;        else:&#10;            # Handle direct format: contour data directly&#10;            contour_data = self.contour&#10;&#10;        # Convert to numpy array format expected by nesting (N, 1, 2)&#10;        if isinstance(contour_data, np.ndarray):&#10;            if len(contour_data.shape) == 3 and contour_data.shape[1] == 1:&#10;                # Already in correct format (N, 1, 2)&#10;                return contour_data&#10;            elif len(contour_data.shape) == 2:&#10;                # Convert from (N, 2) to (N, 1, 2)&#10;                return contour_data.reshape(-1, 1, 2)&#10;            else:&#10;                # Flatten and reshape&#10;                return contour_data.reshape(-1, 2).reshape(-1, 1, 2)&#10;        else:&#10;            # Handle list format - convert to numpy array&#10;            flat_points = []&#10;            for point in contour_data:&#10;                if isinstance(point, (list, tuple, np.ndarray)):&#10;                    # Handle nested structures like [[[x, y]]] or [[x, y]]&#10;                    while isinstance(point, (list, tuple, np.ndarray)) and len(point) == 1:&#10;                        point = point[0]&#10;                    if len(point) &gt;= 2:&#10;                        # Recursively flatten nested coordinates&#10;                        x, y = point[0], point[1]&#10;                        while isinstance(x, (list, tuple, np.ndarray)):&#10;                            x = x[0] if len(x) &gt; 0 else 0&#10;                        while isinstance(y, (list, tuple, np.ndarray)):&#10;                            y = y[0] if len(y) &gt; 0 else 0&#10;                        flat_points.append([float(x), float(y)])&#10;&#10;            if flat_points:&#10;                return np.array(flat_points, dtype=np.float32).reshape(-1, 1, 2)&#10;            else:&#10;                return np.array([], dtype=np.float32).reshape(0, 1, 2)&#10;&#10;    def get_main_contour_settings(self):&#10;        &quot;&quot;&quot;&#10;        Return the settings associated with the main contour.&#10;        If no settings are found, return an empty dictionary.&#10;        &quot;&quot;&quot;&#10;        if isinstance(self.contour, dict) and &quot;settings&quot; in self.contour:&#10;            return self.contour[&quot;settings&quot;]&#10;        return {}&#10;&#10;    @staticmethod&#10;    def serialize(workpiece):&#10;        def convert_ndarray_to_list(obj):&#10;            if isinstance(obj, np.ndarray):&#10;                if obj.ndim == 2 and obj.shape[1] == 2:&#10;                    obj = obj.reshape(-1, 1, 2)  # ✅ normalize before list conversion&#10;                return obj.tolist()&#10;            elif isinstance(obj, dict) and &quot;contour&quot; in obj:&#10;                contour = obj[&quot;contour&quot;]&#10;                if isinstance(contour, np.ndarray) and contour.ndim == 2 and contour.shape[1] == 2:&#10;                    contour = contour.reshape(-1, 1, 2)&#10;                return {&#10;                    &quot;contour&quot;: convert_ndarray_to_list(contour),&#10;                    &quot;settings&quot;: dict(obj.get(&quot;settings&quot;, {}))&#10;                }&#10;            elif isinstance(obj, list):&#10;                return [convert_ndarray_to_list(item) for item in obj]&#10;            return obj&#10;&#10;        # ✅ Handle dict contour directly&#10;        contour_data = convert_ndarray_to_list(workpiece.contour)&#10;&#10;        if isinstance(workpiece.sprayPattern, dict):&#10;            spray_pattern_dict = {&#10;                key: [convert_ndarray_to_list(seg) for seg in val]&#10;                for key, val in workpiece.sprayPattern.items()&#10;            }&#10;        else:&#10;            spray_pattern_dict = convert_ndarray_to_list(workpiece.sprayPattern)&#10;&#10;        workpiece.contour = contour_data&#10;        workpiece.sprayPattern = spray_pattern_dict&#10;        return workpiece.to_dict()&#10;&#10;    @staticmethod&#10;    def deserialize(data):&#10;        def convert_list_to_ndarray(obj):&#10;            if isinstance(obj, dict) and &quot;contour&quot; in obj:&#10;                arr = np.array(obj[&quot;contour&quot;], dtype=np.float32)&#10;&#10;                # ✅ Normalize shape to (N, 1, 2)&#10;                if arr.ndim == 1 and arr.shape[0] == 2:&#10;                    arr = arr.reshape(1, 1, 2)  # single point → (1, 1, 2)&#10;                elif arr.ndim == 2 and arr.shape[1] == 2:&#10;                    arr = arr.reshape(-1, 1, 2)  # (N, 2) → (N, 1, 2)&#10;&#10;                return {&#10;                    &quot;contour&quot;: arr,&#10;                    &quot;settings&quot;: obj.get(&quot;settings&quot;, {})&#10;                }&#10;&#10;            elif isinstance(obj, list):&#10;                return [convert_list_to_ndarray(item) for item in obj]&#10;&#10;            return obj&#10;&#10;        # ----- Main contour -----&#10;        raw_contour = data.get(GlueWorkpieceField.CONTOUR.value, [])&#10;&#10;        if isinstance(raw_contour, dict):&#10;            contour = convert_list_to_ndarray(raw_contour)&#10;        elif isinstance(raw_contour, list):&#10;            contour = [convert_list_to_ndarray(seg) for seg in raw_contour]&#10;        else:&#10;            contour = raw_contour  # unexpected type, leave as-is&#10;&#10;        # ----- Spray pattern -----&#10;        raw_spray_pattern = data.get(GlueWorkpieceField.SPRAY_PATTERN.value, {})&#10;        spray_pattern = {}&#10;&#10;        if isinstance(raw_spray_pattern, dict):&#10;            for key, pattern in raw_spray_pattern.items():&#10;                spray_pattern[key] = [convert_list_to_ndarray(seg) for seg in pattern]&#10;        else:&#10;            spray_pattern = raw_spray_pattern&#10;&#10;        # ----- Build workpiece -----&#10;        workpiece = GlueWorkpiece.from_dict(data)&#10;        workpiece.contour = contour&#10;        workpiece.sprayPattern = spray_pattern&#10;        return workpiece&#10;&#10;    def to_dict(self)-&gt; dict:&#10;        &quot;&quot;&quot;&#10;                Convert the Workpiece object into a dictionary representation.&#10;&#10;                Returns:&#10;                    dict: A dictionary containing the Workpiece's properties, suitable for serialization or storage.&#10;                &quot;&quot;&quot;&#10;        return {&#10;            GlueWorkpieceField.WORKPIECE_ID.value: self.workpieceId,&#10;            GlueWorkpieceField.NAME.value: self.name,&#10;            GlueWorkpieceField.DESCRIPTION.value: self.description,&#10;            GlueWorkpieceField.TOOL_ID.value: self.toolID.value,&#10;            GlueWorkpieceField.GRIPPER_ID.value: self.gripperID.value,&#10;            GlueWorkpieceField.GLUE_TYPE.value: self.glueType.value,&#10;            GlueWorkpieceField.PROGRAM.value: self.program.value,&#10;            GlueWorkpieceField.MATERIAL.value: self.material,&#10;            GlueWorkpieceField.CONTOUR.value: self.contour,&#10;            GlueWorkpieceField.OFFSET.value: self.offset,&#10;            GlueWorkpieceField.HEIGHT.value: self.height,&#10;            GlueWorkpieceField.GLUE_QTY.value: self.glueQty,&#10;            GlueWorkpieceField.SPRAY_WIDTH.value: self.sprayWidth,&#10;            GlueWorkpieceField.PICKUP_POINT.value: self.pickupPoint,&#10;            GlueWorkpieceField.SPRAY_PATTERN.value: self.sprayPattern,&#10;            GlueWorkpieceField.CONTOUR_AREA.value: self.contourArea,&#10;            GlueWorkpieceField.NOZZLES.value: self.nozzles&#10;&#10;        }&#10;&#10;    @staticmethod&#10;    def flatten_spray_pattern(obj):&#10;        &quot;&quot;&quot;&#10;             Flatten nested spray pattern lists into a single list.&#10;&#10;             Args:&#10;                 obj (list): The spray pattern (possibly nested) to be flattened.&#10;&#10;             Returns:&#10;                 list: A flattened list containing all points from the spray pattern.&#10;             &quot;&quot;&quot;&#10;        if isinstance(obj, list):&#10;            flat_obj = []&#10;            for item in obj:&#10;                if isinstance(item, list):&#10;                    flat_obj.extend(GlueWorkpiece.flatten_spray_pattern(item))&#10;                else:&#10;                    flat_obj.append(item)&#10;            return flat_obj&#10;        return [obj]&#10;&#10;    @staticmethod&#10;    def reshape_spray_pattern(obj):&#10;        &quot;&quot;&quot;&#10;        Reshape spray pattern list into list of (N, 1, 2) numpy arrays.&#10;&#10;        Args:&#10;            obj (list): The spray pattern, either a single contour or a list of contours.&#10;&#10;        Returns:&#10;            list: A list of numpy arrays representing the reshaped spray pattern contours.&#10;&#10;        Raises:&#10;            ValueError: If the spray pattern format is invalid or unrecognized.&#10;        &quot;&quot;&quot;&#10;        if not obj:&#10;            return []&#10;&#10;        # If it's a single contour, flatten and reshape it&#10;        if all(isinstance(pt, (list, np.ndarray)) and len(pt) == 2 for pt in obj):&#10;            grouped = np.array(obj, dtype=np.float32).reshape(-1, 1, 2)&#10;            return [grouped]&#10;&#10;        # If it's a list of contours&#10;        if isinstance(obj, list) and all(isinstance(c, list) for c in obj):&#10;            result = []&#10;            for contour in obj:&#10;                if not contour:&#10;                    continue&#10;                flat = GlueWorkpiece.flatten_spray_pattern(contour)&#10;                if all(isinstance(x, (int, float)) for x in flat):&#10;                    grouped = [[flat[i], flat[i + 1]] for i in range(0, len(flat), 2)]&#10;                elif all(isinstance(x, list) and len(x) == 2 for x in flat):&#10;                    grouped = flat&#10;                else:&#10;                    raise ValueError(f&quot;Invalid spray pattern shape: {flat}&quot;)&#10;                result.append(np.array(grouped, dtype=np.float32).reshape(-1, 1, 2))&#10;            return result&#10;&#10;        raise ValueError(f&quot;Unknown spray pattern format: {obj}&quot;)&#10;&#10;    @staticmethod&#10;    def from_dict(data: dict):&#10;        &quot;&quot;&quot;&#10;        Deserialize a dictionary into a Workpiece object.&#10;&#10;        Args:&#10;          data (dict): A dictionary representation of a Workpiece.&#10;&#10;        Returns:&#10;          GlueWorkpiece: The reconstructed Workpiece object.&#10;        &quot;&quot;&quot;&#10;        return GlueWorkpiece(&#10;            workpieceId=data[GlueWorkpieceField.WORKPIECE_ID.value],&#10;            name=data[GlueWorkpieceField.NAME.value],&#10;            description=data[GlueWorkpieceField.DESCRIPTION.value],&#10;            toolID=ToolID(data[GlueWorkpieceField.TOOL_ID.value]),&#10;            gripperID=Gripper(data[GlueWorkpieceField.GRIPPER_ID.value]),&#10;            glueType=GlueType(data[GlueWorkpieceField.GLUE_TYPE.value]),&#10;            program=Program(data[GlueWorkpieceField.PROGRAM.value]),&#10;            material=data[GlueWorkpieceField.MATERIAL.value],&#10;            contour=data[GlueWorkpieceField.CONTOUR.value],&#10;            offset=data[GlueWorkpieceField.OFFSET.value],&#10;            height=data.get(GlueWorkpieceField.HEIGHT.value, 4),&#10;            pickupPoint=data.get(GlueWorkpieceField.PICKUP_POINT.value, None),&#10;            nozzles=data.get(GlueWorkpieceField.NOZZLES.value, []),  # Setting nozzles to empty list if missing&#10;            contourArea=data[GlueWorkpieceField.CONTOUR_AREA.value],&#10;            glueQty=data[GlueWorkpieceField.GLUE_QTY.value],&#10;            sprayWidth=data[GlueWorkpieceField.SPRAY_WIDTH.value],&#10;            sprayPattern=data.get(GlueWorkpieceField.SPRAY_PATTERN.value, []),&#10;&#10;            # Setting spray pattern to empty list if missing&#10;        )&#10;" />
              <option name="updatedContent" value="import numpy as np&#10;&#10;from applications.glue_dispensing_application.workpiece.GlueWorkpieceField import GlueWorkpieceField&#10;from core.model.workpiece.Workpiece import BaseWorkpiece&#10;from modules.shared.core.interfaces.JsonSerializable import JsonSerializable&#10;from modules.shared.tools.GlueCell import GlueType&#10;from modules.shared.tools.enums.Gripper import Gripper&#10;from modules.shared.tools.enums.Program import Program&#10;from modules.shared.tools.enums.ToolID import ToolID&#10;&#10;&#10;class GlueWorkpiece(BaseWorkpiece, JsonSerializable):&#10;    &quot;&quot;&quot;&#10;        A class representing a workpieces in a glue dispensing application, including its properties such as ID,&#10;        name, description, tool, gripper, glue type, program, material, contour, offset, height, nozzles,&#10;        contour area, and spray pattern.&#10;&#10;        Inherits from BaseWorkpiece and JsonSerializable for basic workpieces functionality and serialization support.&#10;        &quot;&quot;&quot;&#10;    def __init__(self, workpieceId, name, description, toolID, gripperID, glueType, program, material, contour, offset,&#10;                 height, nozzles, contourArea, glueQty, sprayWidth, pickupPoint, sprayPattern=None):&#10;        &quot;&quot;&quot;&#10;              Initializes a Workpiece object with specified parameters.&#10;&#10;              Args:&#10;                  workpieceId (int): The unique identifier for the workpieces.&#10;                  name (str): The name of the workpieces.&#10;                  description (str): A description of the workpieces.&#10;                  toolID (ToolID): The tool ID associated with the workpieces.&#10;                  gripperID (Gripper): The gripper ID associated with the workpieces.&#10;                  glueType (GlueType): The type of glue used in the workpieces.&#10;                  program (Program): The program associated with the workpieces.&#10;                  material (str): The material of the workpieces.&#10;                  contour (list of np.ndarray): The contour points of the workpieces.&#10;                  offset (float): The offset of the workpieces.&#10;                  height (float): The height of the workpieces.&#10;                  nozzles (list): The list of nozzles associated with the workpieces.&#10;                  contourArea (float): The area of the contour.&#10;                  sprayPattern (optional, list): The spray pattern used for the workpieces. Defaults to an empty list if None.&#10;&#10;              &quot;&quot;&quot;&#10;        super().__init__(workpieceId, contour)&#10;        if sprayPattern is None:&#10;            sprayPattern = []&#10;        self.workpieceId = workpieceId&#10;        self.name = name&#10;        self.description = description&#10;        self.toolID = toolID&#10;        self.gripperID = gripperID&#10;        self.glueType = glueType&#10;        self.program = program&#10;        self.material = material&#10;        self.contour = contour  # This should be a list of nd arrays&#10;        self.offset = offset&#10;        self.height = height&#10;        self.sprayPattern = sprayPattern&#10;        self.contourArea = contourArea&#10;        self.nozzles = nozzles&#10;        self.glueQty = glueQty&#10;        self.sprayWidth = sprayWidth&#10;        self.pickupPoint = pickupPoint  # Placeholder for pickup point&#10;&#10;    def __str__(self):&#10;        return (f&quot;Workpiece(ID: {self.workpieceId}, &quot;&#10;                f&quot;Name: {self.name}, &quot;&#10;                f&quot;Description: {self.description}, &quot;&#10;                f&quot;Tool: {self.toolID.value if hasattr(self.toolID, 'value') else self.toolID}, &quot;&#10;                f&quot;Gripper: {self.gripperID.value if hasattr(self.gripperID, 'value') else self.gripperID}, &quot;&#10;                f&quot;Material: {self.material}, &quot;&#10;                f&quot;Height: {self.height}, &quot;&#10;                f&quot;ContourArea: {self.contourArea}), &quot;&#10;                f&quot;PickupPoint: {self.pickupPoint})&quot;)&#10;&#10;    def get_spray_pattern_contours(self):&#10;        &quot;&quot;&quot;&#10;        Return list of spray pattern contour entries.&#10;        Each entry is a dict: {&quot;contour&quot;: np.ndarray, &quot;settings&quot;: dict}&#10;        &quot;&quot;&quot;&#10;        contours = []&#10;        for entry in self.sprayPattern.get(&quot;Contour&quot;, []):&#10;            contour_points = np.array(entry.get(&quot;contour&quot;, []), dtype=np.float32).reshape(-1, 2)&#10;            contours.append({&#10;                &quot;contour&quot;: contour_points,&#10;                &quot;settings&quot;: entry.get(&quot;settings&quot;, {})&#10;            })&#10;        return contours&#10;&#10;&#10;    def get_spray_pattern_fills(self):&#10;        &quot;&quot;&quot;&#10;        Return list of spray pattern fill entries.&#10;        Each entry is a dict: {&quot;contou  r&quot;: np.ndarray, &quot;settings&quot;: dict}&#10;        &quot;&quot;&quot;&#10;        fills = []&#10;        for entry in self.sprayPattern.get(&quot;Fill&quot;, []):&#10;            contour_points = np.array(entry.get(&quot;contour&quot;, []), dtype=np.float32).reshape(-1, 2)&#10;            fills.append({&#10;                &quot;contour&quot;: contour_points,&#10;                &quot;settings&quot;: entry.get(&quot;settings&quot;, {})&#10;            })&#10;        return fills&#10;&#10;    def set_main_contour(self, contour):&#10;      self.contour[&quot;contour&quot;] = contour&#10;&#10;&#10;&#10;    def get_main_contour(self):&#10;        &quot;&quot;&quot;&#10;        Return the main contour without settings.&#10;        Handles both dict and direct format of self.contour.&#10;        Returns numpy array in proper format for nesting operations.&#10;        &quot;&quot;&quot;&#10;&#10;        if isinstance(self.contour, dict) and &quot;contour&quot; in self.contour:&#10;            # Handle dict format: {&quot;contour&quot;: points, &quot;settings&quot;: {...}}&#10;            contour_data = self.contour[&quot;contour&quot;]&#10;        else:&#10;            # Handle direct format: contour data directly&#10;            contour_data = self.contour&#10;&#10;        # Convert to numpy array format expected by nesting (N, 1, 2)&#10;        if isinstance(contour_data, np.ndarray):&#10;            if len(contour_data.shape) == 3 and contour_data.shape[1] == 1:&#10;                # Already in correct format (N, 1, 2)&#10;                return contour_data&#10;            elif len(contour_data.shape) == 2:&#10;                # Convert from (N, 2) to (N, 1, 2)&#10;                return contour_data.reshape(-1, 1, 2)&#10;            else:&#10;                # Flatten and reshape&#10;                return contour_data.reshape(-1, 2).reshape(-1, 1, 2)&#10;        else:&#10;            # Handle list format - convert to numpy array&#10;            flat_points = []&#10;            for point in contour_data:&#10;                if isinstance(point, (list, tuple, np.ndarray)):&#10;                    # Handle nested structures like [[[x, y]]] or [[x, y]]&#10;                    while isinstance(point, (list, tuple, np.ndarray)) and len(point) == 1:&#10;                        point = point[0]&#10;                    if len(point) &gt;= 2:&#10;                        # Recursively flatten nested coordinates&#10;                        x, y = point[0], point[1]&#10;                        while isinstance(x, (list, tuple, np.ndarray)):&#10;                            x = x[0] if len(x) &gt; 0 else 0&#10;                        while isinstance(y, (list, tuple, np.ndarray)):&#10;                            y = y[0] if len(y) &gt; 0 else 0&#10;                        flat_points.append([float(x), float(y)])&#10;&#10;            if flat_points:&#10;                return np.array(flat_points, dtype=np.float32).reshape(-1, 1, 2)&#10;            else:&#10;                return np.array([], dtype=np.float32).reshape(0, 1, 2)&#10;&#10;    def get_main_contour_settings(self):&#10;        &quot;&quot;&quot;&#10;        Return the settings associated with the main contour.&#10;        If no settings are found, return an empty dictionary.&#10;        &quot;&quot;&quot;&#10;        if isinstance(self.contour, dict) and &quot;settings&quot; in self.contour:&#10;            return self.contour[&quot;settings&quot;]&#10;        return {}&#10;&#10;    @staticmethod&#10;    def serialize(workpiece):&#10;        def convert_ndarray_to_list(obj):&#10;            if isinstance(obj, np.ndarray):&#10;                if obj.ndim == 2 and obj.shape[1] == 2:&#10;                    obj = obj.reshape(-1, 1, 2)  # ✅ normalize before list conversion&#10;                return obj.tolist()&#10;            elif isinstance(obj, dict) and &quot;contour&quot; in obj:&#10;                contour = obj[&quot;contour&quot;]&#10;                if isinstance(contour, np.ndarray) and contour.ndim == 2 and contour.shape[1] == 2:&#10;                    contour = contour.reshape(-1, 1, 2)&#10;                return {&#10;                    &quot;contour&quot;: convert_ndarray_to_list(contour),&#10;                    &quot;settings&quot;: dict(obj.get(&quot;settings&quot;, {}))&#10;                }&#10;            elif isinstance(obj, list):&#10;                return [convert_ndarray_to_list(item) for item in obj]&#10;            return obj&#10;&#10;        # ✅ Handle dict contour directly&#10;        contour_data = convert_ndarray_to_list(workpiece.contour)&#10;&#10;        if isinstance(workpiece.sprayPattern, dict):&#10;            spray_pattern_dict = {&#10;                key: [convert_ndarray_to_list(seg) for seg in val]&#10;                for key, val in workpiece.sprayPattern.items()&#10;            }&#10;        else:&#10;            spray_pattern_dict = convert_ndarray_to_list(workpiece.sprayPattern)&#10;&#10;        workpiece.contour = contour_data&#10;        workpiece.sprayPattern = spray_pattern_dict&#10;        return workpiece.to_dict()&#10;&#10;    @staticmethod&#10;    def deserialize(data):&#10;        def convert_list_to_ndarray(obj):&#10;            if isinstance(obj, dict) and &quot;contour&quot; in obj:&#10;                arr = np.array(obj[&quot;contour&quot;], dtype=np.float32)&#10;&#10;                # ✅ Normalize shape to (N, 1, 2)&#10;                if arr.ndim == 1 and arr.shape[0] == 2:&#10;                    arr = arr.reshape(1, 1, 2)  # single point → (1, 1, 2)&#10;                elif arr.ndim == 2 and arr.shape[1] == 2:&#10;                    arr = arr.reshape(-1, 1, 2)  # (N, 2) → (N, 1, 2)&#10;&#10;                return {&#10;                    &quot;contour&quot;: arr,&#10;                    &quot;settings&quot;: obj.get(&quot;settings&quot;, {})&#10;                }&#10;&#10;            elif isinstance(obj, list):&#10;                return [convert_list_to_ndarray(item) for item in obj]&#10;&#10;            return obj&#10;&#10;        # ----- Main contour -----&#10;        raw_contour = data.get(GlueWorkpieceField.CONTOUR.value, [])&#10;&#10;        if isinstance(raw_contour, dict):&#10;            contour = convert_list_to_ndarray(raw_contour)&#10;        elif isinstance(raw_contour, list):&#10;            contour = [convert_list_to_ndarray(seg) for seg in raw_contour]&#10;        else:&#10;            contour = raw_contour  # unexpected type, leave as-is&#10;&#10;        # ----- Spray pattern -----&#10;        raw_spray_pattern = data.get(GlueWorkpieceField.SPRAY_PATTERN.value, {})&#10;        spray_pattern = {}&#10;&#10;        if isinstance(raw_spray_pattern, dict):&#10;            for key, pattern in raw_spray_pattern.items():&#10;                spray_pattern[key] = [convert_list_to_ndarray(seg) for seg in pattern]&#10;        else:&#10;            spray_pattern = raw_spray_pattern&#10;&#10;        # ----- Build workpiece -----&#10;        workpiece = GlueWorkpiece.from_dict(data)&#10;        workpiece.contour = contour&#10;        workpiece.sprayPattern = spray_pattern&#10;        return workpiece&#10;&#10;    def to_dict(self)-&gt; dict:&#10;        &quot;&quot;&quot;&#10;                Convert the Workpiece object into a dictionary representation.&#10;&#10;                Returns:&#10;                    dict: A dictionary containing the Workpiece's properties, suitable for serialization or storage.&#10;                &quot;&quot;&quot;&#10;        return {&#10;            GlueWorkpieceField.WORKPIECE_ID.value: self.workpieceId,&#10;            GlueWorkpieceField.NAME.value: self.name,&#10;            GlueWorkpieceField.DESCRIPTION.value: self.description,&#10;            GlueWorkpieceField.TOOL_ID.value: self.toolID.value,&#10;            GlueWorkpieceField.GRIPPER_ID.value: self.gripperID.value,&#10;            GlueWorkpieceField.GLUE_TYPE.value: self.glueType.value,&#10;            GlueWorkpieceField.PROGRAM.value: self.program.value,&#10;            GlueWorkpieceField.MATERIAL.value: self.material,&#10;            GlueWorkpieceField.CONTOUR.value: self.contour,&#10;            GlueWorkpieceField.OFFSET.value: self.offset,&#10;            GlueWorkpieceField.HEIGHT.value: self.height,&#10;            GlueWorkpieceField.GLUE_QTY.value: self.glueQty,&#10;            GlueWorkpieceField.SPRAY_WIDTH.value: self.sprayWidth,&#10;            GlueWorkpieceField.PICKUP_POINT.value: self.pickupPoint,&#10;            GlueWorkpieceField.SPRAY_PATTERN.value: self.sprayPattern,&#10;            GlueWorkpieceField.CONTOUR_AREA.value: self.contourArea,&#10;            GlueWorkpieceField.NOZZLES.value: self.nozzles&#10;&#10;        }&#10;&#10;    @staticmethod&#10;    def flatten_spray_pattern(obj):&#10;        &quot;&quot;&quot;&#10;             Flatten nested spray pattern lists into a single list.&#10;&#10;             Args:&#10;                 obj (list): The spray pattern (possibly nested) to be flattened.&#10;&#10;             Returns:&#10;                 list: A flattened list containing all points from the spray pattern.&#10;             &quot;&quot;&quot;&#10;        if isinstance(obj, list):&#10;            flat_obj = []&#10;            for item in obj:&#10;                if isinstance(item, list):&#10;                    flat_obj.extend(GlueWorkpiece.flatten_spray_pattern(item))&#10;                else:&#10;                    flat_obj.append(item)&#10;            return flat_obj&#10;        return [obj]&#10;&#10;    @staticmethod&#10;    def reshape_spray_pattern(obj):&#10;        &quot;&quot;&quot;&#10;        Reshape spray pattern list into list of (N, 1, 2) numpy arrays.&#10;&#10;        Args:&#10;            obj (list): The spray pattern, either a single contour or a list of contours.&#10;&#10;        Returns:&#10;            list: A list of numpy arrays representing the reshaped spray pattern contours.&#10;&#10;        Raises:&#10;            ValueError: If the spray pattern format is invalid or unrecognized.&#10;        &quot;&quot;&quot;&#10;        if not obj:&#10;            return []&#10;&#10;        # If it's a single contour, flatten and reshape it&#10;        if all(isinstance(pt, (list, np.ndarray)) and len(pt) == 2 for pt in obj):&#10;            grouped = np.array(obj, dtype=np.float32).reshape(-1, 1, 2)&#10;            return [grouped]&#10;&#10;        # If it's a list of contours&#10;        if isinstance(obj, list) and all(isinstance(c, list) for c in obj):&#10;            result = []&#10;            for contour in obj:&#10;                if not contour:&#10;                    continue&#10;                flat = GlueWorkpiece.flatten_spray_pattern(contour)&#10;                if all(isinstance(x, (int, float)) for x in flat):&#10;                    grouped = [[flat[i], flat[i + 1]] for i in range(0, len(flat), 2)]&#10;                elif all(isinstance(x, list) and len(x) == 2 for x in flat):&#10;                    grouped = flat&#10;                else:&#10;                    raise ValueError(f&quot;Invalid spray pattern shape: {flat}&quot;)&#10;                result.append(np.array(grouped, dtype=np.float32).reshape(-1, 1, 2))&#10;            return result&#10;&#10;        raise ValueError(f&quot;Unknown spray pattern format: {obj}&quot;)&#10;&#10;    @staticmethod&#10;    def from_dict(data: dict):&#10;        &quot;&quot;&quot;&#10;        Deserialize a dictionary into a Workpiece object.&#10;&#10;        Args:&#10;          data (dict): A dictionary representation of a Workpiece.&#10;&#10;        Returns:&#10;          GlueWorkpiece: The reconstructed Workpiece object.&#10;        &quot;&quot;&quot;&#10;        return GlueWorkpiece(&#10;            workpieceId=data[GlueWorkpieceField.WORKPIECE_ID.value],&#10;            name=data[GlueWorkpieceField.NAME.value],&#10;            description=data[GlueWorkpieceField.DESCRIPTION.value],&#10;            toolID=ToolID(data[GlueWorkpieceField.TOOL_ID.value]),&#10;            gripperID=Gripper(data[GlueWorkpieceField.GRIPPER_ID.value]),&#10;            glueType=GlueType(data[GlueWorkpieceField.GLUE_TYPE.value]),&#10;            program=Program(data[GlueWorkpieceField.PROGRAM.value]),&#10;            material=data[GlueWorkpieceField.MATERIAL.value],&#10;            contour=data[GlueWorkpieceField.CONTOUR.value],&#10;            offset=data[GlueWorkpieceField.OFFSET.value],&#10;            height=data.get(GlueWorkpieceField.HEIGHT.value, 4),&#10;            pickupPoint=data.get(GlueWorkpieceField.PICKUP_POINT.value, None),&#10;            nozzles=data.get(GlueWorkpieceField.NOZZLES.value, []),  # Setting nozzles to empty list if missing&#10;            contourArea=data[GlueWorkpieceField.CONTOUR_AREA.value],&#10;            glueQty=data[GlueWorkpieceField.GLUE_QTY.value],&#10;            sprayWidth=data[GlueWorkpieceField.SPRAY_WIDTH.value],&#10;            sprayPattern=data.get(GlueWorkpieceField.SPRAY_PATTERN.value, []),&#10;&#10;            # Setting spray pattern to empty list if missing&#10;        )&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/src/core/application/interfaces/robot_application_interface.py">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/core/application/interfaces/robot_application_interface.py" />
              <option name="originalContent" value="&quot;&quot;&quot;&#10;Robot Application Interface&#10;&#10;This module defines the standard interface that all robot applications must implement.&#10;It provides a contract for operation control, calibration, workpiece handling, and configuration.&#10;&quot;&quot;&quot;&#10;&#10;from abc import ABC, abstractmethod&#10;from typing import Dict, Any, List&#10;from enum import Enum&#10;&#10;from core.base_robot_application import ApplicationType&#10;from core.operation_state_management import OperationResult&#10;&#10;&#10;class CalibrationStatus(Enum):&#10;    &quot;&quot;&quot;Calibration status indicators&quot;&quot;&quot;&#10;    NOT_CALIBRATED = &quot;not_calibrated&quot;&#10;    IN_PROGRESS = &quot;in_progress&quot;&#10;    CALIBRATED = &quot;calibrated&quot;&#10;    FAILED = &quot;failed&quot;&#10;    EXPIRED = &quot;expired&quot;&#10;&#10;&#10;class WorkpieceProcessingResult(Enum):&#10;    &quot;&quot;&quot;Results of workpiece processing operations&quot;&quot;&quot;&#10;    SUCCESS = &quot;success&quot;&#10;    FAILED = &quot;failed&quot;&#10;    PARTIAL = &quot;partial&quot;&#10;    CANCELLED = &quot;cancelled&quot;&#10;    ERROR = &quot;error&quot;&#10;&#10;&#10;class RobotApplicationInterface(ABC):&#10;    &quot;&quot;&quot;&#10;    Standard interface that all robot applications must implement.&#10;    &#10;    This interface defines the contract for:&#10;    - Operation control (start, stop, pause, resume)&#10;    - Calibration management (robot, camera, tools)&#10;    - Workpiece handling and processing&#10;    - Configuration and settings management&#10;    - Status monitoring and reporting&#10;    &quot;&quot;&quot;&#10;    &#10;    # ========== Core Operation Control ==========&#10;    &#10;    @abstractmethod&#10;    def start(self, **kwargs) -&gt; OperationResult:&#10;        &quot;&quot;&quot;&#10;        Start the robot application operation.&#10;        &#10;        Args:&#10;            mode: Operation mode (automatic, manual, etc.)&#10;            **kwargs: Additional application-specific parameters&#10;            &#10;        Returns:&#10;            Dict containing operation result and status&#10;        &quot;&quot;&quot;&#10;        pass&#10;    &#10;    @abstractmethod&#10;    def stop(self, emergency: bool = False) -&gt; OperationResult:&#10;        &quot;&quot;&quot;&#10;        Stop the robot application operation.&#10;        &#10;        Args:&#10;            emergency: Whether this is an emergency stop&#10;            &#10;        Returns:&#10;            Dict containing operation result&#10;        &quot;&quot;&quot;&#10;        pass&#10;&#10;    @abstractmethod&#10;    def pause(self) -&gt; OperationResult:&#10;        &quot;&quot;&quot;&#10;        Pause the robot application operation.&#10;        &#10;        Returns:&#10;            Dict containing operation result&#10;        &quot;&quot;&quot;&#10;        pass&#10;    &#10;    @abstractmethod&#10;    def resume(self) -&gt; OperationResult:&#10;        &quot;&quot;&quot;&#10;        Resume the robot application operation.&#10;        &#10;        Returns:&#10;            Dict containing operation result&#10;        &quot;&quot;&quot;&#10;        pass&#10;    &#10;    @abstractmethod&#10;    def reset(self) -&gt; OperationResult:&#10;        &quot;&quot;&quot;&#10;        Reset the robot application to initial state.&#10;        &#10;        Returns:&#10;            Dict containing operation result&#10;        &quot;&quot;&quot;&#10;        pass&#10;    &#10;    # ========== Calibration Management ==========&#10;    &#10;    @abstractmethod&#10;    def calibrate_robot(self) -&gt; OperationResult:&#10;        &quot;&quot;&quot;&#10;        Calibrate the robot coordinate system.&#10;        &#10;&#10;        Returns:&#10;            Dict containing calibration result and status&#10;        &quot;&quot;&quot;&#10;        pass&#10;    &#10;    @abstractmethod&#10;    def calibrate_camera(self) -&gt; OperationResult:&#10;        &quot;&quot;&quot;&#10;        Calibrate the camera system.&#10;        &#10;&#10;        Returns:&#10;            Dict containing calibration result and status&#10;        &quot;&quot;&quot;&#10;        pass&#10;&#10;&#10;    # ========== Tool and Hardware Control ==========&#10;&#10;    @abstractmethod&#10;    def home_robot(self) -&gt; OperationResult:&#10;        &quot;&quot;&quot;&#10;        Move robot to home position.&#10;        &#10;        Returns:&#10;            Dict containing operation result&#10;        &quot;&quot;&quot;&#10;        pass&#10;&#10;# ========== Helper Data Classes ==========&#10;&#10;class ApplicationInfo:&#10;    &quot;&quot;&quot;Information about a robot application&quot;&quot;&quot;&#10;    &#10;    def __init__(self, &#10;                 app_type: ApplicationType, &#10;                 name: str, &#10;                 version: str,&#10;                 description: str,&#10;                 supported_operations: List[str],&#10;                 supported_tools: List[str],&#10;                 supported_workpieces: List[str]):&#10;        self.app_type = app_type&#10;        self.name = name&#10;        self.version = version&#10;        self.description = description&#10;        self.supported_operations = supported_operations&#10;        self.supported_tools = supported_tools&#10;        self.supported_workpieces = supported_workpieces&#10;    &#10;    def to_dict(self) -&gt; Dict[str, Any]:&#10;        &quot;&quot;&quot;Convert to dictionary representation&quot;&quot;&quot;&#10;        return {&#10;            &quot;type&quot;: self.app_type.value,&#10;            &quot;name&quot;: self.name,&#10;            &quot;version&quot;: self.version,&#10;            &quot;description&quot;: self.description,&#10;            &quot;supported_operations&quot;: self.supported_operations,&#10;            &quot;supported_tools&quot;: self.supported_tools,&#10;            &quot;supported_workpieces&quot;: self.supported_workpieces&#10;        }&#10;" />
              <option name="updatedContent" value="&quot;&quot;&quot;&#10;Robot Application Interface&#10;&#10;This module defines the standard interface that all robot applications must implement.&#10;It provides a contract for operation control, calibration, workpiece handling, and configuration.&#10;&quot;&quot;&quot;&#10;&#10;from abc import ABC, abstractmethod&#10;from typing import Dict, Any, List&#10;from enum import Enum&#10;&#10;from core.base_robot_application import ApplicationType&#10;from core.operation_state_management import OperationResult&#10;&#10;&#10;class CalibrationStatus(Enum):&#10;    &quot;&quot;&quot;Calibration status indicators&quot;&quot;&quot;&#10;    NOT_CALIBRATED = &quot;not_calibrated&quot;&#10;    IN_PROGRESS = &quot;in_progress&quot;&#10;    CALIBRATED = &quot;calibrated&quot;&#10;    FAILED = &quot;failed&quot;&#10;    EXPIRED = &quot;expired&quot;&#10;&#10;&#10;class WorkpieceProcessingResult(Enum):&#10;    &quot;&quot;&quot;Results of workpiece processing operations&quot;&quot;&quot;&#10;    SUCCESS = &quot;success&quot;&#10;    FAILED = &quot;failed&quot;&#10;    PARTIAL = &quot;partial&quot;&#10;    CANCELLED = &quot;cancelled&quot;&#10;    ERROR = &quot;error&quot;&#10;&#10;&#10;class RobotApplicationInterface(ABC):&#10;    &quot;&quot;&quot;&#10;    Standard interface that all robot applications must implement.&#10;    &#10;    This interface defines the contract for:&#10;    - Operation control (start, stop, pause, resume)&#10;    - Calibration management (robot, camera, tools)&#10;    - Workpiece handling and processing&#10;    - Configuration and settings management&#10;    - Status monitoring and reporting&#10;    &quot;&quot;&quot;&#10;    &#10;    # ========== Core Operation Control ==========&#10;    &#10;    @abstractmethod&#10;    def start(self, **kwargs) -&gt; OperationResult:&#10;        &quot;&quot;&quot;&#10;        Start the robot application operation.&#10;        &#10;        Args:&#10;            mode: Operation mode (automatic, manual, etc.)&#10;            **kwargs: Additional application-specific parameters&#10;            &#10;        Returns:&#10;            Dict containing operation result and status&#10;        &quot;&quot;&quot;&#10;        pass&#10;    &#10;    @abstractmethod&#10;    def stop(self, emergency: bool = False) -&gt; OperationResult:&#10;        &quot;&quot;&quot;&#10;        Stop the robot application operation.&#10;        &#10;        Args:&#10;            emergency: Whether this is an emergency stop&#10;            &#10;        Returns:&#10;            Dict containing operation result&#10;        &quot;&quot;&quot;&#10;        pass&#10;&#10;    @abstractmethod&#10;    def pause(self) -&gt; OperationResult:&#10;        &quot;&quot;&quot;&#10;        Pause the robot application operation.&#10;        &#10;        Returns:&#10;            Dict containing operation result&#10;        &quot;&quot;&quot;&#10;        pass&#10;    &#10;    @abstractmethod&#10;    def resume(self) -&gt; OperationResult:&#10;        &quot;&quot;&quot;&#10;        Resume the robot application operation.&#10;        &#10;        Returns:&#10;            Dict containing operation result&#10;        &quot;&quot;&quot;&#10;        pass&#10;    &#10;    @abstractmethod&#10;    def reset(self) -&gt; OperationResult:&#10;        &quot;&quot;&quot;&#10;        Reset the robot application to initial state.&#10;        &#10;        Returns:&#10;            Dict containing operation result&#10;        &quot;&quot;&quot;&#10;        pass&#10;    &#10;    # ========== Calibration Management ==========&#10;    &#10;    @abstractmethod&#10;    def calibrate_robot(self) -&gt; OperationResult:&#10;        &quot;&quot;&quot;&#10;        Calibrate the robot coordinate system.&#10;        &#10;&#10;        Returns:&#10;            Dict containing calibration result and status&#10;        &quot;&quot;&quot;&#10;        pass&#10;    &#10;    @abstractmethod&#10;    def calibrate_camera(self) -&gt; OperationResult:&#10;        &quot;&quot;&quot;&#10;        Calibrate the camera system.&#10;        &#10;&#10;        Returns:&#10;            Dict containing calibration result and status&#10;        &quot;&quot;&quot;&#10;        pass&#10;&#10;&#10;    # ========== Tool and Hardware Control ==========&#10;&#10;    @abstractmethod&#10;    def home_robot(self) -&gt; OperationResult:&#10;        &quot;&quot;&quot;&#10;        Move robot to home position.&#10;        &#10;        Returns:&#10;            Dict containing operation result&#10;        &quot;&quot;&quot;&#10;        pass&#10;&#10;# ========== Helper Data Classes ==========&#10;&#10;class ApplicationInfo:&#10;    &quot;&quot;&quot;Information about a robot application&quot;&quot;&quot;&#10;    &#10;    def __init__(self, &#10;                 app_type: ApplicationType, &#10;                 name: str, &#10;                 version: str,&#10;                 description: str,&#10;                 supported_operations: List[str],&#10;                 supported_tools: List[str],&#10;                 supported_workpieces: List[str]):&#10;        self.app_type = app_type&#10;        self.name = name&#10;        self.version = version&#10;        self.description = description&#10;        self.supported_operations = supported_operations&#10;        self.supported_tools = supported_tools&#10;        self.supported_workpieces = supported_workpieces&#10;    &#10;    def to_dict(self) -&gt; Dict[str, Any]:&#10;        &quot;&quot;&quot;Convert to dictionary representation&quot;&quot;&quot;&#10;        return {&#10;            &quot;type&quot;: self.app_type.value,&#10;            &quot;name&quot;: self.name,&#10;            &quot;version&quot;: self.version,&#10;            &quot;description&quot;: self.description,&#10;            &quot;supported_operations&quot;: self.supported_operations,&#10;            &quot;supported_tools&quot;: self.supported_tools,&#10;            &quot;supported_workpieces&quot;: self.supported_workpieces&#10;        }" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/src/core/model/robot/fairino_robot.py">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/core/model/robot/fairino_robot.py" />
              <option name="originalContent" value="import platform&#10;import logging&#10;&#10;from modules.utils.custom_logging import setup_logger, LoggerContext, log_info_message, log_error_message, log_debug_message&#10;from core.model.robot.IRobot import IRobot&#10;from core.model.robot.enums.axis import Direction&#10;from frontend.core.services.domain.RobotService import RobotAxis&#10;&#10;if platform.system() == &quot;Windows&quot;:&#10;    pass&#10;&#10;elif platform.system() == &quot;Linux&quot;:&#10;    logging.info(&quot;Linux detected&quot;)&#10;    from libs.fairino.linux.fairino import Robot&#10;else:&#10;    raise Exception(&quot;Unsupported OS&quot;)&#10;&#10;ENABLE_LOGGING = True  # Enable or disable logging&#10;# Initialize logger if enabled&#10;if ENABLE_LOGGING:&#10;    robot_logger = setup_logger(&quot;RobotWrapper&quot;)&#10;else:&#10;    robot_logger = None&#10;&#10;class TestRobotWrapper(IRobot):&#10;    &quot;&quot;&quot;&#10;       A full mock of the Fairino Robot interface.&#10;       Implements every method used by FairinoRobot and returns safe dummy values.&#10;       &quot;&quot;&quot;&#10;&#10;    def __init__(self):&#10;        print(&quot;⚙️  TestRobot initialized (mock robot).&quot;)&#10;&#10;    # --- Motion commands ---&#10;    def move_cartesian(self, position, tool=0, user=0, vel=100, acc=30,blendR=0):&#10;        print(f&quot;[MOCK] MoveCart -&gt; pos={position}, tool={tool}, user={user}, vel={vel}, acc={acc}&quot;)&#10;        return 0&#10;&#10;    def move_liner(self, position, tool=0, user=0, vel=100, acc=30, blendR=0):&#10;        print(f&quot;[MOCK] MoveL -&gt; pos={position}, tool={tool}, user={user}, vel={vel}, acc={acc}, blendR={blendR}&quot;)&#10;        return 0&#10;&#10;    def start_jog(self,axis:RobotAxis,direction:Direction,step,vel,acc):&#10;        print(f&quot;[MOCK] StartJOG -&gt; axis={axis}, direction={direction}, step={step}, vel={vel}, acc={acc}&quot;)&#10;        return 0&#10;&#10;    def stop_motion(self):&#10;        print(&quot;[MOCK] StopMotion called&quot;)&#10;        return 0&#10;&#10;    def ResetAllError(self):&#10;        print(&quot;[MOCK] ResetAllError called&quot;)&#10;        return 0&#10;&#10;    # --- State queries ---&#10;    def get_current_position(self):&#10;        # print(&quot;[MOCK] GetActualTCPPose called&quot;)&#10;        # Returning tuple to match expected structure (status, pose)&#10;        return (0, [0.0, 0.0, 0.0, 0.0, 0.0, 0.0])&#10;&#10;    def get_current_velocity(self):&#10;        print(&quot;[MOCK] GetActualTCPCompositeSpeed called&quot;)&#10;        return (0, [0.0])  # mimic real return: (status, [speed])&#10;&#10;    def GetSDKVersion(self):&#10;        print(&quot;[MOCK] GetSDKVersion called&quot;)&#10;        return &quot;TestRobot SDK v1.0&quot;&#10;&#10;&#10;class FairinoRobot(IRobot):&#10;    &quot;&quot;&quot;&#10;      A wrapper for the real robot controller, abstracting motion and I/O operations.&#10;      &quot;&quot;&quot;&#10;    def __init__(self, ip):&#10;        &quot;&quot;&quot;&#10;               Initializes the robot wrapper and connects to the robot via RPC.&#10;&#10;               Args:&#10;                   ip (str): IP address of the robot controller.&#10;               &quot;&quot;&quot;&#10;        self.ip = ip&#10;        self.robot = Robot.RPC(self.ip)  # Real robot - use in production&#10;        # self.robot = TestRobotWrapper()  # For testing purposes, replace with real robot in production&#10;        self.logger_context = LoggerContext(logger=robot_logger, enabled=ENABLE_LOGGING)&#10;        if self.robot is not None:&#10;            log_info_message(self.logger_context, f&quot;RobotWrapper initialized for robot at {self.ip}&quot;)&#10;        else:&#10;            log_error_message(self.logger_context, f&quot;Failed to connect to robot at {self.ip}&quot;)&#10;            raise ConnectionError(f&quot;Could not connect to robot at {self.ip}&quot;)&#10;&#10;        &quot;&quot;&quot;overSpeedStrategy: over speed handling strategy&#10;        0 - strategy off;&#10;        1 - standard;&#10;        2 - stop on error when over speeding;&#10;        3 - adaptive speed reduction, default 0&quot;&quot;&quot;&#10;        self.overSpeedStrategy = 3&#10;&#10;&#10;&#10;    def move_cartesian(self,position, tool=0, user=0, vel=30, acc=30,blendR=0):&#10;        &quot;&quot;&quot;&#10;              Moves the robot in Cartesian space.&#10;&#10;              Args:&#10;                  blendR&#10;                  position (list): Target Cartesian position.&#10;                  tool (int): Tool frame ID.&#10;                  user (int): User frame ID.&#10;                  vel (float): Velocity.&#10;                  acc (float): Acceleration.&#10;&#10;              Returns:&#10;                  list: Result from robot move command.&#10;              &quot;&quot;&quot;&#10;&#10;        result = self.robot.MoveCart(position, tool, user, vel=vel, acc=acc)&#10;        log_debug_message(self.logger_context, f&quot;MoveCart to {position} with tool {tool}, user {user}, vel {vel}, acc {acc} -&gt; result: {result}&quot;)&#10;        return result&#10;&#10;    def move_liner(self,position, tool=0, user=0, vel=30, acc=30, blendR=0):&#10;        &quot;&quot;&quot;&#10;              Executes a linear movement with blending.&#10;&#10;              Args:&#10;                  position (list): Target position.&#10;                  tool (int): Tool frame ID.&#10;                  user (int): User frame ID.&#10;                  vel (float): Velocity.&#10;                  acc (float): Acceleration.&#10;                  blendR (float): Blend radius.&#10;&#10;              Returns:&#10;                  list: Result from robot linear move command.&#10;              &quot;&quot;&quot;&#10;&#10;        result = self.robot.MoveL(position, tool, user, vel=vel, acc=acc, blendR=blendR)&#10;        log_debug_message(self.logger_context, f&quot;MoveL to {position} with tool {tool}, user {user}, vel {vel}, acc {acc}, blendR {blendR} -&gt; result: {result}&quot;)&#10;        return result&#10;&#10;    def get_current_position(self):&#10;        &quot;&quot;&quot;&#10;              Retrieves the current TCP (tool center point) position.&#10;&#10;              Returns:&#10;                  list: Current robot TCP pose.&#10;              &quot;&quot;&quot;&#10;        try:&#10;            currentPose = self.robot.GetActualTCPPose()&#10;        except Exception as e:&#10;            log_error_message(self.logger_context, f&quot;get_current_position failed: {e}&quot;)&#10;            return None&#10;        # print(f&quot;GetCurrentPosition raw -&gt; {currentPose}&quot;)&#10;        # check if int&#10;        if isinstance(currentPose, int):&#10;            currentPose = None&#10;        else:&#10;            currentPose = currentPose[1]&#10;        # log_debug_message(self.logger_context, f&quot;GetCurrentPosition -&gt; {currentPose}&quot;)&#10;        return currentPose&#10;&#10;    def get_current_velocity(self):&#10;        pass&#10;&#10;    def get_current_acceleration(self):&#10;        pass&#10;&#10;    def enable(self):&#10;        &quot;&quot;&quot;&#10;               Enables the robot, allowing motion.&#10;               &quot;&quot;&quot;&#10;        self.robot.RobotEnable(1)&#10;&#10;    def disable(self):&#10;        &quot;&quot;&quot;&#10;             Disables the robot, preventing motion.&#10;             &quot;&quot;&quot;&#10;        self.robot.RobotEnable(0)&#10;&#10;    def printSdkVersion(self):&#10;        &quot;&quot;&quot;&#10;              Prints the current SDK version of the robot controller.&#10;              &quot;&quot;&quot;&#10;        version = self.robot.GetSDKVersion()&#10;        print(version)&#10;        return version&#10;&#10;&#10;    def setDigitalOutput(self, portId, value):&#10;        &quot;&quot;&quot;&#10;              Sets a digital output pin on the robot.&#10;&#10;              Args:&#10;                  portId (int): Output port number.&#10;                  value (int): Value to set (0 or 1).&#10;              &quot;&quot;&quot;&#10;        result =  self.robot.SetDO(portId, value)&#10;        log_debug_message(self.logger_context, f&quot;SetDigitalOutput port {portId} to {value} -&gt; result: {result}&quot;)&#10;        return result&#10;&#10;    def start_jog(self,axis,direction,step,vel,acc):&#10;        &quot;&quot;&quot;&#10;              Starts jogging the robot in a specified axis and direction.&#10;&#10;              Args:&#10;                  axis (Axis): Axis to jog.&#10;                  direction (Direction): Jog direction (PLUS or MINUS).&#10;                  step (float): Distance to move.&#10;                  vel (float): Velocity of jog.&#10;                  acc (float): Acceleration of jog.&#10;&#10;              Returns:&#10;                  object: Result of the StartJOG command.&#10;              &quot;&quot;&quot;&#10;        axis = axis.value&#10;        direction = direction.value&#10;&#10;        result = self.robot.StartJOG(ref=4,nb=axis,dir=direction,vel=vel,acc=acc,max_dis=step)&#10;        log_debug_message(self.logger_context, f&quot;StartJog axis {axis} direction {direction} step {step} vel {vel} acc {acc} -&gt; result: {result}&quot;)&#10;        return result&#10;&#10;    def stop_motion(self):&#10;        &quot;&quot;&quot;&#10;               Stops all current robot motion.&#10;&#10;               Returns:&#10;                   object: Result of StopMotion command.&#10;               &quot;&quot;&quot;&#10;        return self.robot.StopMotion()&#10;&#10;    def resetAllErrors(self):&#10;        &quot;&quot;&quot;&#10;               Resets all current error states on the robot.&#10;&#10;               Returns:&#10;                   object: Result of ResetAllError command.&#10;               &quot;&quot;&quot;&#10;        print(f&quot;RobotWrapper: ResetAllError called&quot;)&#10;        return self.robot.ResetAllError()&#10;&#10;if __name__ == &quot;__main__&quot;:&#10;    # robot = RobotWrapper(&quot;192.168.58.2&quot;)&#10;    # robot.printSdkVersion()&#10;    # current_pose = robot.getCurrentPosition()&#10;    # print(f&quot;Current Pose: {current_pose}&quot;)&#10;    # # current_speed = robot.getCurrentLinerSpeed()&#10;    # # print(f&quot;Current Speed: {current_speed}&quot;)&#10;&#10;# I will run minimal example&#10;    import time&#10;    robot = FairinoRobot(&quot;192.168.58.2&quot;)&#10;    robot.printSdkVersion()&#10;    time.sleep(1)&#10;    while True:&#10;        print(robot.getCurrentPosition())" />
              <option name="updatedContent" value="import platform&#10;import logging&#10;&#10;from modules.utils.custom_logging import setup_logger, LoggerContext, log_info_message, log_error_message, log_debug_message&#10;from core.model.robot.IRobot import IRobot&#10;from core.model.robot.enums.axis import Direction&#10;from frontend.core.services.domain.RobotService import RobotAxis&#10;&#10;if platform.system() == &quot;Windows&quot;:&#10;    pass&#10;&#10;elif platform.system() == &quot;Linux&quot;:&#10;    logging.info(&quot;Linux detected&quot;)&#10;    from libs.fairino.linux.fairino import Robot&#10;else:&#10;    raise Exception(&quot;Unsupported OS&quot;)&#10;&#10;ENABLE_LOGGING = True  # Enable or disable logging&#10;# Initialize logger if enabled&#10;if ENABLE_LOGGING:&#10;    robot_logger = setup_logger(&quot;RobotWrapper&quot;)&#10;else:&#10;    robot_logger = None&#10;&#10;class TestRobotWrapper(IRobot):&#10;    &quot;&quot;&quot;&#10;       A full mock of the Fairino Robot interface.&#10;       Implements every method used by FairinoRobot and returns safe dummy values.&#10;       &quot;&quot;&quot;&#10;&#10;    def __init__(self):&#10;        print(&quot;⚙️  TestRobot initialized (mock robot).&quot;)&#10;&#10;    # --- Motion commands ---&#10;    def move_cartesian(self, position, tool=0, user=0, vel=100, acc=30,blendR=0):&#10;        print(f&quot;[MOCK] MoveCart -&gt; pos={position}, tool={tool}, user={user}, vel={vel}, acc={acc}&quot;)&#10;        return 0&#10;&#10;    def move_liner(self, position, tool=0, user=0, vel=100, acc=30, blendR=0):&#10;        print(f&quot;[MOCK] MoveL -&gt; pos={position}, tool={tool}, user={user}, vel={vel}, acc={acc}, blendR={blendR}&quot;)&#10;        return 0&#10;&#10;    def start_jog(self,axis:RobotAxis,direction:Direction,step,vel,acc):&#10;        print(f&quot;[MOCK] StartJOG -&gt; axis={axis}, direction={direction}, step={step}, vel={vel}, acc={acc}&quot;)&#10;        return 0&#10;&#10;    def stop_motion(self):&#10;        print(&quot;[MOCK] StopMotion called&quot;)&#10;        return 0&#10;&#10;    def ResetAllError(self):&#10;        print(&quot;[MOCK] ResetAllError called&quot;)&#10;        return 0&#10;&#10;    # --- State queries ---&#10;    def get_current_position(self):&#10;        # print(&quot;[MOCK] GetActualTCPPose called&quot;)&#10;        # Returning tuple to match expected structure (status, pose)&#10;        return (0, [0.0, 0.0, 0.0, 0.0, 0.0, 0.0])&#10;&#10;    def get_current_velocity(self):&#10;        print(&quot;[MOCK] GetActualTCPCompositeSpeed called&quot;)&#10;        return (0, [0.0])  # mimic real return: (status, [speed])&#10;&#10;    def GetSDKVersion(self):&#10;        print(&quot;[MOCK] GetSDKVersion called&quot;)&#10;        return &quot;TestRobot SDK v1.0&quot;&#10;&#10;&#10;class FairinoRobot(IRobot):&#10;    &quot;&quot;&quot;&#10;      A wrapper for the real robot controller, abstracting motion and I/O operations.&#10;      &quot;&quot;&quot;&#10;    def __init__(self, ip):&#10;        &quot;&quot;&quot;&#10;               Initializes the robot wrapper and connects to the robot via RPC.&#10;&#10;               Args:&#10;                   ip (str): IP address of the robot controller.&#10;               &quot;&quot;&quot;&#10;        self.ip = ip&#10;        self.robot = Robot.RPC(self.ip)  # Real robot - use in production&#10;        # self.robot = TestRobotWrapper()  # For testing purposes, replace with real robot in production&#10;        self.logger_context = LoggerContext(logger=robot_logger, enabled=ENABLE_LOGGING)&#10;        if self.robot is not None:&#10;            log_info_message(self.logger_context, f&quot;RobotWrapper initialized for robot at {self.ip}&quot;)&#10;        else:&#10;            log_error_message(self.logger_context, f&quot;Failed to connect to robot at {self.ip}&quot;)&#10;            raise ConnectionError(f&quot;Could not connect to robot at {self.ip}&quot;)&#10;&#10;        &quot;&quot;&quot;overSpeedStrategy: over speed handling strategy&#10;        0 - strategy off;&#10;        1 - standard;&#10;        2 - stop on error when over speeding;&#10;        3 - adaptive speed reduction, default 0&quot;&quot;&quot;&#10;        self.overSpeedStrategy = 3&#10;&#10;&#10;&#10;    def move_cartesian(self,position, tool=0, user=0, vel=30, acc=30,blendR=0):&#10;        &quot;&quot;&quot;&#10;              Moves the robot in Cartesian space.&#10;&#10;              Args:&#10;                  blendR&#10;                  position (list): Target Cartesian position.&#10;                  tool (int): Tool frame ID.&#10;                  user (int): User frame ID.&#10;                  vel (float): Velocity.&#10;                  acc (float): Acceleration.&#10;&#10;              Returns:&#10;                  list: Result from robot move command.&#10;              &quot;&quot;&quot;&#10;&#10;        result = self.robot.MoveCart(position, tool, user, vel=vel, acc=acc)&#10;        log_debug_message(self.logger_context, f&quot;MoveCart to {position} with tool {tool}, user {user}, vel {vel}, acc {acc} -&gt; result: {result}&quot;)&#10;        return result&#10;&#10;    def move_liner(self,position, tool=0, user=0, vel=30, acc=30, blendR=0):&#10;        &quot;&quot;&quot;&#10;              Executes a linear movement with blending.&#10;&#10;              Args:&#10;                  position (list): Target position.&#10;                  tool (int): Tool frame ID.&#10;                  user (int): User frame ID.&#10;                  vel (float): Velocity.&#10;                  acc (float): Acceleration.&#10;                  blendR (float): Blend radius.&#10;&#10;              Returns:&#10;                  list: Result from robot linear move command.&#10;              &quot;&quot;&quot;&#10;&#10;        result = self.robot.MoveL(position, tool, user, vel=vel, acc=acc, blendR=blendR)&#10;        log_debug_message(self.logger_context, f&quot;MoveL to {position} with tool {tool}, user {user}, vel {vel}, acc {acc}, blendR {blendR} -&gt; result: {result}&quot;)&#10;        return result&#10;&#10;    def get_current_position(self):&#10;        &quot;&quot;&quot;&#10;              Retrieves the current TCP (tool center point) position.&#10;&#10;              Returns:&#10;                  list: Current robot TCP pose.&#10;              &quot;&quot;&quot;&#10;        try:&#10;            currentPose = self.robot.GetActualTCPPose()&#10;        except Exception as e:&#10;            log_error_message(self.logger_context, f&quot;get_current_position failed: {e}&quot;)&#10;            return None&#10;        # print(f&quot;GetCurrentPosition raw -&gt; {currentPose}&quot;)&#10;        # check if int&#10;        if isinstance(currentPose, int):&#10;            currentPose = None&#10;        else:&#10;            currentPose = currentPose[1]&#10;        # log_debug_message(self.logger_context, f&quot;GetCurrentPosition -&gt; {currentPose}&quot;)&#10;        return currentPose&#10;&#10;    def get_current_velocity(self):&#10;        pass&#10;&#10;    def get_current_acceleration(self):&#10;        pass&#10;&#10;    def enable(self):&#10;        &quot;&quot;&quot;&#10;               Enables the robot, allowing motion.&#10;               &quot;&quot;&quot;&#10;        self.robot.RobotEnable(1)&#10;&#10;    def disable(self):&#10;        &quot;&quot;&quot;&#10;             Disables the robot, preventing motion.&#10;             &quot;&quot;&quot;&#10;        self.robot.RobotEnable(0)&#10;&#10;    def printSdkVersion(self):&#10;        &quot;&quot;&quot;&#10;              Prints the current SDK version of the robot controller.&#10;              &quot;&quot;&quot;&#10;        version = self.robot.GetSDKVersion()&#10;        print(version)&#10;        return version&#10;&#10;&#10;    def setDigitalOutput(self, portId, value):&#10;        &quot;&quot;&quot;&#10;              Sets a digital output pin on the robot.&#10;&#10;              Args:&#10;                  portId (int): Output port number.&#10;                  value (int): Value to set (0 or 1).&#10;              &quot;&quot;&quot;&#10;        result =  self.robot.SetDO(portId, value)&#10;        log_debug_message(self.logger_context, f&quot;SetDigitalOutput port {portId} to {value} -&gt; result: {result}&quot;)&#10;        return result&#10;&#10;    def start_jog(self,axis,direction,step,vel,acc):&#10;        &quot;&quot;&quot;&#10;              Starts jogging the robot in a specified axis and direction.&#10;&#10;              Args:&#10;                  axis (Axis): Axis to jog.&#10;                  direction (Direction): Jog direction (PLUS or MINUS).&#10;                  step (float): Distance to move.&#10;                  vel (float): Velocity of jog.&#10;                  acc (float): Acceleration of jog.&#10;&#10;              Returns:&#10;                  object: Result of the StartJOG command.&#10;              &quot;&quot;&quot;&#10;        axis = axis.value&#10;        direction = direction.value&#10;&#10;        result = self.robot.StartJOG(ref=4,nb=axis,dir=direction,vel=vel,acc=acc,max_dis=step)&#10;        log_debug_message(self.logger_context, f&quot;StartJog axis {axis} direction {direction} step {step} vel {vel} acc {acc} -&gt; result: {result}&quot;)&#10;        return result&#10;&#10;    def stop_motion(self):&#10;        &quot;&quot;&quot;&#10;               Stops all current robot motion.&#10;&#10;               Returns:&#10;                   object: Result of StopMotion command.&#10;               &quot;&quot;&quot;&#10;        return self.robot.StopMotion()&#10;&#10;    def resetAllErrors(self):&#10;        &quot;&quot;&quot;&#10;               Resets all current error states on the robot.&#10;&#10;               Returns:&#10;                   object: Result of ResetAllError command.&#10;               &quot;&quot;&quot;&#10;        print(f&quot;RobotWrapper: ResetAllError called&quot;)&#10;        return self.robot.ResetAllError()&#10;&#10;if __name__ == &quot;__main__&quot;:&#10;    # robot = RobotWrapper(&quot;192.168.58.2&quot;)&#10;    # robot.printSdkVersion()&#10;    # current_pose = robot.getCurrentPosition()&#10;    # print(f&quot;Current Pose: {current_pose}&quot;)&#10;    # # current_speed = robot.getCurrentLinerSpeed()&#10;    # # print(f&quot;Current Speed: {current_speed}&quot;)&#10;&#10;# I will run minimal example&#10;    import time&#10;    robot = FairinoRobot(&quot;192.168.58.2&quot;)&#10;    robot.printSdkVersion()&#10;    time.sleep(1)&#10;    while True:&#10;        print(robot.getCurrentPosition())" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="/tmp/test_robot_repo.py">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="/tmp/test_robot_repo.py" />
            </PendingDiffInfo>
          </value>
        </entry>
      </map>
    </option>
  </component>
</project>