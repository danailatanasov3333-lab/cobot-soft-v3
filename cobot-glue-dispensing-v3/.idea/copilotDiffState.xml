<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="CopilotDiffPersistence">
    <option name="pendingDiffs">
      <map>
        <entry key="$PROJECT_DIR$/src/applications/glue_dispensing_application/GlueDispensingApplication.py">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/applications/glue_dispensing_application/GlueDispensingApplication.py" />
              <option name="originalContent" value="from typing import Dict, Any&#10;&#10;from typing_extensions import override&#10;&#10;from applications.glue_dispensing_application.services.glueSprayService.GlueSprayService import GlueSprayService&#10;from applications.glue_dispensing_application.services.workpiece.glue_workpiece_service import GlueWorkpieceService&#10;from communication_layer.api.v1.topics import GlueTopics, SystemTopics&#10;from core.application.interfaces.application_settings_interface import ApplicationSettingsRegistry&#10;from core.application.interfaces.robot_application_interface import RobotApplicationInterface&#10;&#10;import logging&#10;&#10;from backend.system.settings.SettingsService import SettingsService&#10;from core.application_state_management import SubscriptionManger, OperationState&#10;from core.operation_state_management import OperationStatePublisher&#10;from core.operation_state_management import OperationResult&#10;from core.operations_handlers.camera_calibration_handler import \&#10;    calibrate_camera&#10;from core.operations_handlers.robot_calibration_handler import calibrate_robot&#10;from core.services.robot_service.impl.base_robot_service import RobotService&#10;from core.services.vision.VisionService import _VisionService&#10;# Import base classes&#10;from core.base_robot_application import BaseRobotApplication, ApplicationState, ApplicationMetadata&#10;&#10;from applications.glue_dispensing_application.glue_process.glue_dispensing_operation import \&#10;    GlueDispensingOperation&#10;from applications.glue_dispensing_application.glue_process.state_machine.GlueProcessState import \&#10;    GlueProcessState&#10;from applications.glue_dispensing_application.glue_process.state_machine.GlueProcessStateMachine import \&#10;    GlueProcessStateMachine&#10;from applications.glue_dispensing_application.handlers import spraying_handler, nesting_handler&#10;from applications.glue_dispensing_application.handlers.clean_nozzle_handler import clean_nozzle&#10;from applications.glue_dispensing_application.handlers.create_workpiece_handler import \&#10;    CreateWorkpieceHandler, CrateWorkpieceResult&#10;from applications.glue_dispensing_application.handlers.handle_start import start&#10;from applications.glue_dispensing_application.handlers.match_workpiece_handler import WorkpieceMatcher&#10;from applications.glue_dispensing_application.handlers.temp_handlers.execute_from_gallery_handler import \&#10;    execute_from_gallery&#10;from applications.glue_dispensing_application.handlers.workpieces_to_spray_paths_handler import \&#10;    WorkpieceToSprayPathsGenerator&#10;from applications.glue_dispensing_application.settings.GlueSettings import GlueSettings&#10;from applications.glue_dispensing_application.settings.GlueSettingsHandler import GlueSettingsHandler&#10;from core.system_state_management import ServiceRegistry&#10;from modules.shared.MessageBroker import MessageBroker&#10;from modules.shared.tools.GlueCell import GlueCellsManagerSingleton, GlueDataFetcher&#10;&#10;&quot;&quot;&quot;&#10;ENDPOINTS&#10;- start&#10;- measureHeight&#10;- calibrateRobot&#10;- calibrateCamera&#10;- createWorkpiece&#10;&#10;&quot;&quot;&quot;&#10;&#10;Z_OFFSET_FOR_CALIBRATION_PATTERN = -4 # MM&#10;&#10;class GlueSprayingApplication(BaseRobotApplication, RobotApplicationInterface):&#10;    &quot;&quot;&quot;&#10;    ActionManager is responsible for connecting actions to functions.&#10;    The MainWindow will just emit signals, and ActionManager handles them.&#10;    &quot;&quot;&quot;&#10;&#10;    glueCellsManager = GlueCellsManagerSingleton.get_instance()&#10;&#10;    def __init__(self,&#10;                 vision_service: _VisionService,&#10;                 settings_manager: SettingsService,&#10;                 workpiece_service: GlueWorkpieceService,&#10;                 robot_service: RobotService,&#10;                 settings_registry: ApplicationSettingsRegistry,&#10;                 service_registry: ServiceRegistry,&#10;                 **kwargs&#10;                 ):&#10;&#10;        # Initialize logger first (before base class to avoid issues)&#10;        self.logger = logging.getLogger(self.__class__.__name__)&#10;&#10;        self.vision_service = vision_service&#10;        self.settings_manager = settings_manager&#10;        self.workpiece_service=workpiece_service&#10;        self.robot_service = robot_service&#10;        self.settings_registry = settings_registry&#10;        self.service_registry = service_registry&#10;        # Initialize the base class&#10;        super().__init__(self.vision_service, self.settings_manager, self.robot_service,self.settings_registry)&#10;&#10;        # Register application-specific settings after initialization&#10;        self._register_settings()&#10;&#10;        # Application-specific initialization&#10;        self.preselected_workpiece = None&#10;        self.workpiece_to_spray_paths_generator = WorkpieceToSprayPathsGenerator(self)&#10;        self.create_workpiece_handler = CreateWorkpieceHandler(self)&#10;        &#10;        # Initialize glue process state machine for operation control&#10;        self.glue_process_state_machine = GlueProcessStateMachine(GlueProcessState.INITIALIZING)&#10;        self.workpiece_matcher = WorkpieceMatcher()&#10;        self.glue_service= GlueSprayService(generatorTurnOffTimeout=10, settings=self.get_glue_settings())&#10;        # TODO: register glue service in service registry when the glue service state management is implemented&#10;        # self.service_registry.register_service(self.glue_service.service_id,&quot;glue-service/state&quot;,ServiceState.UNKNOWN)&#10;        # print(f&quot;Registered Services in Glue App: {service_registry.get_registered_services()}&quot;)&#10;        # Initialize glue dispensing operation with proper settings access&#10;        self.glue_dispensing_operation = GlueDispensingOperation(self.robot_service, self.glue_service,self)&#10;        self.glue_dispensing_operation.set_state_publisher(OperationStatePublisher(self.broker))&#10;        self.broker.publish(SystemTopics.OPERATION_STATE, OperationState.IDLE)&#10;&#10;        self.NESTING = True&#10;        self.CONTOUR_MATCHING = True&#10;        self.current_operation = self.glue_dispensing_operation&#10;&#10;    @property&#10;    def operation(self):&#10;        return self.current_operation&#10;&#10;    @override&#10;    def set_current_operation(self):&#10;        &quot;&quot;&quot;determine the current operation based on mode&quot;&quot;&quot;&#10;        self.current_operation = self.glue_dispensing_operation&#10;    @override&#10;    def _on_operation_start(self, debug=True, **kwargs) -&gt;OperationResult:&#10;        return start(self, self.CONTOUR_MATCHING, self.NESTING, debug)&#10;&#10;    @staticmethod&#10;    def get_metadata() -&gt; ApplicationMetadata:&#10;        return ApplicationMetadata(&#10;            name=&quot;Glue Spraying Application&quot;,&#10;            version=&quot;1.0.0&quot;,&#10;            dependencies=[&quot;_VisionService&quot;,&#10;                          &quot;SettingsService&quot;,&#10;                          &quot;GlueRobotService&quot;,&#10;                          &quot;ApplicationSettingsRegistry&quot;],&#10;        )&#10;&#10;&#10;    def initialize_glue_data_fetcher(self):&#10;        glue_fetcher = GlueDataFetcher()&#10;        glue_fetcher.start()&#10;&#10;    # ========== BaseRobotApplication Abstract Methods Implementation ==========&#10;    &#10;    def get_initial_state(self) -&gt; ApplicationState:&#10;        &quot;&quot;&quot;Return the initial state for this application&quot;&quot;&quot;&#10;        return ApplicationState.INITIALIZING&#10;&#10;    def start_nesting(self, debug=True)-&gt; OperationResult:&#10;        self.current_operation = &quot;Nesting&quot;&#10;        result =  nesting_handler.start_nesting(self, self.get_workpieces())&#10;        return OperationResult(success=result.success,message=result.message)&#10;&#10;    def start_spraying(self,workpieces, debug=True)-&gt; OperationResult:&#10;        self.current_operation = &quot;Spraying&quot;&#10;        return spraying_handler.start_spraying(self, workpieces, debug)&#10;&#10;    def move_to_nesting_capture_position(self, z_offset=0):&#10;        ret = self.robot_service.moveToStartPosition(z_offset=z_offset)&#10;&#10;        if ret != 0:&#10;            return ret&#10;&#10;        target_pose = self.robot_service.robot_config.getHomePositionParsed()&#10;        target_pose[2] += z_offset  # apply z_offset&#10;        self.robot_service._waitForRobotToReachPosition(target_pose, 1, 0.1)&#10;        return ret&#10;&#10;    def move_to_spray_capture_position(self, z_offset=0):&#10;        ret = self.robot_service.move_to_calibration_position(z_offset=z_offset)&#10;&#10;        if ret != 0:&#10;            return ret&#10;&#10;        target_pose = self.robot_service.robot_config.getCalibrationPositionParsed()&#10;        target_pose[2] += z_offset  # apply z_offset&#10;        self.robot_service._waitForRobotToReachPosition(target_pose, 1, 0.1)&#10;        return ret&#10;&#10;    # ========== Tool and Hardware Control ==========&#10;&#10;    def clean_nozzle(self) -&gt; Dict[str, Any]:&#10;        &quot;&quot;&quot;&#10;        Clean the robot nozzle.&#10;        Default implementation - can be overridden by specific applications.&#10;        &quot;&quot;&quot;&#10;        return clean_nozzle(self.robot_service)&#10;&#10;    def clean_tool(self, tool_id: str) -&gt; OperationResult:&#10;        &quot;&quot;&quot;Clean a specific tool (e.g., nozzle cleaning)&quot;&quot;&quot;&#10;        try:&#10;            if tool_id == &quot;nozzle&quot;:&#10;                result = self.clean_nozzle()&#10;                return OperationResult(&#10;                    success=True,&#10;                    message=f&quot;Tool {tool_id} cleaned successfully&quot;,&#10;                    data=result&#10;                )&#10;&#10;            else:&#10;                return OperationResult(&#10;                    success=False,&#10;                    message=f&quot;Tool {tool_id} not supported for cleaning&quot;&#10;                )&#10;&#10;        except Exception as e:&#10;            return OperationResult(&#10;                success=False,&#10;                message=f&quot;Failed to clean tool {tool_id}: {e}&quot;,&#10;                error=str(e)&#10;            )&#10;&#10;    &#10;    def reset(self) -&gt; Dict[str, Any]:&#10;        &quot;&quot;&quot;Reset the robot application to initial state&quot;&quot;&quot;&#10;        try:&#10;            # Stop any ongoing operation&#10;            self.stop()&#10;            &#10;            # Reset to initial state&#10;            self.state_manager.update_state(ApplicationState.IDLE)&#10;            &#10;            # Clear preselected workpiece&#10;            self.preselected_workpiece = None&#10;            &#10;            # Reset modes to default&#10;            self.NESTING = True&#10;            self.CONTOUR_MATCHING = True&#10;            &#10;            return {&#10;                &quot;success&quot;: True,&#10;                &quot;message&quot;: &quot;Application reset to initial state&quot;&#10;            }&#10;        except Exception as e:&#10;            return {&#10;                &quot;success&quot;: False,&#10;                &quot;message&quot;: f&quot;Failed to reset application: {e}&quot;,&#10;                &quot;error&quot;: str(e)&#10;            } # TODO not used!&#10;&#10;    # ========== Calibration Management ==========&#10;&#10;&#10;    def create_workpiece(self) -&gt; CrateWorkpieceResult:&#10;        return  self.create_workpiece_handler.create_workpiece()&#10;&#10;    # ========== Workpiece Handling ==========&#10;    &#10;    def load_workpiece(self, workpiece_id: str) -&gt; Dict[str, Any]:&#10;        &quot;&quot;&quot;Load a workpiece for processing&quot;&quot;&quot;&#10;        try:&#10;            workpiece = self.workpiece_service.get_workpiece_by_id(workpiece_id)&#10;            if workpiece is None:&#10;                return {&#10;                    &quot;success&quot;: False,&#10;                    &quot;message&quot;: f&quot;Workpiece with ID {workpiece_id} not found&quot;&#10;                }&#10;            &#10;            self.preselected_workpiece = workpiece&#10;            return {&#10;                &quot;success&quot;: True,&#10;                &quot;message&quot;: f&quot;Workpiece {workpiece_id} loaded successfully&quot;,&#10;                &quot;data&quot;: {&#10;                    &quot;workpiece_id&quot;: workpiece_id,&#10;                    &quot;workpiece_name&quot;: workpiece.name if hasattr(workpiece, 'name') else 'Unknown'&#10;                }&#10;            }&#10;        except Exception as e:&#10;            return {&#10;                &quot;success&quot;: False,&#10;                &quot;message&quot;: f&quot;Failed to load workpiece: {e}&quot;,&#10;                &quot;error&quot;: str(e)&#10;            }&#10;    &#10;    def process_workpiece(self, workpiece_id: str, **parameters) -&gt; Dict[str, Any]:&#10;        &quot;&quot;&quot;Process a workpiece with the robot application&quot;&quot;&quot;&#10;        try:&#10;            # Load the workpiece&#10;            load_result = self.load_workpiece(workpiece_id)&#10;            if not load_result[&quot;success&quot;]:&#10;                return load_result&#10;            &#10;            # Start the dispensing operation&#10;            start_result = self.start(**parameters)&#10;            &#10;            return {&#10;                &quot;success&quot;: start_result[&quot;success&quot;],&#10;                &quot;message&quot;: f&quot;Workpiece {workpiece_id} processing {'started' if start_result['success'] else 'failed'}&quot;,&#10;                &quot;data&quot;: {&#10;                    &quot;workpiece_id&quot;: workpiece_id,&#10;                    &quot;processing_result&quot;: start_result&#10;                }&#10;            }&#10;        except Exception as e:&#10;            return {&#10;                &quot;success&quot;: False,&#10;                &quot;message&quot;: f&quot;Failed to process workpiece: {e}&quot;,&#10;                &quot;error&quot;: str(e)&#10;            }&#10;    &#10;    def get_workpieces(self):&#10;        &quot;&quot;&quot;Legacy method for backward compatibility&quot;&quot;&quot;&#10;        if self.preselected_workpiece is None:&#10;            workpieces = self.workpiece_service.load_all()&#10;            print(f&quot; Loaded workpieces: {len(workpieces)}&quot;)&#10;        else:&#10;            workpieces = [self.preselected_workpiece]&#10;            print(f&quot; Using preselected workpiece: {self.preselected_workpiece.name}&quot;)&#10;        return workpieces&#10;&#10;    def get_dynamic_offsets_config(self):&#10;        &quot;&quot;&quot;&#10;        Return the dynamic offset configuration including step offsets and direction map.&#10;        &quot;&quot;&quot;&#10;        # Step offsets&#10;        x_step_offset = self.robot_service.robot_config.tcp_x_step_offset&#10;        y_step_offset = self.robot_service.robot_config.tcp_y_step_offset&#10;&#10;        # Optionally: distances (if still used)&#10;        x_distance = getattr(self.robot_service.robot_config, 'tcp_x_step_distance', 50.0)&#10;        y_distance = getattr(self.robot_service.robot_config, 'tcp_y_step_distance', 50.0)&#10;&#10;        # Direction map&#10;        direction_map = self.robot_service.robot_config.offset_direction_map&#10;        # print(f&quot;in get_dynamic_offsets_config: direction_map={direction_map}&quot;)&#10;        return x_distance, x_step_offset, y_distance, y_step_offset, direction_map&#10;&#10;    def get_transducer_offsets(self):&#10;        # NOTE:&#10;        # - The offsets defined here are measured in the robot's 0° TCP (Tool Center Point) orientation.&#10;&#10;        x_offset = self.robot_service.robot_config.tcp_x_offset # to the top left corner of the transducer&#10;        y_offset = self.robot_service.robot_config.tcp_y_offset # to the top left corner of the transducer&#10;&#10;        # print(f&quot;Transducer offsets: x_offset={x_offset}, y_offset={y_offset}&quot;)&#10;        return [x_offset, y_offset]&#10;&#10;    &quot;&quot;&quot; TEMP METHODS FOR TESTING WHILE IN DEVELOPMENT &quot;&quot;&quot;&#10;&#10;    def handleExecuteFromGallery(self, workpiece):&#10;        return execute_from_gallery(self,workpiece,Z_OFFSET_FOR_CALIBRATION_PATTERN)&#10;&#10;    def on_mode_change(self,message):&#10;        print(f&quot;Changing mode to: {message}&quot;)&#10;        if message == &quot;Spray Only&quot;:&#10;            self.NESTING = False&#10;        elif message == &quot;Pick And Spray&quot;:&#10;            self.NESTING = True&#10;        else:&#10;            raise ValueError(f&quot;Unknown mode: {message}&quot;)&#10;&#10;    def run_demo(self):&#10;&#10;        if self.preselected_workpiece is None:&#10;            print(f&quot;No preselected workpiece set for demo&quot;)&#10;            return False, &quot;No preselected workpiece set for demo&quot;&#10;&#10;        workpiece = self.workpiece_service.get_workpiece_by_id(self.preselected_workpiece)&#10;        if workpiece is None:&#10;            print(f&quot;Demo workpiece with ID {self.preselected_workpiece} not found.&quot;)&#10;            return True, f&quot;Demo workpiece with ID {self.preselected_workpiece} not found.&quot;&#10;&#10;        print(&quot;Demo workpiece found: &quot;, workpiece)&#10;        return True, &quot;Demo workpiece found&quot;&#10;&#10;    &quot;&quot;&quot; TEMP METHODS FOR TESTING WHILE IN DEVELOPMENT &quot;&quot;&quot;&#10;&#10;    def handle_set_preselected_workpiece(self, wp_id):&#10;        selected_workpiece = None&#10;        all_workpieces = self.workpiece_service.load_all()&#10;        for wp in all_workpieces:&#10;            if str(wp.workpieceId) == str(wp_id):&#10;                selected_workpiece = wp&#10;                break&#10;&#10;        if selected_workpiece is not None:&#10;            self.preselected_workpiece = selected_workpiece&#10;            print(f&quot;Preselected workpiece set to ID: {wp_id}&quot;)&#10;            print(f&quot;Workpiece: {selected_workpiece}&quot;)&#10;            print(f&quot;Pickup point: {selected_workpiece.pickupPoint}&quot;)&#10;&#10;            return True, f&quot;Preselected workpiece set to ID: {wp_id}&quot;&#10;        else:&#10;            print(f&quot;Workpiece with ID: {wp_id} not found&quot;)&#10;            return False, f&quot;Workpiece with ID: {wp_id} not found&quot;&#10;&#10;    # ========== Application-Specific Information ==========&#10;&#10;    def _register_settings(self):&#10;        &quot;&quot;&quot;Register glue application settings with the global settings registry&quot;&quot;&quot;&#10;        try:&#10;            # Create glue settings instance&#10;            glue_settings = GlueSettings()&#10;            &#10;            # Create glue settings handler  &#10;            glue_handler = GlueSettingsHandler()&#10;            &#10;            # Register both with the global registry&#10;            self.settings_registry.register_settings_type(glue_settings)&#10;            self.settings_registry.register_handler(glue_handler)&#10;            &#10;            self.logger.info(&quot;Glue application settings registered successfully&quot;)&#10;            &#10;        except Exception as e:&#10;            self.logger.error(f&quot;Failed to register glue application settings: {e}&quot;)&#10;&#10;    def get_glue_settings(self):&#10;        &quot;&quot;&quot;Get glue settings object for this application&quot;&quot;&quot;&#10;        try:&#10;            handler = self.settings_registry.get_handler(&quot;glue&quot;)&#10;            return handler.get_settings_object()&#10;        except Exception as e:&#10;            self.logger.error(f&quot;Failed to get glue settings: {e}&quot;)&#10;            # Fallback to default settings&#10;            return GlueSettings()&#10;&#10;    &quot;&quot;&quot;SUPER CLASS METHODS FOR EXTENSIONS OR OVERRIDE IF NEEDED&quot;&quot;&quot;&#10;&#10;    @override&#10;    def start(self, debug=True, **kwargs) -&gt; OperationResult:&#10;        &quot;&quot;&quot;Start the robot application operation&#10;        calling the super class start method which in turn calls _on_operation_start&#10;        keeping this method for clarity and possible future customizations&quot;&quot;&quot;&#10;        return super().start()&#10;        # return start(self, self.CONTOUR_MATCHING, self.NESTING, debug)&#10;&#10;    @override&#10;    def stop(self, emergency: bool = False) -&gt; OperationResult:&#10;        &quot;&quot;&quot;Stop the robot application operation&quot;&quot;&quot;&#10;        # CALLING SUPER CLASS STOP METHOD. KEEPING THIS METHOD FOR CLARITY AND POSSIBLE FUTURE CUSTOMIZATIONS&#10;        print(f&quot;[GlueSprayingApplication] Stopping operation, emergency={emergency}&quot;)&#10;        return super().stop()&#10;&#10;    @override&#10;    def pause(self) -&gt; OperationResult:&#10;        &quot;&quot;&quot;Pause the robot application operation&quot;&quot;&quot;&#10;        # CALLING SUPER CLASS PAUSE METHOD. KEEPING THIS METHOD FOR CLARITY AND POSSIBLE FUTURE CUSTOMIZATIONS&#10;        return super().pause()&#10;&#10;    @override&#10;    def resume(self) -&gt; OperationResult:&#10;        &quot;&quot;&quot;Resume the robot application operation&quot;&quot;&quot;&#10;        # CALLING SUPER CLASS RESUME METHOD. KEEPING THIS METHOD FOR CLARITY AND POSSIBLE FUTURE CUSTOMIZATIONS&#10;        return super().resume()&#10;&#10;    @override&#10;    def calibrate_robot(self) -&gt; Dict[str, Any]:&#10;        &quot;&quot;&quot;Calibrate the robot coordinate system&quot;&quot;&quot;&#10;        # CALLING THE SUPER CALIBRATE ROBOT METHOD AND KEEPING THIS FOR CLARITY AND POSSIBLE CHANGES&#10;        return super().calibrate_robot()&#10;&#10;    @override&#10;    def calibrate_camera(self) -&gt; Dict[str, Any]:&#10;        &quot;&quot;&quot;Calibrate the camera system&quot;&quot;&quot;&#10;        # CALLING THE SUPER CALIBRATE CAMERA METHOD AND KEEPING THIS FOR CLARITY AND POSSIBLE CHANGES&#10;        return super().calibrate_camera()&#10;&#10;    @override&#10;    def home_robot(self):&#10;        &quot;&quot;&quot;Move robot to home position&quot;&quot;&quot;&#10;        return super().home_robot()&#10;" />
              <option name="updatedContent" value="from typing import Dict, Any&#10;&#10;from typing_extensions import override&#10;&#10;from applications.glue_dispensing_application.services.glueSprayService.GlueSprayService import GlueSprayService&#10;from applications.glue_dispensing_application.services.workpiece.glue_workpiece_service import GlueWorkpieceService&#10;from communication_layer.api.v1.topics import GlueTopics, SystemTopics&#10;from core.application.interfaces.application_settings_interface import ApplicationSettingsRegistry&#10;from core.application.interfaces.robot_application_interface import RobotApplicationInterface&#10;&#10;import logging&#10;&#10;from backend.system.settings.SettingsService import SettingsService&#10;from core.application_state_management import SubscriptionManger, OperationState&#10;from core.operation_state_management import OperationStatePublisher&#10;from core.operation_state_management import OperationResult&#10;from core.operations_handlers.camera_calibration_handler import \&#10;    calibrate_camera&#10;from core.operations_handlers.robot_calibration_handler import calibrate_robot&#10;from core.services.robot_service.impl.base_robot_service import RobotService&#10;from core.services.vision.VisionService import _VisionService&#10;# Import base classes&#10;from core.base_robot_application import BaseRobotApplication, ApplicationState, ApplicationMetadata&#10;&#10;from applications.glue_dispensing_application.glue_process.glue_dispensing_operation import \&#10;    GlueDispensingOperation&#10;from applications.glue_dispensing_application.glue_process.state_machine.GlueProcessState import \&#10;    GlueProcessState&#10;from applications.glue_dispensing_application.glue_process.state_machine.GlueProcessStateMachine import \&#10;    GlueProcessStateMachine&#10;from applications.glue_dispensing_application.handlers import spraying_handler, nesting_handler&#10;from applications.glue_dispensing_application.handlers.clean_nozzle_handler import clean_nozzle&#10;from applications.glue_dispensing_application.handlers.create_workpiece_handler import \&#10;    CreateWorkpieceHandler, CrateWorkpieceResult&#10;from applications.glue_dispensing_application.handlers.handle_start import start&#10;from applications.glue_dispensing_application.handlers.match_workpiece_handler import WorkpieceMatcher&#10;from applications.glue_dispensing_application.handlers.temp_handlers.execute_from_gallery_handler import \&#10;    execute_from_gallery&#10;from applications.glue_dispensing_application.handlers.workpieces_to_spray_paths_handler import \&#10;    WorkpieceToSprayPathsGenerator&#10;from applications.glue_dispensing_application.settings.GlueSettings import GlueSettings&#10;from applications.glue_dispensing_application.settings.GlueSettingsHandler import GlueSettingsHandler&#10;from core.system_state_management import ServiceRegistry&#10;from modules.shared.MessageBroker import MessageBroker&#10;from modules.shared.tools.GlueCell import GlueCellsManagerSingleton, GlueDataFetcher&#10;&#10;&quot;&quot;&quot;&#10;ENDPOINTS&#10;- start&#10;- measureHeight&#10;- calibrateRobot&#10;- calibrateCamera&#10;- createWorkpiece&#10;&#10;&quot;&quot;&quot;&#10;&#10;Z_OFFSET_FOR_CALIBRATION_PATTERN = -4 # MM&#10;&#10;class GlueSprayingApplication(BaseRobotApplication, RobotApplicationInterface):&#10;    &quot;&quot;&quot;&#10;    ActionManager is responsible for connecting actions to functions.&#10;    The MainWindow will just emit signals, and ActionManager handles them.&#10;    &quot;&quot;&quot;&#10;&#10;    glueCellsManager = GlueCellsManagerSingleton.get_instance()&#10;&#10;    def __init__(self,&#10;                 vision_service: _VisionService,&#10;                 settings_manager: SettingsService,&#10;                 workpiece_service: GlueWorkpieceService,&#10;                 robot_service: RobotService,&#10;                 settings_registry: ApplicationSettingsRegistry,&#10;                 service_registry: ServiceRegistry,&#10;                 **kwargs&#10;                 ):&#10;&#10;        # Initialize logger first (before base class to avoid issues)&#10;        self.logger = logging.getLogger(self.__class__.__name__)&#10;&#10;        self.vision_service = vision_service&#10;        self.settings_manager = settings_manager&#10;        self.workpiece_service=workpiece_service&#10;        self.robot_service = robot_service&#10;        self.settings_registry = settings_registry&#10;        self.service_registry = service_registry&#10;        # Initialize the base class&#10;        super().__init__(self.vision_service, self.settings_manager, self.robot_service,self.settings_registry)&#10;&#10;        # Register application-specific settings after initialization&#10;        self._register_settings()&#10;&#10;        # Application-specific initialization&#10;        self.preselected_workpiece = None&#10;        self.workpiece_to_spray_paths_generator = WorkpieceToSprayPathsGenerator(self)&#10;        self.create_workpiece_handler = CreateWorkpieceHandler(self)&#10;        &#10;        # Initialize glue process state machine for operation control&#10;        self.glue_process_state_machine = GlueProcessStateMachine(GlueProcessState.INITIALIZING)&#10;        self.workpiece_matcher = WorkpieceMatcher()&#10;        self.glue_service= GlueSprayService(generatorTurnOffTimeout=10, settings=self.get_glue_settings())&#10;        # TODO: register glue service in service registry when the glue service state management is implemented&#10;        # self.service_registry.register_service(self.glue_service.service_id,&quot;glue-service/state&quot;,ServiceState.UNKNOWN)&#10;        # print(f&quot;Registered Services in Glue App: {service_registry.get_registered_services()}&quot;)&#10;        # Initialize glue dispensing operation with proper settings access&#10;        self.glue_dispensing_operation = GlueDispensingOperation(self.robot_service, self.glue_service,self)&#10;        self.glue_dispensing_operation.set_state_publisher(OperationStatePublisher(self.broker))&#10;        self.broker.publish(SystemTopics.OPERATION_STATE, OperationState.IDLE)&#10;&#10;        self.NESTING = True&#10;        self.CONTOUR_MATCHING = True&#10;        self.current_operation = self.glue_dispensing_operation&#10;&#10;    @property&#10;    def operation(self):&#10;        return self.current_operation&#10;&#10;    @override&#10;    def set_current_operation(self):&#10;        &quot;&quot;&quot;determine the current operation based on mode&quot;&quot;&quot;&#10;        self.current_operation = self.glue_dispensing_operation&#10;    @override&#10;    def _on_operation_start(self, debug=True, **kwargs) -&gt;OperationResult:&#10;        return start(self, self.CONTOUR_MATCHING, self.NESTING, debug)&#10;&#10;    @staticmethod&#10;    def get_metadata() -&gt; ApplicationMetadata:&#10;        return ApplicationMetadata(&#10;            name=&quot;Glue Spraying Application&quot;,&#10;            version=&quot;1.0.0&quot;,&#10;            dependencies=[&quot;_VisionService&quot;,&#10;                          &quot;SettingsService&quot;,&#10;                          &quot;GlueRobotService&quot;,&#10;                          &quot;ApplicationSettingsRegistry&quot;],&#10;        )&#10;&#10;&#10;    def initialize_glue_data_fetcher(self):&#10;        glue_fetcher = GlueDataFetcher()&#10;        glue_fetcher.start()&#10;&#10;    # ========== BaseRobotApplication Abstract Methods Implementation ==========&#10;    &#10;    def get_initial_state(self) -&gt; ApplicationState:&#10;        &quot;&quot;&quot;Return the initial state for this application&quot;&quot;&quot;&#10;        return ApplicationState.INITIALIZING&#10;&#10;    def start_nesting(self, debug=True)-&gt; OperationResult:&#10;        self.current_operation = &quot;Nesting&quot;&#10;        result =  nesting_handler.start_nesting(self, self.get_workpieces())&#10;        return OperationResult(success=result.success,message=result.message)&#10;&#10;    def start_spraying(self,workpieces, debug=True)-&gt; OperationResult:&#10;        self.current_operation = &quot;Spraying&quot;&#10;        return spraying_handler.start_spraying(self, workpieces, debug)&#10;&#10;    def move_to_nesting_capture_position(self, z_offset=0):&#10;        ret = self.robot_service.moveToStartPosition(z_offset=z_offset)&#10;&#10;        if ret != 0:&#10;            return ret&#10;&#10;        target_pose = self.robot_service.robot_config.getHomePositionParsed()&#10;        target_pose[2] += z_offset  # apply z_offset&#10;        self.robot_service._waitForRobotToReachPosition(target_pose, 1, 0.1)&#10;        return ret&#10;&#10;    def move_to_spray_capture_position(self, z_offset=0):&#10;        ret = self.robot_service.move_to_calibration_position(z_offset=z_offset)&#10;&#10;        if ret != 0:&#10;            return ret&#10;&#10;        target_pose = self.robot_service.robot_config.getCalibrationPositionParsed()&#10;        target_pose[2] += z_offset  # apply z_offset&#10;        self.robot_service._waitForRobotToReachPosition(target_pose, 1, 0.1)&#10;        return ret&#10;&#10;    # ========== Tool and Hardware Control ==========&#10;&#10;    def clean_nozzle(self) -&gt; Dict[str, Any]:&#10;        &quot;&quot;&quot;&#10;        Clean the robot nozzle.&#10;        Default implementation - can be overridden by specific applications.&#10;        &quot;&quot;&quot;&#10;        return clean_nozzle(self.robot_service)&#10;&#10;    def clean_tool(self, tool_id: str) -&gt; OperationResult:&#10;        &quot;&quot;&quot;Clean a specific tool (e.g., nozzle cleaning)&quot;&quot;&quot;&#10;        try:&#10;            if tool_id == &quot;nozzle&quot;:&#10;                result = self.clean_nozzle()&#10;                return OperationResult(&#10;                    success=True,&#10;                    message=f&quot;Tool {tool_id} cleaned successfully&quot;,&#10;                    data=result&#10;                )&#10;&#10;            else:&#10;                return OperationResult(&#10;                    success=False,&#10;                    message=f&quot;Tool {tool_id} not supported for cleaning&quot;&#10;                )&#10;&#10;        except Exception as e:&#10;            return OperationResult(&#10;                success=False,&#10;                message=f&quot;Failed to clean tool {tool_id}: {e}&quot;,&#10;                error=str(e)&#10;            )&#10;&#10;    &#10;    def reset(self) -&gt; Dict[str, Any]:&#10;        &quot;&quot;&quot;Reset the robot application to initial state&quot;&quot;&quot;&#10;        try:&#10;            # Stop any ongoing operation&#10;            self.stop()&#10;            &#10;            # Reset to initial state&#10;            self.state_manager.update_state(ApplicationState.IDLE)&#10;            &#10;            # Clear preselected workpiece&#10;            self.preselected_workpiece = None&#10;            &#10;            # Reset modes to default&#10;            self.NESTING = True&#10;            self.CONTOUR_MATCHING = True&#10;            &#10;            return {&#10;                &quot;success&quot;: True,&#10;                &quot;message&quot;: &quot;Application reset to initial state&quot;&#10;            }&#10;        except Exception as e:&#10;            return {&#10;                &quot;success&quot;: False,&#10;                &quot;message&quot;: f&quot;Failed to reset application: {e}&quot;,&#10;                &quot;error&quot;: str(e)&#10;            } # TODO not used!&#10;&#10;    # ========== Calibration Management ==========&#10;&#10;&#10;    def create_workpiece(self) -&gt; CrateWorkpieceResult:&#10;        return  self.create_workpiece_handler.create_workpiece()&#10;&#10;    # ========== Workpiece Handling ==========&#10;    &#10;    def load_workpiece(self, workpiece_id: str) -&gt; Dict[str, Any]:&#10;        &quot;&quot;&quot;Load a workpiece for processing&quot;&quot;&quot;&#10;        try:&#10;            workpiece = self.workpiece_service.get_workpiece_by_id(workpiece_id)&#10;            if workpiece is None:&#10;                return {&#10;                    &quot;success&quot;: False,&#10;                    &quot;message&quot;: f&quot;Workpiece with ID {workpiece_id} not found&quot;&#10;                }&#10;            &#10;            self.preselected_workpiece = workpiece&#10;            return {&#10;                &quot;success&quot;: True,&#10;                &quot;message&quot;: f&quot;Workpiece {workpiece_id} loaded successfully&quot;,&#10;                &quot;data&quot;: {&#10;                    &quot;workpiece_id&quot;: workpiece_id,&#10;                    &quot;workpiece_name&quot;: workpiece.name if hasattr(workpiece, 'name') else 'Unknown'&#10;                }&#10;            }&#10;        except Exception as e:&#10;            return {&#10;                &quot;success&quot;: False,&#10;                &quot;message&quot;: f&quot;Failed to load workpiece: {e}&quot;,&#10;                &quot;error&quot;: str(e)&#10;            }&#10;    &#10;    def process_workpiece(self, workpiece_id: str, **parameters) -&gt; Dict[str, Any]:&#10;        &quot;&quot;&quot;Process a workpiece with the robot application&quot;&quot;&quot;&#10;        try:&#10;            # Load the workpiece&#10;            load_result = self.load_workpiece(workpiece_id)&#10;            if not load_result[&quot;success&quot;]:&#10;                return load_result&#10;            &#10;            # Start the dispensing operation&#10;            start_result = self.start(**parameters)&#10;            &#10;            return {&#10;                &quot;success&quot;: start_result[&quot;success&quot;],&#10;                &quot;message&quot;: f&quot;Workpiece {workpiece_id} processing {'started' if start_result['success'] else 'failed'}&quot;,&#10;                &quot;data&quot;: {&#10;                    &quot;workpiece_id&quot;: workpiece_id,&#10;                    &quot;processing_result&quot;: start_result&#10;                }&#10;            }&#10;        except Exception as e:&#10;            return {&#10;                &quot;success&quot;: False,&#10;                &quot;message&quot;: f&quot;Failed to process workpiece: {e}&quot;,&#10;                &quot;error&quot;: str(e)&#10;            }&#10;    &#10;    def get_workpieces(self):&#10;        &quot;&quot;&quot;Legacy method for backward compatibility&quot;&quot;&quot;&#10;        if self.preselected_workpiece is None:&#10;            workpieces = self.workpiece_service.load_all()&#10;            print(f&quot; Loaded workpieces: {len(workpieces)}&quot;)&#10;        else:&#10;            workpieces = [self.preselected_workpiece]&#10;            print(f&quot; Using preselected workpiece: {self.preselected_workpiece.name}&quot;)&#10;        return workpieces&#10;&#10;    def get_dynamic_offsets_config(self):&#10;        &quot;&quot;&quot;&#10;        Return the dynamic offset configuration including step offsets and direction map.&#10;        &quot;&quot;&quot;&#10;        # Step offsets&#10;        x_step_offset = self.robot_service.robot_config.tcp_x_step_offset&#10;        y_step_offset = self.robot_service.robot_config.tcp_y_step_offset&#10;&#10;        # Optionally: distances (if still used)&#10;        x_distance = getattr(self.robot_service.robot_config, 'tcp_x_step_distance', 50.0)&#10;        y_distance = getattr(self.robot_service.robot_config, 'tcp_y_step_distance', 50.0)&#10;&#10;        # Direction map&#10;        direction_map = self.robot_service.robot_config.offset_direction_map&#10;        # print(f&quot;in get_dynamic_offsets_config: direction_map={direction_map}&quot;)&#10;        return x_distance, x_step_offset, y_distance, y_step_offset, direction_map&#10;&#10;    def get_transducer_offsets(self):&#10;        # NOTE:&#10;        # - The offsets defined here are measured in the robot's 0° TCP (Tool Center Point) orientation.&#10;&#10;        x_offset = self.robot_service.robot_config.tcp_x_offset # to the top left corner of the transducer&#10;        y_offset = self.robot_service.robot_config.tcp_y_offset # to the top left corner of the transducer&#10;&#10;        # print(f&quot;Transducer offsets: x_offset={x_offset}, y_offset={y_offset}&quot;)&#10;        return [x_offset, y_offset]&#10;&#10;    &quot;&quot;&quot; TEMP METHODS FOR TESTING WHILE IN DEVELOPMENT &quot;&quot;&quot;&#10;&#10;    def handleExecuteFromGallery(self, workpiece):&#10;        return execute_from_gallery(self,workpiece,Z_OFFSET_FOR_CALIBRATION_PATTERN)&#10;&#10;    def on_mode_change(self,message):&#10;        print(f&quot;Changing mode to: {message}&quot;)&#10;        if message == &quot;Spray Only&quot;:&#10;            self.NESTING = False&#10;        elif message == &quot;Pick And Spray&quot;:&#10;            self.NESTING = True&#10;        else:&#10;            raise ValueError(f&quot;Unknown mode: {message}&quot;)&#10;&#10;    def run_demo(self):&#10;&#10;        if self.preselected_workpiece is None:&#10;            print(f&quot;No preselected workpiece set for demo&quot;)&#10;            return False, &quot;No preselected workpiece set for demo&quot;&#10;&#10;        workpiece = self.workpiece_service.get_workpiece_by_id(self.preselected_workpiece)&#10;        if workpiece is None:&#10;            print(f&quot;Demo workpiece with ID {self.preselected_workpiece} not found.&quot;)&#10;            return True, f&quot;Demo workpiece with ID {self.preselected_workpiece} not found.&quot;&#10;&#10;        print(&quot;Demo workpiece found: &quot;, workpiece)&#10;        return True, &quot;Demo workpiece found&quot;&#10;&#10;    &quot;&quot;&quot; TEMP METHODS FOR TESTING WHILE IN DEVELOPMENT &quot;&quot;&quot;&#10;&#10;    def handle_set_preselected_workpiece(self, wp_id):&#10;        selected_workpiece = None&#10;        all_workpieces = self.workpiece_service.load_all()&#10;        for wp in all_workpieces:&#10;            if str(wp.workpieceId) == str(wp_id):&#10;                selected_workpiece = wp&#10;                break&#10;&#10;        if selected_workpiece is not None:&#10;            self.preselected_workpiece = selected_workpiece&#10;            print(f&quot;Preselected workpiece set to ID: {wp_id}&quot;)&#10;            print(f&quot;Workpiece: {selected_workpiece}&quot;)&#10;            print(f&quot;Pickup point: {selected_workpiece.pickupPoint}&quot;)&#10;&#10;            return True, f&quot;Preselected workpiece set to ID: {wp_id}&quot;&#10;        else:&#10;            print(f&quot;Workpiece with ID: {wp_id} not found&quot;)&#10;            return False, f&quot;Workpiece with ID: {wp_id} not found&quot;&#10;&#10;    # ========== Application-Specific Information ==========&#10;&#10;    def _register_settings(self):&#10;        &quot;&quot;&quot;Register glue application settings with the global settings registry&quot;&quot;&quot;&#10;        try:&#10;            # Create glue settings instance&#10;            glue_settings = GlueSettings()&#10;            &#10;            # Create glue settings handler  &#10;            glue_handler = GlueSettingsHandler()&#10;            &#10;            # Register both with the global registry&#10;            self.settings_registry.register_settings_type(glue_settings)&#10;            self.settings_registry.register_handler(glue_handler)&#10;            &#10;            self.logger.info(&quot;Glue application settings registered successfully&quot;)&#10;            &#10;        except Exception as e:&#10;            self.logger.error(f&quot;Failed to register glue application settings: {e}&quot;)&#10;&#10;    def get_glue_settings(self):&#10;        &quot;&quot;&quot;Get glue settings object for this application&quot;&quot;&quot;&#10;        try:&#10;            handler = self.settings_registry.get_handler(&quot;glue&quot;)&#10;            return handler.get_settings_object()&#10;        except Exception as e:&#10;            self.logger.error(f&quot;Failed to get glue settings: {e}&quot;)&#10;            # Fallback to default settings&#10;            return GlueSettings()&#10;&#10;    &quot;&quot;&quot;SUPER CLASS METHODS FOR EXTENSIONS OR OVERRIDE IF NEEDED&quot;&quot;&quot;&#10;&#10;    @override&#10;    def start(self, debug=True, **kwargs) -&gt; OperationResult:&#10;        &quot;&quot;&quot;Start the robot application operation&#10;        calling the super class start method which in turn calls _on_operation_start&#10;        keeping this method for clarity and possible future customizations&quot;&quot;&quot;&#10;        return super().start()&#10;        # return start(self, self.CONTOUR_MATCHING, self.NESTING, debug)&#10;&#10;    @override&#10;    def stop(self, emergency: bool = False) -&gt; OperationResult:&#10;        &quot;&quot;&quot;Stop the robot application operation&quot;&quot;&quot;&#10;        # CALLING SUPER CLASS STOP METHOD. KEEPING THIS METHOD FOR CLARITY AND POSSIBLE FUTURE CUSTOMIZATIONS&#10;        print(f&quot;[GlueSprayingApplication] Stopping operation, emergency={emergency}&quot;)&#10;        return super().stop()&#10;&#10;    @override&#10;    def pause(self) -&gt; OperationResult:&#10;        &quot;&quot;&quot;Pause the robot application operation&quot;&quot;&quot;&#10;        # CALLING SUPER CLASS PAUSE METHOD. KEEPING THIS METHOD FOR CLARITY AND POSSIBLE FUTURE CUSTOMIZATIONS&#10;        return super().pause()&#10;&#10;    @override&#10;    def resume(self) -&gt; OperationResult:&#10;        &quot;&quot;&quot;Resume the robot application operation&quot;&quot;&quot;&#10;        # CALLING SUPER CLASS RESUME METHOD. KEEPING THIS METHOD FOR CLARITY AND POSSIBLE FUTURE CUSTOMIZATIONS&#10;        return super().resume()&#10;&#10;    @override&#10;    def calibrate_robot(self) -&gt; Dict[str, Any]:&#10;        &quot;&quot;&quot;Calibrate the robot coordinate system&quot;&quot;&quot;&#10;        # CALLING THE SUPER CALIBRATE ROBOT METHOD AND KEEPING THIS FOR CLARITY AND POSSIBLE CHANGES&#10;        return super().calibrate_robot()&#10;&#10;    @override&#10;    def calibrate_camera(self) -&gt; Dict[str, Any]:&#10;        &quot;&quot;&quot;Calibrate the camera system&quot;&quot;&quot;&#10;        # CALLING THE SUPER CALIBRATE CAMERA METHOD AND KEEPING THIS FOR CLARITY AND POSSIBLE CHANGES&#10;        return super().calibrate_camera()&#10;&#10;    @override&#10;    def home_robot(self):&#10;        &quot;&quot;&quot;Move robot to home position&quot;&quot;&quot;&#10;        return super().home_robot()" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/src/applications/glue_dispensing_application/glue_process/glue_dispensing_operation.py">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/applications/glue_dispensing_application/glue_process/glue_dispensing_operation.py" />
              <option name="originalContent" value="import time&#10;import json&#10;import os&#10;from datetime import datetime&#10;from typing import Optional&#10;&#10;from applications.glue_dispensing_application.glue_process.state_handlers.pause_operation import pause_operation&#10;from applications.glue_dispensing_application.glue_process.state_handlers.resume_operation import resume_operation&#10;from applications.glue_dispensing_application.glue_process.state_handlers.stop_operation import stop_operation&#10;from applications.glue_dispensing_application.glue_process.state_machine.ExecutableStateMachine import \&#10;    ExecutableStateMachine, StateRegistry, State, ExecutableStateMachineBuilder&#10;from applications.glue_dispensing_application.glue_process.state_machine.GlueProcessStateMachine import \&#10;    GlueProcessStateMachine&#10;from applications.glue_dispensing_application.settings.enums.GlueSettingKey import GlueSettingKey&#10;from applications.glue_dispensing_application.glue_process.ExecutionContext import ExecutionContext&#10;from applications.glue_dispensing_application.settings.GlueSettings import GlueSettings&#10;&#10;from applications.glue_dispensing_application.glue_process.state_machine.GlueProcessState import GlueProcessState, \&#10;    GlueProcessTransitionRules&#10;&#10;from backend.system.utils.custom_logging import log_debug_message, log_info_message, log_error_message, \&#10;    log_calls_with_timestamp_decorator, setup_logger, LoggerContext&#10;from applications.glue_dispensing_application.glue_process.PumpController import PumpController&#10;from communication_layer.api.v1.topics import GlueTopics&#10;from core.operation_state_management import OperationResult, IOperation&#10;from core.services.robot_service.impl.base_robot_service import RobotService&#10;from modules.shared.MessageBroker import MessageBroker&#10;&#10;# glue dispensing process configuration&#10;USE_SEGMENT_SETTINGS = True&#10;TURN_OFF_PUMP_BETWEEN_PATHS = True&#10;ADJUST_PUMP_SPEED_WHILE_SPRAY = True&#10;&#10;# logging configuration&#10;ENABLE_GLUE_DISPENSING_LOGGING = True&#10;glue_dispensing_logger = setup_logger(&quot;Glue Dispensing&quot;) if ENABLE_GLUE_DISPENSING_LOGGING else None&#10;glue_dispensing_logger_context = LoggerContext(enabled=ENABLE_GLUE_DISPENSING_LOGGING, logger=glue_dispensing_logger)&#10;&#10;# debug configuration&#10;ENABLE_CONTEXT_DEBUG = True&#10;DEBUG_DIR = os.path.join(os.path.dirname(__file__), &quot;debug&quot;)&#10;&#10;&#10;class GlueDispensingOperation(IOperation):&#10;    def __init__(self, robot_service, glue_service, glue_application=None):&#10;        super().__init__()&#10;        self.robot_service = robot_service&#10;        self.glue_application = glue_application&#10;        self.glue_service = glue_service&#10;        self.broker=MessageBroker()&#10;        # Get glue settings from the glue application&#10;        if glue_application is not None:&#10;            glue_settings = glue_application.get_glue_settings()&#10;        else:&#10;            # Fallback to default settings if no application provided&#10;            glue_settings = GlueSettings()&#10;&#10;        self.glue_service.settings = glue_settings&#10;        self.pump_controller = PumpController(USE_SEGMENT_SETTINGS, glue_dispensing_logger_context, glue_settings)&#10;        self.execution_context = ExecutionContext()&#10;        self.glue_process_state_machine = self.get_state_machine()&#10;&#10;        # Create debug directory if it doesn't exist&#10;        if ENABLE_CONTEXT_DEBUG:&#10;            os.makedirs(DEBUG_DIR, exist_ok=True)&#10;&#10;    def _write_context_debug(self, state_name: str):&#10;        &quot;&quot;&quot;&#10;        Write execution context to debug file after state execution.&#10;&#10;        Args:&#10;            state_name: Name of the state that just completed&#10;        &quot;&quot;&quot;&#10;        if not ENABLE_CONTEXT_DEBUG:&#10;            return&#10;&#10;        try:&#10;            # Create debug directory if it doesn't exist&#10;            os.makedirs(DEBUG_DIR, exist_ok=True)&#10;&#10;            # Generate timestamp&#10;            timestamp = datetime.now().strftime(&quot;%Y%m%d_%H%M%S_%f&quot;)&#10;&#10;            # Get context as dict&#10;            context_dict = self.execution_context.to_debug_dict()&#10;&#10;            # Add metadata&#10;            debug_data = {&#10;                &quot;timestamp&quot;: timestamp,&#10;                &quot;state&quot;: state_name,&#10;                &quot;context&quot;: context_dict&#10;            }&#10;&#10;            # Generate filename&#10;            filename = f&quot;{timestamp}_{state_name}.json&quot;&#10;            filepath = os.path.join(DEBUG_DIR, filename)&#10;&#10;            # Write to file&#10;            with open(filepath, 'w') as f:&#10;                json.dump(debug_data, f, indent=2, default=str)&#10;&#10;            log_debug_message(&#10;                glue_dispensing_logger_context,&#10;                message=f&quot;Debug context written to: {filename}&quot;&#10;            )&#10;&#10;        except Exception as e:&#10;            log_error_message(&#10;                glue_dispensing_logger_context,&#10;                message=f&quot;Failed to write debug context: {e}&quot;&#10;            )&#10;&#10;    def setup_execution_context(self, paths, spray_on):&#10;        self.execution_context.reset()&#10;        self.execution_context.paths = paths&#10;        self.execution_context.spray_on = spray_on&#10;        self.execution_context.service = self.glue_service&#10;        self.execution_context.robot_service = self.robot_service&#10;        # Use the application's glue process state machine instead of robot service state machine&#10;        self.execution_context.state_machine = self.glue_process_state_machine&#10;        self.execution_context.glue_type = self.glue_service.glueA_addresses&#10;        self.execution_context.current_path_index = 0&#10;        self.execution_context.current_point_index = 0&#10;        self.execution_context.is_resuming = False&#10;        self.execution_context.current_settings = None&#10;        self.execution_context.pump_controller = self.pump_controller&#10;&#10;        # ✅ Add these for pump adjustment&#10;        self.execution_context.pump_thread = None&#10;        self.execution_context.pump_ready_event = None&#10;&#10;    @log_calls_with_timestamp_decorator(enabled=ENABLE_GLUE_DISPENSING_LOGGING, logger=glue_dispensing_logger)&#10;    def _do_start(self, paths, spray_on=False, resume=False) -&gt; OperationResult:&#10;        try:&#10;            if resume is False or not self.execution_context.has_valid_context():&#10;                self.setup_execution_context(paths, spray_on)&#10;                # Transition to start&#10;                if self.execution_context.state_machine.state == GlueProcessState.IDLE:&#10;                    self.execution_context.state_machine.transition(GlueProcessState.STARTING)&#10;&#10;            # Start execution loop (non-blocking if needed, blocking here)&#10;            self.execution_context.state_machine.start_execution(delay=0.2)&#10;&#10;            return OperationResult(True, &quot;Execution completed&quot;)&#10;&#10;        except Exception as e:&#10;            log_error_message(glue_dispensing_logger_context, message=f&quot;Error during execution: {e}&quot;)&#10;            self.execution_context.state_machine.transition(GlueProcessState.ERROR)&#10;            return OperationResult(False, &quot;Execution error&quot;, error=str(e))&#10;&#10;    # @log_calls_with_timestamp_decorator(enabled=ENABLE_GLUE_DISPENSING_LOGGING, logger=glue_dispensing_logger)&#10;    # def _do_start(self, paths, spray_on=False, resume=False)-&gt;OperationResult:&#10;    #     &quot;&quot;&quot;Main path execution method with proper state management&quot;&quot;&quot;&#10;    #     message = f&quot;Resuming from execution context: {self.execution_context}&quot; if resume and self.execution_context.has_valid_context() else f&quot;Starting new execution with {len(paths)} paths, spray_on={spray_on}&quot;&#10;    #     log_debug_message(glue_dispensing_logger_context, message=message)&#10;    #&#10;    #     if resume is False or not self.execution_context.has_valid_context():&#10;    #         self.setup_execution_context(paths, spray_on)&#10;    #&#10;    #         # ✅ Ensure proper state transition before execution&#10;    #         if self.execution_context.state_machine.state == GlueProcessState.IDLE:&#10;    #             self.execution_context.state_machine.transition(GlueProcessState.STARTING)&#10;    #             log_debug_message(glue_dispensing_logger_context,&#10;    #                               message=&quot;Transitioned from IDLE to STARTING to begin execution&quot;)&#10;    #&#10;    #     try:&#10;    #         # Main execution loop&#10;    #         while self.execution_context.state_machine.state not in [GlueProcessState.COMPLETED,&#10;    #                                                                  GlueProcessState.ERROR]:&#10;    #             current_state = self.execution_context.state_machine.state&#10;    #             log_debug_message(glue_dispensing_logger_context,&#10;    #                               message=f&quot;Execution loop - Current State: {current_state}&quot;)&#10;    #&#10;    #             if current_state == GlueProcessState.PAUSED:&#10;    #                 self.execution_context.robot_service.robot_state_manager.trajectoryUpdate = False&#10;    #                 log_debug_message(glue_dispensing_logger_context,&#10;    #                                   message=f&quot;In PAUSED state - trajectoryUpdate set to {self.execution_context.robot_service.robot_state_manager.trajectoryUpdate}&quot;)&#10;    #&#10;    #                 time.sleep(0.5)&#10;    #                 continue&#10;    #&#10;    #             elif current_state == GlueProcessState.STOPPED:&#10;    #                 self.execution_context.robot_service.robot_state_manager.trajectoryUpdate = False&#10;    #                 log_debug_message(glue_dispensing_logger_context, message=&quot;Execution stopped, completing...&quot;)&#10;    #                 self.execution_context.state_machine.transition(GlueProcessState.COMPLETED)&#10;    #                 break&#10;    #&#10;    #             elif current_state == GlueProcessState.INITIALIZING:&#10;    #                 # Transition from INITIALIZING to IDLE, then to STARTING&#10;    #                 log_debug_message(glue_dispensing_logger_context,&#10;    #                                   message=&quot;Transitioning from INITIALIZING to IDLE&quot;)&#10;    #                 self.execution_context.state_machine.transition(GlueProcessState.IDLE)&#10;    #                 continue&#10;    #&#10;    #             elif current_state == GlueProcessState.IDLE:&#10;    #                 # Transition from IDLE to STARTING to begin execution&#10;    #                 log_debug_message(glue_dispensing_logger_context,&#10;    #                                   message=&quot;Transitioning from IDLE to STARTING to begin execution&quot;)&#10;    #                 self.execution_context.state_machine.transition(GlueProcessState.STARTING)&#10;    #                 continue&#10;    #&#10;    #             elif current_state == GlueProcessState.STARTING:&#10;    #&#10;    #                 ctx = self.execution_context&#10;    #                 next_state = self._handle_starting_state(self.execution_context)&#10;    #                 ctx.state_machine.transition(next_state)&#10;    #                 self._write_context_debug(&quot;STARTING&quot;)&#10;    #&#10;    #&#10;    #             elif current_state == GlueProcessState.MOVING_TO_FIRST_POINT:&#10;    #                 next_state = self._handle_moving_to_first_point_state(self.execution_context, resume)&#10;    #                 ctx = self.execution_context&#10;    #                 ctx.state_machine.transition(next_state)&#10;    #                 # Write debug context&#10;    #                 self._write_context_debug(&quot;MOVING_TO_FIRST_POINT&quot;)&#10;    #&#10;    #             elif current_state == GlueProcessState.EXECUTING_PATH:&#10;    #                 self.execution_context.state_machine.transition(GlueProcessState.PUMP_INITIAL_BOOST)&#10;    #                 # Write debug context&#10;    #                 self._write_context_debug(&quot;EXECUTING_PATH&quot;)&#10;    #&#10;    #             elif current_state == GlueProcessState.PUMP_INITIAL_BOOST:&#10;    #                 next_state = self._handle_pump_initial_boost(self.execution_context)&#10;    #                 ctx = self.execution_context&#10;    #                 ctx.state_machine.transition(next_state)&#10;    #                 # Write debug context&#10;    #                 self._write_context_debug(&quot;PUMP_INITIAL_BOOST&quot;)&#10;    #&#10;    #             elif current_state == GlueProcessState.STARTING_PUMP_ADJUSTMENT_THREAD:&#10;    #                 next_state = self._handle_start_pump_adjustment_thread(self.execution_context)&#10;    #                 ctx = self.execution_context&#10;    #                 ctx.state_machine.transition(next_state)&#10;    #                 # Write debug context&#10;    #                 self._write_context_debug(&quot;STARTING_PUMP_ADJUSTMENT_THREAD&quot;)&#10;    #&#10;    #             elif current_state == GlueProcessState.SENDING_PATH_POINTS:&#10;    #                 next_state = self._handle_send_path_to_robot_state(self.execution_context)&#10;    #                 ctx = self.execution_context&#10;    #                 ctx.state_machine.transition(next_state)&#10;    #                 self._write_context_debug(&quot;SENDING_PATH_POINTS&quot;)&#10;    #&#10;    #             elif current_state == GlueProcessState.WAIT_FOR_PATH_COMPLETION:&#10;    #                 next_state = self._handle_wait_for_path_completion(self.execution_context)&#10;    #                 ctx = self.execution_context&#10;    #                 ctx.state_machine.transition(next_state)&#10;    #                 self._write_context_debug(&quot;WAIT_FOR_PATH_COMPLETION&quot;)&#10;    #&#10;    #             elif current_state == GlueProcessState.TRANSITION_BETWEEN_PATHS:&#10;    #                 next_state = self._handle_transition_between_paths(self.execution_context)&#10;    #                 ctx = self.execution_context&#10;    #                 ctx.state_machine.transition(next_state)&#10;    #                 self._write_context_debug(&quot;TRANSITION_BETWEEN_PATHS&quot;)&#10;    #&#10;    #             else:&#10;    #                 log_debug_message(glue_dispensing_logger_context,&#10;    #                                   message=f&quot;Unexpected state in execution loop: {current_state}&quot;)&#10;    #                 break&#10;    #&#10;    #         self.execution_context.pump_controller.pump_off(self.execution_context.service,&#10;    #                                                         self.execution_context.robot_service,&#10;    #                                                         self.execution_context.glue_type,&#10;    #                                                         self.execution_context.current_settings)&#10;    #&#10;    #         # Guard: current_settings may be None if no valid path/settings were established&#10;    #         if self.execution_context.current_settings and isinstance(self.execution_context.current_settings, dict):&#10;    #             timeout_before_generator_off = float(&#10;    #                 self.execution_context.current_settings.get(GlueSettingKey.TIME_BETWEEN_GENERATOR_AND_GLUE.value,&#10;    #                                                             1))&#10;    #         else:&#10;    #             # Fallback safe default&#10;    #             timeout_before_generator_off = 1.0&#10;    #&#10;    #         log_info_message(glue_dispensing_logger_context,&#10;    #                          message=f&quot;Waiting {timeout_before_generator_off}s before turning generator off&quot;)&#10;    #         time.sleep(timeout_before_generator_off)&#10;    #&#10;    #         self.execution_context.service.generatorOff()&#10;    #         log_info_message(glue_dispensing_logger_context,&#10;    #                          message=f&quot;Generator turned off after waiting {timeout_before_generator_off}s&quot;)&#10;    #         self.execution_context.state_machine.transition(GlueProcessState.IDLE)&#10;    #         self.execution_context.robot_service.robot_state_manager.trajectoryUpdate = False&#10;    #         self.execution_context.robot_service.message_publisher.publish_trajectory_stop_topic()&#10;    #         return OperationResult(False, &quot;Execution did not complete&quot;)&#10;    #&#10;    #     except Exception as e:&#10;    #         log_error_message(glue_dispensing_logger_context, message=f&quot;Error during traceContours execution: {e}&quot;)&#10;    #&#10;    #         import traceback&#10;    #         traceback.print_exc()&#10;    #         self.execution_context.state_machine.transition(GlueProcessState.ERROR)&#10;    #         return OperationResult(False, &quot;Execution error occurred&quot;,error=str(e))&#10;&#10;    def _do_pause(self)-&gt;OperationResult:&#10;        return pause_operation(self, self.execution_context,glue_dispensing_logger_context)&#10;&#10;    def _do_stop(self)-&gt;OperationResult:&#10;        return stop_operation(self, self.execution_context,glue_dispensing_logger_context)&#10;&#10;    def _do_resume(self)-&gt;OperationResult:&#10;        &quot;&quot;&quot;Resume operation from paused state&quot;&quot;&quot;&#10;        return resume_operation(self.execution_context,glue_dispensing_logger_context)&#10;&#10;    def _resume_execution(self):&#10;        &quot;&quot;&quot;Resume execution from saved context&quot;&quot;&quot;&#10;&#10;        try:&#10;            paths = self.execution_context.paths&#10;            spray_on = self.execution_context.spray_on&#10;            self.start(paths, spray_on, resume=True)&#10;        except Exception as e:&#10;            log_debug_message(glue_dispensing_logger_context, message=f&quot;Error during resume execution: {e}&quot;)&#10;            self.execution_context.state_machine.transition(GlueProcessState.ERROR)&#10;&#10;    def _handle_starting_state(self, context):&#10;        from applications.glue_dispensing_application.glue_process.state_handlers.start_state_handler import \&#10;            handle_starting_state&#10;        # Return whatever the handler returns so the caller can update its local execution context variables&#10;        return handle_starting_state(context)&#10;&#10;    def _handle_moving_to_first_point_state(self, context, resume):&#10;        from applications.glue_dispensing_application.glue_process.state_handlers.moving_to_first_point_state_handler import \&#10;            handle_moving_to_first_point_state&#10;        return handle_moving_to_first_point_state(context, resume)&#10;&#10;    def _handle_transition_between_paths(self, context):&#10;        from applications.glue_dispensing_application.glue_process.state_handlers.transition_between_paths_state_handler import \&#10;            handle_transition_between_paths&#10;        return handle_transition_between_paths(context)&#10;&#10;    def _handle_pump_initial_boost(self, context):&#10;        from applications.glue_dispensing_application.glue_process.state_handlers.initial_pump_boost_state_handler import \&#10;            handle_pump_initial_boost&#10;        return handle_pump_initial_boost(context)&#10;&#10;    def _handle_start_pump_adjustment_thread(self, execution_context):&#10;        from applications.glue_dispensing_application.glue_process.state_handlers.start_pump_adjustment_thread_handler import \&#10;            handle_start_pump_adjustment_thread&#10;        return handle_start_pump_adjustment_thread(execution_context)&#10;&#10;    def _handle_send_path_to_robot_state(self, execution_context):&#10;        from applications.glue_dispensing_application.glue_process.state_handlers.sending_path_to_robot_state_handler import \&#10;            handle_send_path_to_robot&#10;        return handle_send_path_to_robot(execution_context)&#10;&#10;    def _handle_wait_for_path_completion(self, execution_context):&#10;        from applications.glue_dispensing_application.glue_process.state_handlers.wait_for_path_completion_state_handler import \&#10;            handle_wait_for_path_completion&#10;        return handle_wait_for_path_completion(execution_context)&#10;&#10;    def get_state_machine(self)-&gt;ExecutableStateMachine:&#10;        transition_rules = GlueProcessTransitionRules.get_glue_transition_rules()&#10;        # Register all states and link to their respective handler functions&#10;        state_handlers_map = {&#10;            GlueProcessState.IDLE: lambda ctx: None,  # IDLE state does nothing&#10;            GlueProcessState.STARTING: self._handle_starting_state,&#10;            GlueProcessState.MOVING_TO_FIRST_POINT: lambda ctx: self._handle_moving_to_first_point_state(ctx,&#10;                                                                                                         resume=False),&#10;            GlueProcessState.EXECUTING_PATH: lambda ctx: GlueProcessState.PUMP_INITIAL_BOOST,&#10;            GlueProcessState.PUMP_INITIAL_BOOST: self._handle_pump_initial_boost,&#10;            GlueProcessState.STARTING_PUMP_ADJUSTMENT_THREAD: self._handle_start_pump_adjustment_thread,&#10;            GlueProcessState.SENDING_PATH_POINTS: self._handle_send_path_to_robot_state,&#10;            GlueProcessState.WAIT_FOR_PATH_COMPLETION: self._handle_wait_for_path_completion,&#10;            GlueProcessState.TRANSITION_BETWEEN_PATHS: self._handle_transition_between_paths,&#10;            GlueProcessState.PAUSED: lambda ctx: GlueProcessState.PAUSED,&#10;            GlueProcessState.STOPPED: lambda ctx: GlueProcessState.COMPLETED,&#10;            GlueProcessState.ERROR: lambda ctx: GlueProcessState.ERROR,&#10;            GlueProcessState.COMPLETED: lambda ctx: GlueProcessState.COMPLETED,&#10;            GlueProcessState.INITIALIZING: lambda ctx: GlueProcessState.IDLE,&#10;        }&#10;        registry = StateRegistry()&#10;        # Create and register State objects&#10;        for state_enum, handler in state_handlers_map.items():&#10;            registry.register_state(State(&#10;                state=state_enum,&#10;                handler=handler,&#10;                on_enter=lambda ctx, s=state_enum: self._write_context_debug(f&quot;{s.name}_ENTER&quot;),&#10;                on_exit=lambda ctx, s=state_enum: self._write_context_debug(f&quot;{s.name}_EXIT&quot;)&#10;            ))&#10;&#10;&#10;&#10;        # Build the executable state machine&#10;        transition_rules = GlueProcessTransitionRules.get_glue_transition_rules()&#10;        state_machine = (&#10;            ExecutableStateMachineBuilder()&#10;        .with_initial_state(GlueProcessState.INITIALIZING)&#10;        .with_transition_rules(transition_rules)&#10;        .with_state_registry(registry)&#10;        .with_context(self.execution_context)&#10;        .with_state_topic(GlueTopics.PROCESS_STATE)&#10;        .build()&#10;        )&#10;&#10;        return state_machine&#10;        # return ExecutableStateMachine(&#10;        #     initial_state=GlueProcessState.INITIALIZING,&#10;        #     transition_rules=transition_rules,&#10;        #     state_registry=registry,&#10;        #     context=self.execution_context,&#10;        # )&#10;" />
              <option name="updatedContent" value="import time&#10;import json&#10;import os&#10;from datetime import datetime&#10;from typing import Optional&#10;&#10;from applications.glue_dispensing_application.glue_process.state_handlers.pause_operation import pause_operation&#10;from applications.glue_dispensing_application.glue_process.state_handlers.resume_operation import resume_operation&#10;from applications.glue_dispensing_application.glue_process.state_handlers.stop_operation import stop_operation&#10;from applications.glue_dispensing_application.glue_process.state_machine.ExecutableStateMachine import \&#10;    ExecutableStateMachine, StateRegistry, State, ExecutableStateMachineBuilder&#10;from applications.glue_dispensing_application.glue_process.state_machine.GlueProcessStateMachine import \&#10;    GlueProcessStateMachine&#10;from applications.glue_dispensing_application.settings.enums.GlueSettingKey import GlueSettingKey&#10;from applications.glue_dispensing_application.glue_process.ExecutionContext import ExecutionContext&#10;from applications.glue_dispensing_application.settings.GlueSettings import GlueSettings&#10;&#10;from applications.glue_dispensing_application.glue_process.state_machine.GlueProcessState import GlueProcessState, \&#10;    GlueProcessTransitionRules&#10;&#10;from backend.system.utils.custom_logging import log_debug_message, log_info_message, log_error_message, \&#10;    log_calls_with_timestamp_decorator, setup_logger, LoggerContext&#10;from applications.glue_dispensing_application.glue_process.PumpController import PumpController&#10;from communication_layer.api.v1.topics import GlueTopics&#10;from core.operation_state_management import OperationResult, IOperation&#10;from core.services.robot_service.impl.base_robot_service import RobotService&#10;from modules.shared.MessageBroker import MessageBroker&#10;&#10;# glue dispensing process configuration&#10;USE_SEGMENT_SETTINGS = True&#10;TURN_OFF_PUMP_BETWEEN_PATHS = True&#10;ADJUST_PUMP_SPEED_WHILE_SPRAY = True&#10;&#10;# logging configuration&#10;ENABLE_GLUE_DISPENSING_LOGGING = True&#10;glue_dispensing_logger = setup_logger(&quot;Glue Dispensing&quot;) if ENABLE_GLUE_DISPENSING_LOGGING else None&#10;glue_dispensing_logger_context = LoggerContext(enabled=ENABLE_GLUE_DISPENSING_LOGGING, logger=glue_dispensing_logger)&#10;&#10;# debug configuration&#10;ENABLE_CONTEXT_DEBUG = True&#10;DEBUG_DIR = os.path.join(os.path.dirname(__file__), &quot;debug&quot;)&#10;&#10;&#10;class GlueDispensingOperation(IOperation):&#10;    def __init__(self, robot_service, glue_service, glue_application=None):&#10;        super().__init__()&#10;        self.robot_service = robot_service&#10;        self.glue_application = glue_application&#10;        self.glue_service = glue_service&#10;        self.broker=MessageBroker()&#10;        # Get glue settings from the glue application&#10;        if glue_application is not None:&#10;            glue_settings = glue_application.get_glue_settings()&#10;        else:&#10;            # Fallback to default settings if no application provided&#10;            glue_settings = GlueSettings()&#10;&#10;        self.glue_service.settings = glue_settings&#10;        self.pump_controller = PumpController(USE_SEGMENT_SETTINGS, glue_dispensing_logger_context, glue_settings)&#10;        self.execution_context = ExecutionContext()&#10;        self.glue_process_state_machine = self.get_state_machine()&#10;&#10;        # Create debug directory if it doesn't exist&#10;        if ENABLE_CONTEXT_DEBUG:&#10;            os.makedirs(DEBUG_DIR, exist_ok=True)&#10;&#10;    def _write_context_debug(self, state_name: str):&#10;        &quot;&quot;&quot;&#10;        Write execution context to debug file after state execution.&#10;&#10;        Args:&#10;            state_name: Name of the state that just completed&#10;        &quot;&quot;&quot;&#10;        if not ENABLE_CONTEXT_DEBUG:&#10;            return&#10;&#10;        try:&#10;            # Create debug directory if it doesn't exist&#10;            os.makedirs(DEBUG_DIR, exist_ok=True)&#10;&#10;            # Generate timestamp&#10;            timestamp = datetime.now().strftime(&quot;%Y%m%d_%H%M%S_%f&quot;)&#10;&#10;            # Get context as dict&#10;            context_dict = self.execution_context.to_debug_dict()&#10;&#10;            # Add metadata&#10;            debug_data = {&#10;                &quot;timestamp&quot;: timestamp,&#10;                &quot;state&quot;: state_name,&#10;                &quot;context&quot;: context_dict&#10;            }&#10;&#10;            # Generate filename&#10;            filename = f&quot;{timestamp}_{state_name}.json&quot;&#10;            filepath = os.path.join(DEBUG_DIR, filename)&#10;&#10;            # Write to file&#10;            with open(filepath, 'w') as f:&#10;                json.dump(debug_data, f, indent=2, default=str)&#10;&#10;            log_debug_message(&#10;                glue_dispensing_logger_context,&#10;                message=f&quot;Debug context written to: {filename}&quot;&#10;            )&#10;&#10;        except Exception as e:&#10;            log_error_message(&#10;                glue_dispensing_logger_context,&#10;                message=f&quot;Failed to write debug context: {e}&quot;&#10;            )&#10;&#10;    def setup_execution_context(self, paths, spray_on):&#10;        self.execution_context.reset()&#10;        self.execution_context.paths = paths&#10;        self.execution_context.spray_on = spray_on&#10;        self.execution_context.service = self.glue_service&#10;        self.execution_context.robot_service = self.robot_service&#10;        # Use the application's glue process state machine instead of robot service state machine&#10;        self.execution_context.state_machine = self.glue_process_state_machine&#10;        self.execution_context.glue_type = self.glue_service.glueA_addresses&#10;        self.execution_context.current_path_index = 0&#10;        self.execution_context.current_point_index = 0&#10;        self.execution_context.is_resuming = False&#10;        self.execution_context.current_settings = None&#10;        self.execution_context.pump_controller = self.pump_controller&#10;&#10;        # ✅ Add these for pump adjustment&#10;        self.execution_context.pump_thread = None&#10;        self.execution_context.pump_ready_event = None&#10;&#10;    @log_calls_with_timestamp_decorator(enabled=ENABLE_GLUE_DISPENSING_LOGGING, logger=glue_dispensing_logger)&#10;    def _do_start(self, paths, spray_on=False, resume=False) -&gt; OperationResult:&#10;        try:&#10;            if resume is False or not self.execution_context.has_valid_context():&#10;                self.setup_execution_context(paths, spray_on)&#10;                # Transition to start&#10;                if self.execution_context.state_machine.state == GlueProcessState.IDLE:&#10;                    self.execution_context.state_machine.transition(GlueProcessState.STARTING)&#10;&#10;            # Start execution loop (non-blocking if needed, blocking here)&#10;            self.execution_context.state_machine.start_execution(delay=0.2)&#10;&#10;            return OperationResult(True, &quot;Execution completed&quot;)&#10;&#10;        except Exception as e:&#10;            log_error_message(glue_dispensing_logger_context, message=f&quot;Error during execution: {e}&quot;)&#10;            self.execution_context.state_machine.transition(GlueProcessState.ERROR)&#10;            return OperationResult(False, &quot;Execution error&quot;, error=str(e))&#10;&#10;    # @log_calls_with_timestamp_decorator(enabled=ENABLE_GLUE_DISPENSING_LOGGING, logger=glue_dispensing_logger)&#10;    # def _do_start(self, paths, spray_on=False, resume=False)-&gt;OperationResult:&#10;    #     &quot;&quot;&quot;Main path execution method with proper state management&quot;&quot;&quot;&#10;    #     message = f&quot;Resuming from execution context: {self.execution_context}&quot; if resume and self.execution_context.has_valid_context() else f&quot;Starting new execution with {len(paths)} paths, spray_on={spray_on}&quot;&#10;    #     log_debug_message(glue_dispensing_logger_context, message=message)&#10;    #&#10;    #     if resume is False or not self.execution_context.has_valid_context():&#10;    #         self.setup_execution_context(paths, spray_on)&#10;    #&#10;    #         # ✅ Ensure proper state transition before execution&#10;    #         if self.execution_context.state_machine.state == GlueProcessState.IDLE:&#10;    #             self.execution_context.state_machine.transition(GlueProcessState.STARTING)&#10;    #             log_debug_message(glue_dispensing_logger_context,&#10;    #                               message=&quot;Transitioned from IDLE to STARTING to begin execution&quot;)&#10;    #&#10;    #     try:&#10;    #         # Main execution loop&#10;    #         while self.execution_context.state_machine.state not in [GlueProcessState.COMPLETED,&#10;    #                                                                  GlueProcessState.ERROR]:&#10;    #             current_state = self.execution_context.state_machine.state&#10;    #             log_debug_message(glue_dispensing_logger_context,&#10;    #                               message=f&quot;Execution loop - Current State: {current_state}&quot;)&#10;    #&#10;    #             if current_state == GlueProcessState.PAUSED:&#10;    #                 self.execution_context.robot_service.robot_state_manager.trajectoryUpdate = False&#10;    #                 log_debug_message(glue_dispensing_logger_context,&#10;    #                                   message=f&quot;In PAUSED state - trajectoryUpdate set to {self.execution_context.robot_service.robot_state_manager.trajectoryUpdate}&quot;)&#10;    #&#10;    #                 time.sleep(0.5)&#10;    #                 continue&#10;    #&#10;    #             elif current_state == GlueProcessState.STOPPED:&#10;    #                 self.execution_context.robot_service.robot_state_manager.trajectoryUpdate = False&#10;    #                 log_debug_message(glue_dispensing_logger_context, message=&quot;Execution stopped, completing...&quot;)&#10;    #                 self.execution_context.state_machine.transition(GlueProcessState.COMPLETED)&#10;    #                 break&#10;    #&#10;    #             elif current_state == GlueProcessState.INITIALIZING:&#10;    #                 # Transition from INITIALIZING to IDLE, then to STARTING&#10;    #                 log_debug_message(glue_dispensing_logger_context,&#10;    #                                   message=&quot;Transitioning from INITIALIZING to IDLE&quot;)&#10;    #                 self.execution_context.state_machine.transition(GlueProcessState.IDLE)&#10;    #                 continue&#10;    #&#10;    #             elif current_state == GlueProcessState.IDLE:&#10;    #                 # Transition from IDLE to STARTING to begin execution&#10;    #                 log_debug_message(glue_dispensing_logger_context,&#10;    #                                   message=&quot;Transitioning from IDLE to STARTING to begin execution&quot;)&#10;    #                 self.execution_context.state_machine.transition(GlueProcessState.STARTING)&#10;    #                 continue&#10;    #&#10;    #             elif current_state == GlueProcessState.STARTING:&#10;    #&#10;    #                 ctx = self.execution_context&#10;    #                 next_state = self._handle_starting_state(self.execution_context)&#10;    #                 ctx.state_machine.transition(next_state)&#10;    #                 self._write_context_debug(&quot;STARTING&quot;)&#10;    #&#10;    #&#10;    #             elif current_state == GlueProcessState.MOVING_TO_FIRST_POINT:&#10;    #                 next_state = self._handle_moving_to_first_point_state(self.execution_context, resume)&#10;    #                 ctx = self.execution_context&#10;    #                 ctx.state_machine.transition(next_state)&#10;    #                 # Write debug context&#10;    #                 self._write_context_debug(&quot;MOVING_TO_FIRST_POINT&quot;)&#10;    #&#10;    #             elif current_state == GlueProcessState.EXECUTING_PATH:&#10;    #                 self.execution_context.state_machine.transition(GlueProcessState.PUMP_INITIAL_BOOST)&#10;    #                 # Write debug context&#10;    #                 self._write_context_debug(&quot;EXECUTING_PATH&quot;)&#10;    #&#10;    #             elif current_state == GlueProcessState.PUMP_INITIAL_BOOST:&#10;    #                 next_state = self._handle_pump_initial_boost(self.execution_context)&#10;    #                 ctx = self.execution_context&#10;    #                 ctx.state_machine.transition(next_state)&#10;    #                 # Write debug context&#10;    #                 self._write_context_debug(&quot;PUMP_INITIAL_BOOST&quot;)&#10;    #&#10;    #             elif current_state == GlueProcessState.STARTING_PUMP_ADJUSTMENT_THREAD:&#10;    #                 next_state = self._handle_start_pump_adjustment_thread(self.execution_context)&#10;    #                 ctx = self.execution_context&#10;    #                 ctx.state_machine.transition(next_state)&#10;    #                 # Write debug context&#10;    #                 self._write_context_debug(&quot;STARTING_PUMP_ADJUSTMENT_THREAD&quot;)&#10;    #&#10;    #             elif current_state == GlueProcessState.SENDING_PATH_POINTS:&#10;    #                 next_state = self._handle_send_path_to_robot_state(self.execution_context)&#10;    #                 ctx = self.execution_context&#10;    #                 ctx.state_machine.transition(next_state)&#10;    #                 self._write_context_debug(&quot;SENDING_PATH_POINTS&quot;)&#10;    #&#10;    #             elif current_state == GlueProcessState.WAIT_FOR_PATH_COMPLETION:&#10;    #                 next_state = self._handle_wait_for_path_completion(self.execution_context)&#10;    #                 ctx = self.execution_context&#10;    #                 ctx.state_machine.transition(next_state)&#10;    #                 self._write_context_debug(&quot;WAIT_FOR_PATH_COMPLETION&quot;)&#10;    #&#10;    #             elif current_state == GlueProcessState.TRANSITION_BETWEEN_PATHS:&#10;    #                 next_state = self._handle_transition_between_paths(self.execution_context)&#10;    #                 ctx = self.execution_context&#10;    #                 ctx.state_machine.transition(next_state)&#10;    #                 self._write_context_debug(&quot;TRANSITION_BETWEEN_PATHS&quot;)&#10;    #&#10;    #             else:&#10;    #                 log_debug_message(glue_dispensing_logger_context,&#10;    #                                   message=f&quot;Unexpected state in execution loop: {current_state}&quot;)&#10;    #                 break&#10;    #&#10;    #         self.execution_context.pump_controller.pump_off(self.execution_context.service,&#10;    #                                                         self.execution_context.robot_service,&#10;    #                                                         self.execution_context.glue_type,&#10;    #                                                         self.execution_context.current_settings)&#10;    #&#10;    #         # Guard: current_settings may be None if no valid path/settings were established&#10;    #         if self.execution_context.current_settings and isinstance(self.execution_context.current_settings, dict):&#10;    #             timeout_before_generator_off = float(&#10;    #                 self.execution_context.current_settings.get(GlueSettingKey.TIME_BETWEEN_GENERATOR_AND_GLUE.value,&#10;    #                                                             1))&#10;    #         else:&#10;    #             # Fallback safe default&#10;    #             timeout_before_generator_off = 1.0&#10;    #&#10;    #         log_info_message(glue_dispensing_logger_context,&#10;    #                          message=f&quot;Waiting {timeout_before_generator_off}s before turning generator off&quot;)&#10;    #         time.sleep(timeout_before_generator_off)&#10;    #&#10;    #         self.execution_context.service.generatorOff()&#10;    #         log_info_message(glue_dispensing_logger_context,&#10;    #                          message=f&quot;Generator turned off after waiting {timeout_before_generator_off}s&quot;)&#10;    #         self.execution_context.state_machine.transition(GlueProcessState.IDLE)&#10;    #         self.execution_context.robot_service.robot_state_manager.trajectoryUpdate = False&#10;    #         self.execution_context.robot_service.message_publisher.publish_trajectory_stop_topic()&#10;    #         return OperationResult(False, &quot;Execution did not complete&quot;)&#10;    #&#10;    #     except Exception as e:&#10;    #         log_error_message(glue_dispensing_logger_context, message=f&quot;Error during traceContours execution: {e}&quot;)&#10;    #&#10;    #         import traceback&#10;    #         traceback.print_exc()&#10;    #         self.execution_context.state_machine.transition(GlueProcessState.ERROR)&#10;    #         return OperationResult(False, &quot;Execution error occurred&quot;,error=str(e))&#10;&#10;    def _do_pause(self)-&gt;OperationResult:&#10;        return pause_operation(self, self.execution_context,glue_dispensing_logger_context)&#10;&#10;    def _do_stop(self)-&gt;OperationResult:&#10;        return stop_operation(self, self.execution_context,glue_dispensing_logger_context)&#10;&#10;    def _do_resume(self)-&gt;OperationResult:&#10;        &quot;&quot;&quot;Resume operation from paused state&quot;&quot;&quot;&#10;        return resume_operation(self.execution_context,glue_dispensing_logger_context)&#10;&#10;    def _resume_execution(self):&#10;        &quot;&quot;&quot;Resume execution from saved context&quot;&quot;&quot;&#10;&#10;        try:&#10;            paths = self.execution_context.paths&#10;            spray_on = self.execution_context.spray_on&#10;            self.start(paths, spray_on, resume=True)&#10;        except Exception as e:&#10;            log_debug_message(glue_dispensing_logger_context, message=f&quot;Error during resume execution: {e}&quot;)&#10;            self.execution_context.state_machine.transition(GlueProcessState.ERROR)&#10;&#10;    def _handle_starting_state(self, context):&#10;        from applications.glue_dispensing_application.glue_process.state_handlers.start_state_handler import \&#10;            handle_starting_state&#10;        # Return whatever the handler returns so the caller can update its local execution context variables&#10;        return handle_starting_state(context)&#10;&#10;    def _handle_moving_to_first_point_state(self, context, resume):&#10;        from applications.glue_dispensing_application.glue_process.state_handlers.moving_to_first_point_state_handler import \&#10;            handle_moving_to_first_point_state&#10;        return handle_moving_to_first_point_state(context, resume)&#10;&#10;    def _handle_transition_between_paths(self, context):&#10;        from applications.glue_dispensing_application.glue_process.state_handlers.transition_between_paths_state_handler import \&#10;            handle_transition_between_paths&#10;        return handle_transition_between_paths(context)&#10;&#10;    def _handle_pump_initial_boost(self, context):&#10;        from applications.glue_dispensing_application.glue_process.state_handlers.initial_pump_boost_state_handler import \&#10;            handle_pump_initial_boost&#10;        return handle_pump_initial_boost(context)&#10;&#10;    def _handle_start_pump_adjustment_thread(self, execution_context):&#10;        from applications.glue_dispensing_application.glue_process.state_handlers.start_pump_adjustment_thread_handler import \&#10;            handle_start_pump_adjustment_thread&#10;        return handle_start_pump_adjustment_thread(execution_context)&#10;&#10;    def _handle_send_path_to_robot_state(self, execution_context):&#10;        from applications.glue_dispensing_application.glue_process.state_handlers.sending_path_to_robot_state_handler import \&#10;            handle_send_path_to_robot&#10;        return handle_send_path_to_robot(execution_context)&#10;&#10;    def _handle_wait_for_path_completion(self, execution_context):&#10;        from applications.glue_dispensing_application.glue_process.state_handlers.wait_for_path_completion_state_handler import \&#10;            handle_wait_for_path_completion&#10;        return handle_wait_for_path_completion(execution_context)&#10;&#10;    def get_state_machine(self)-&gt;ExecutableStateMachine:&#10;        transition_rules = GlueProcessTransitionRules.get_glue_transition_rules()&#10;        # Register all states and link to their respective handler functions&#10;        state_handlers_map = {&#10;            GlueProcessState.IDLE: lambda ctx: None,  # IDLE state does nothing&#10;            GlueProcessState.STARTING: self._handle_starting_state,&#10;            GlueProcessState.MOVING_TO_FIRST_POINT: lambda ctx: self._handle_moving_to_first_point_state(ctx,&#10;                                                                                                         resume=False),&#10;            GlueProcessState.EXECUTING_PATH: lambda ctx: GlueProcessState.PUMP_INITIAL_BOOST,&#10;            GlueProcessState.PUMP_INITIAL_BOOST: self._handle_pump_initial_boost,&#10;            GlueProcessState.STARTING_PUMP_ADJUSTMENT_THREAD: self._handle_start_pump_adjustment_thread,&#10;            GlueProcessState.SENDING_PATH_POINTS: self._handle_send_path_to_robot_state,&#10;            GlueProcessState.WAIT_FOR_PATH_COMPLETION: self._handle_wait_for_path_completion,&#10;            GlueProcessState.TRANSITION_BETWEEN_PATHS: self._handle_transition_between_paths,&#10;            GlueProcessState.PAUSED: lambda ctx: GlueProcessState.PAUSED,&#10;            GlueProcessState.STOPPED: lambda ctx: GlueProcessState.COMPLETED,&#10;            GlueProcessState.ERROR: lambda ctx: GlueProcessState.ERROR,&#10;            GlueProcessState.COMPLETED: lambda ctx: GlueProcessState.COMPLETED,&#10;            GlueProcessState.INITIALIZING: lambda ctx: GlueProcessState.IDLE,&#10;        }&#10;        registry = StateRegistry()&#10;        # Create and register State objects&#10;        for state_enum, handler in state_handlers_map.items():&#10;            registry.register_state(State(&#10;                state=state_enum,&#10;                handler=handler,&#10;                on_enter=lambda ctx, s=state_enum: self._write_context_debug(f&quot;{s.name}_ENTER&quot;),&#10;                on_exit=lambda ctx, s=state_enum: self._write_context_debug(f&quot;{s.name}_EXIT&quot;)&#10;            ))&#10;&#10;&#10;&#10;        # Build the executable state machine&#10;        transition_rules = GlueProcessTransitionRules.get_glue_transition_rules()&#10;        state_machine = (&#10;            ExecutableStateMachineBuilder()&#10;        .with_initial_state(GlueProcessState.INITIALIZING)&#10;        .with_transition_rules(transition_rules)&#10;        .with_state_registry(registry)&#10;        .with_context(self.execution_context)&#10;        .with_state_topic(GlueTopics.PROCESS_STATE)&#10;        .build()&#10;        )&#10;&#10;        return state_machine&#10;        # return ExecutableStateMachine(&#10;        #     initial_state=GlueProcessState.INITIALIZING,&#10;        #     transition_rules=transition_rules,&#10;        #     state_registry=registry,&#10;        #     context=self.execution_context,&#10;        # )" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/src/applications/glue_dispensing_application/glue_process/state_machine/GlueProcessState.py">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/applications/glue_dispensing_application/glue_process/state_machine/GlueProcessState.py" />
              <option name="originalContent" value="&quot;&quot;&quot;&#10;Glue Process States&#10;&#10;import threading&#10;This module defines the states specific to the glue dispensing application.&#10;These states extend the base ProcessStateType with glue-specific operations&#10;and workflow steps.&#10;&quot;&quot;&quot;&#10;&#10;from enum import Enum, auto&#10;from typing import Dict, Set&#10;&#10;&#10;&#10;class GlueProcessState(Enum):&#10;    &quot;&quot;&quot;&#10;    States specific to the glue dispensing process.&#10;    &#10;    These states represent the complete workflow for glue dispensing operations,&#10;    from initialization through completion. They inherit the base process patterns&#10;    but add glue-specific operations.&#10;    &quot;&quot;&quot;&#10;&#10;    INITIALIZING = auto()&#10;    IDLE = auto()&#10;    MOVING_TO_FIRST_POINT = auto()&#10;    WAIT_FOR_PATH_COMPLETION = auto()&#10;    STARTING = auto()&#10;    PREPARING_PATH = auto()&#10;    MOVING_TO_START_POINT = auto()&#10;    WAITING_FOR_START_REACH = auto()&#10;    EXECUTING_PATH = auto()&#10;    STARTING_PUMP = auto()&#10;    SENDING_PATH_POINTS = auto()&#10;    WAITING_PATH_COMPLETION = auto()&#10;    STOPPING_PUMP = auto()&#10;    TRANSITION_BETWEEN_PATHS = auto()&#10;    PATH_CLEANUP = auto()&#10;    PATH_INCREMENT = auto()&#10;    COMPLETED = auto()&#10;    ERROR = auto()&#10;    STOPPED = auto()&#10;    PAUSED = auto()&#10;    STARTING_PUMP_ADJUSTMENT_THREAD = auto()&#10;    PUMP_INITIAL_BOOST = auto()&#10;&#10;&#10;&#10;&#10;&#10;class GlueProcessTransitionRules:&#10;    &quot;&quot;&quot;&#10;    Transition rules specific to the glue dispensing process.&#10;    &#10;    These rules define the valid state transitions for glue dispensing operations.&#10;    &quot;&quot;&quot;&#10;    &#10;    @staticmethod&#10;    def get_glue_transition_rules() -&gt; Dict[GlueProcessState, Set[GlueProcessState]]:&#10;        &quot;&quot;&quot;&#10;        Get the complete transition rules for glue dispensing operations.&#10;        &#10;        Returns:&#10;            Dict mapping glue process states to their valid transition targets&#10;        &quot;&quot;&quot;&#10;        return {&#10;            GlueProcessState.INITIALIZING: {&#10;                GlueProcessState.IDLE,&#10;                GlueProcessState.ERROR&#10;            },&#10;&#10;            GlueProcessState.IDLE: {&#10;                GlueProcessState.STARTING,&#10;                GlueProcessState.ERROR,&#10;            },&#10;&#10;            GlueProcessState.STARTING: {&#10;                GlueProcessState.MOVING_TO_FIRST_POINT,&#10;                GlueProcessState.EXECUTING_PATH,&#10;                GlueProcessState.COMPLETED,&#10;                GlueProcessState.PAUSED,&#10;                GlueProcessState.STOPPED,&#10;                GlueProcessState.ERROR,&#10;            },&#10;&#10;            GlueProcessState.MOVING_TO_FIRST_POINT: {&#10;                GlueProcessState.EXECUTING_PATH,&#10;                GlueProcessState.PAUSED,&#10;                GlueProcessState.STOPPED,&#10;                GlueProcessState.COMPLETED,&#10;                GlueProcessState.ERROR,&#10;            },&#10;&#10;            #  Extended execution chain&#10;            GlueProcessState.EXECUTING_PATH: {&#10;                GlueProcessState.PUMP_INITIAL_BOOST,&#10;                GlueProcessState.TRANSITION_BETWEEN_PATHS,&#10;                GlueProcessState.PAUSED,&#10;                GlueProcessState.STOPPED,&#10;                GlueProcessState.COMPLETED,&#10;                GlueProcessState.ERROR,&#10;            },&#10;&#10;            #  New intermediate state: PUMP_INITIAL_BOOST&#10;            GlueProcessState.PUMP_INITIAL_BOOST: {&#10;                GlueProcessState.STARTING_PUMP_ADJUSTMENT_THREAD,&#10;                GlueProcessState.PAUSED,&#10;                GlueProcessState.STOPPED,&#10;                GlueProcessState.ERROR,&#10;            },&#10;&#10;            #  New intermediate state: STARTING_PUMP_ADJUSTMENT_THREAD&#10;            GlueProcessState.STARTING_PUMP_ADJUSTMENT_THREAD: {&#10;                GlueProcessState.SENDING_PATH_POINTS,&#10;                GlueProcessState.PAUSED,&#10;                GlueProcessState.STOPPED,&#10;                GlueProcessState.ERROR,&#10;            },&#10;&#10;            #  New intermediate state: SENDING_PATH_POINTS&#10;            GlueProcessState.SENDING_PATH_POINTS: {&#10;                GlueProcessState.WAIT_FOR_PATH_COMPLETION,&#10;                GlueProcessState.PAUSED,&#10;                GlueProcessState.STOPPED,&#10;                GlueProcessState.ERROR,&#10;            },&#10;&#10;            #  New intermediate state: WAIT_FOR_PATH_COMPLETION&#10;            GlueProcessState.WAIT_FOR_PATH_COMPLETION: {&#10;                GlueProcessState.TRANSITION_BETWEEN_PATHS,&#10;                GlueProcessState.COMPLETED,&#10;                GlueProcessState.PAUSED,&#10;                GlueProcessState.STOPPED,&#10;                GlueProcessState.ERROR,&#10;            },&#10;&#10;            GlueProcessState.TRANSITION_BETWEEN_PATHS: {&#10;                GlueProcessState.STARTING,  # Start next path&#10;                GlueProcessState.COMPLETED,  # No more paths&#10;                GlueProcessState.PAUSED,&#10;                GlueProcessState.STOPPED,&#10;                GlueProcessState.ERROR,&#10;            },&#10;&#10;            GlueProcessState.PAUSED: {&#10;                GlueProcessState.STARTING,  # Resume execution&#10;                GlueProcessState.STOPPED,  # Stop from pause&#10;                GlueProcessState.COMPLETED,  # Complete from pause&#10;                GlueProcessState.IDLE,  # Reset to idle&#10;                GlueProcessState.ERROR,&#10;            },&#10;&#10;            GlueProcessState.STOPPED: {&#10;                GlueProcessState.COMPLETED,  # Complete after stop&#10;                GlueProcessState.IDLE,  # Reset to idle&#10;                GlueProcessState.ERROR,&#10;            },&#10;&#10;            GlueProcessState.COMPLETED: {&#10;                GlueProcessState.IDLE,  # Ready for next operation&#10;                GlueProcessState.ERROR,&#10;            },&#10;&#10;            GlueProcessState.ERROR: {&#10;                GlueProcessState.ERROR,  # Allow staying in error state&#10;                GlueProcessState.IDLE,  # Recovery&#10;                GlueProcessState.INITIALIZING,  # Full reset&#10;            },&#10;        }&#10;" />
              <option name="updatedContent" value="&quot;&quot;&quot;&#10;Glue Process States&#10;&#10;This module defines the states specific to the glue dispensing application.&#10;These states extend the base ProcessStateType with glue-specific operations&#10;and workflow steps.&#10;&quot;&quot;&quot;&#10;&#10;from enum import Enum, auto&#10;from typing import Dict, Set&#10;&#10;&#10;&#10;class GlueProcessState(Enum):&#10;    &quot;&quot;&quot;&#10;    States specific to the glue dispensing process.&#10;    &#10;    These states represent the complete workflow for glue dispensing operations,&#10;    from initialization through completion. They inherit the base process patterns&#10;    but add glue-specific operations.&#10;    &quot;&quot;&quot;&#10;&#10;    INITIALIZING = auto()&#10;    IDLE = auto()&#10;    MOVING_TO_FIRST_POINT = auto()&#10;    WAIT_FOR_PATH_COMPLETION = auto()&#10;    STARTING = auto()&#10;    PREPARING_PATH = auto()&#10;    MOVING_TO_START_POINT = auto()&#10;    WAITING_FOR_START_REACH = auto()&#10;    EXECUTING_PATH = auto()&#10;    STARTING_PUMP = auto()&#10;    SENDING_PATH_POINTS = auto()&#10;    WAITING_PATH_COMPLETION = auto()&#10;    STOPPING_PUMP = auto()&#10;    TRANSITION_BETWEEN_PATHS = auto()&#10;    PATH_CLEANUP = auto()&#10;    PATH_INCREMENT = auto()&#10;    COMPLETED = auto()&#10;    ERROR = auto()&#10;    STOPPED = auto()&#10;    PAUSED = auto()&#10;    STARTING_PUMP_ADJUSTMENT_THREAD = auto()&#10;    PUMP_INITIAL_BOOST = auto()&#10;&#10;&#10;&#10;&#10;&#10;class GlueProcessTransitionRules:&#10;    &quot;&quot;&quot;&#10;    Transition rules specific to the glue dispensing process.&#10;    &#10;    These rules define the valid state transitions for glue dispensing operations.&#10;    &quot;&quot;&quot;&#10;    &#10;    @staticmethod&#10;    def get_glue_transition_rules() -&gt; Dict[GlueProcessState, Set[GlueProcessState]]:&#10;        &quot;&quot;&quot;&#10;        Get the complete transition rules for glue dispensing operations.&#10;        &#10;        Returns:&#10;            Dict mapping glue process states to their valid transition targets&#10;        &quot;&quot;&quot;&#10;        return {&#10;            GlueProcessState.INITIALIZING: {&#10;                GlueProcessState.IDLE,&#10;                GlueProcessState.ERROR&#10;            },&#10;&#10;            GlueProcessState.IDLE: {&#10;                GlueProcessState.STARTING,&#10;                GlueProcessState.ERROR,&#10;            },&#10;&#10;            GlueProcessState.STARTING: {&#10;                GlueProcessState.MOVING_TO_FIRST_POINT,&#10;                GlueProcessState.EXECUTING_PATH,&#10;                GlueProcessState.COMPLETED,&#10;                GlueProcessState.PAUSED,&#10;                GlueProcessState.STOPPED,&#10;                GlueProcessState.ERROR,&#10;            },&#10;&#10;            GlueProcessState.MOVING_TO_FIRST_POINT: {&#10;                GlueProcessState.STOPPED,&#10;                GlueProcessState.COMPLETED,&#10;                GlueProcessState.ERROR,&#10;            },&#10;&#10;            #  Extended execution chain&#10;            GlueProcessState.EXECUTING_PATH: {&#10;                GlueProcessState.PUMP_INITIAL_BOOST,&#10;                GlueProcessState.TRANSITION_BETWEEN_PATHS,&#10;                GlueProcessState.PAUSED,&#10;                GlueProcessState.STOPPED,&#10;                GlueProcessState.COMPLETED,&#10;                GlueProcessState.ERROR,&#10;            },&#10;&#10;            #  New intermediate state: PUMP_INITIAL_BOOST&#10;            GlueProcessState.PUMP_INITIAL_BOOST: {&#10;                GlueProcessState.STARTING_PUMP_ADJUSTMENT_THREAD,&#10;                GlueProcessState.PAUSED,&#10;                GlueProcessState.STOPPED,&#10;                GlueProcessState.ERROR,&#10;            },&#10;&#10;            #  New intermediate state: STARTING_PUMP_ADJUSTMENT_THREAD&#10;            GlueProcessState.STARTING_PUMP_ADJUSTMENT_THREAD: {&#10;                GlueProcessState.SENDING_PATH_POINTS,&#10;                GlueProcessState.PAUSED,&#10;                GlueProcessState.STOPPED,&#10;                GlueProcessState.ERROR,&#10;            },&#10;&#10;            #  New intermediate state: SENDING_PATH_POINTS&#10;            GlueProcessState.SENDING_PATH_POINTS: {&#10;&#10;            #  New intermediate state: SENDING_PATH_POINTS&#10;            GlueProcessState.SENDING_PATH_POINTS: {&#10;            },&#10;&#10;            #  New intermediate state: WAIT_FOR_PATH_COMPLETION&#10;            GlueProcessState.WAIT_FOR_PATH_COMPLETION: {&#10;                GlueProcessState.TRANSITION_BETWEEN_PATHS,&#10;                GlueProcessState.COMPLETED,&#10;                GlueProcessState.PAUSED,&#10;                GlueProcessState.STOPPED,&#10;                GlueProcessState.ERROR,&#10;            },&#10;&#10;            GlueProcessState.TRANSITION_BETWEEN_PATHS: {&#10;                GlueProcessState.STARTING,  # Start next path&#10;                GlueProcessState.COMPLETED,  # No more paths&#10;                GlueProcessState.PAUSED,&#10;                GlueProcessState.STOPPED,&#10;                GlueProcessState.ERROR,&#10;                GlueProcessState.COMPLETED,  # No more paths&#10;                GlueProcessState.PAUSED,&#10;                GlueProcessState.STOPPED,&#10;                GlueProcessState.STOPPED,  # Stop from pause&#10;                GlueProcessState.COMPLETED,  # Complete from pause&#10;                GlueProcessState.IDLE,  # Reset to idle&#10;                GlueProcessState.ERROR,&#10;            },&#10;&#10;            GlueProcessState.STOPPED: {&#10;                GlueProcessState.COMPLETED,  # Complete after stop&#10;                GlueProcessState.IDLE,  # Reset to idle&#10;                GlueProcessState.ERROR,&#10;            },&#10;&#10;            GlueProcessState.COMPLETED: {&#10;                GlueProcessState.IDLE,  # Ready for next operation&#10;                GlueProcessState.ERROR,&#10;            },&#10;&#10;            GlueProcessState.ERROR: {&#10;                GlueProcessState.ERROR,  # Allow staying in error state&#10;                GlueProcessState.IDLE,  # Recovery&#10;                GlueProcessState.INITIALIZING,  # Full reset&#10;            },&#10;        }" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/src/applications/glue_dispensing_application/workpiece/GlueWorkpiece.py">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/applications/glue_dispensing_application/workpiece/GlueWorkpiece.py" />
              <option name="originalContent" value="import numpy as np&#10;&#10;from applications.glue_dispensing_application.workpiece.GlueWorkpieceField import GlueWorkpieceField&#10;from core.model.workpiece.Workpiece import BaseWorkpiece&#10;from modules.shared.core.interfaces.JsonSerializable import JsonSerializable&#10;from modules.shared.tools.GlueCell import GlueType&#10;from modules.shared.tools.enums.Gripper import Gripper&#10;from modules.shared.tools.enums.Program import Program&#10;from modules.shared.tools.enums.ToolID import ToolID&#10;&#10;&#10;class GlueWorkpiece(BaseWorkpiece, JsonSerializable):&#10;    &quot;&quot;&quot;&#10;        A class representing a workpieces in a glue dispensing application, including its properties such as ID,&#10;        name, description, tool, gripper, glue type, program, material, contour, offset, height, nozzles,&#10;        contour area, and spray pattern.&#10;&#10;        Inherits from BaseWorkpiece and JsonSerializable for basic workpieces functionality and serialization support.&#10;        &quot;&quot;&quot;&#10;    def __init__(self, workpieceId, name, description, toolID, gripperID, glueType, program, material, contour, offset,&#10;                 height, nozzles, contourArea, glueQty, sprayWidth, pickupPoint, sprayPattern=None):&#10;        &quot;&quot;&quot;&#10;              Initializes a Workpiece object with specified parameters.&#10;&#10;              Args:&#10;                  workpieceId (int): The unique identifier for the workpieces.&#10;                  name (str): The name of the workpieces.&#10;                  description (str): A description of the workpieces.&#10;                  toolID (ToolID): The tool ID associated with the workpieces.&#10;                  gripperID (Gripper): The gripper ID associated with the workpieces.&#10;                  glueType (GlueType): The type of glue used in the workpieces.&#10;                  program (Program): The program associated with the workpieces.&#10;                  material (str): The material of the workpieces.&#10;                  contour (list of np.ndarray): The contour points of the workpieces.&#10;                  offset (float): The offset of the workpieces.&#10;                  height (float): The height of the workpieces.&#10;                  nozzles (list): The list of nozzles associated with the workpieces.&#10;                  contourArea (float): The area of the contour.&#10;                  sprayPattern (optional, list): The spray pattern used for the workpieces. Defaults to an empty list if None.&#10;&#10;              &quot;&quot;&quot;&#10;        super().__init__(workpieceId, contour)&#10;        if sprayPattern is None:&#10;            sprayPattern = []&#10;        self.workpieceId = workpieceId&#10;        self.name = name&#10;        self.description = description&#10;        self.toolID = toolID&#10;        self.gripperID = gripperID&#10;        self.glueType = glueType&#10;        self.program = program&#10;        self.material = material&#10;        self.contour = contour  # This should be a list of nd arrays&#10;        self.offset = offset&#10;        self.height = height&#10;        self.sprayPattern = sprayPattern&#10;        self.contourArea = contourArea&#10;        self.nozzles = nozzles&#10;        self.glueQty = glueQty&#10;        self.sprayWidth = sprayWidth&#10;        self.pickupPoint = pickupPoint  # Placeholder for pickup point&#10;&#10;    def __str__(self):&#10;        return (f&quot;Workpiece(ID: {self.workpieceId}, &quot;&#10;                f&quot;Name: {self.name}, &quot;&#10;                f&quot;Description: {self.description}, &quot;&#10;                f&quot;Tool: {self.toolID.value if hasattr(self.toolID, 'value') else self.toolID}, &quot;&#10;                f&quot;Gripper: {self.gripperID.value if hasattr(self.gripperID, 'value') else self.gripperID}, &quot;&#10;                f&quot;Material: {self.material}, &quot;&#10;                f&quot;Height: {self.height}, &quot;&#10;                f&quot;ContourArea: {self.contourArea}), &quot;&#10;                f&quot;PickupPoint: {self.pickupPoint})&quot;)&#10;&#10;    def get_spray_pattern_contours(self):&#10;        &quot;&quot;&quot;&#10;        Return list of spray pattern contour entries.&#10;        Each entry is a dict: {&quot;contour&quot;: np.ndarray, &quot;settings&quot;: dict}&#10;        &quot;&quot;&quot;&#10;        contours = []&#10;        for entry in self.sprayPattern.get(&quot;Contour&quot;, []):&#10;            contour_points = np.array(entry.get(&quot;contour&quot;, []), dtype=np.float32).reshape(-1, 2)&#10;            contours.append({&#10;                &quot;contour&quot;: contour_points,&#10;                &quot;settings&quot;: entry.get(&quot;settings&quot;, {})&#10;            })&#10;        return contours&#10;&#10;&#10;    def get_spray_pattern_fills(self):&#10;        &quot;&quot;&quot;&#10;        Return list of spray pattern fill entries.&#10;        Each entry is a dict: {&quot;contou  r&quot;: np.ndarray, &quot;settings&quot;: dict}&#10;        &quot;&quot;&quot;&#10;        fills = []&#10;        for entry in self.sprayPattern.get(&quot;Fill&quot;, []):&#10;            contour_points = np.array(entry.get(&quot;contour&quot;, []), dtype=np.float32).reshape(-1, 2)&#10;            fills.append({&#10;                &quot;contour&quot;: contour_points,&#10;                &quot;settings&quot;: entry.get(&quot;settings&quot;, {})&#10;            })&#10;        return fills&#10;&#10;    def set_main_contour(self, contour):&#10;      self.contour[&quot;contour&quot;] = contour&#10;&#10;&#10;&#10;    def get_main_contour(self):&#10;        &quot;&quot;&quot;&#10;        Return the main contour without settings.&#10;        Handles both dict and direct format of self.contour.&#10;        Returns numpy array in proper format for nesting operations.&#10;        &quot;&quot;&quot;&#10;&#10;        if isinstance(self.contour, dict) and &quot;contour&quot; in self.contour:&#10;            # Handle dict format: {&quot;contour&quot;: points, &quot;settings&quot;: {...}}&#10;            contour_data = self.contour[&quot;contour&quot;]&#10;        else:&#10;            # Handle direct format: contour data directly&#10;            contour_data = self.contour&#10;&#10;        # Convert to numpy array format expected by nesting (N, 1, 2)&#10;        if isinstance(contour_data, np.ndarray):&#10;            if len(contour_data.shape) == 3 and contour_data.shape[1] == 1:&#10;                # Already in correct format (N, 1, 2)&#10;                return contour_data&#10;            elif len(contour_data.shape) == 2:&#10;                # Convert from (N, 2) to (N, 1, 2)&#10;                return contour_data.reshape(-1, 1, 2)&#10;            else:&#10;                # Flatten and reshape&#10;                return contour_data.reshape(-1, 2).reshape(-1, 1, 2)&#10;        else:&#10;            # Handle list format - convert to numpy array&#10;            flat_points = []&#10;            for point in contour_data:&#10;                if isinstance(point, (list, tuple, np.ndarray)):&#10;                    # Handle nested structures like [[[x, y]]] or [[x, y]]&#10;                    while isinstance(point, (list, tuple, np.ndarray)) and len(point) == 1:&#10;                        point = point[0]&#10;                    if len(point) &gt;= 2:&#10;                        # Recursively flatten nested coordinates&#10;                        x, y = point[0], point[1]&#10;                        while isinstance(x, (list, tuple, np.ndarray)):&#10;                            x = x[0] if len(x) &gt; 0 else 0&#10;                        while isinstance(y, (list, tuple, np.ndarray)):&#10;                            y = y[0] if len(y) &gt; 0 else 0&#10;                        flat_points.append([float(x), float(y)])&#10;&#10;            if flat_points:&#10;                return np.array(flat_points, dtype=np.float32).reshape(-1, 1, 2)&#10;            else:&#10;                return np.array([], dtype=np.float32).reshape(0, 1, 2)&#10;&#10;    def get_main_contour_settings(self):&#10;        &quot;&quot;&quot;&#10;        Return the settings associated with the main contour.&#10;        If no settings are found, return an empty dictionary.&#10;        &quot;&quot;&quot;&#10;        if isinstance(self.contour, dict) and &quot;settings&quot; in self.contour:&#10;            return self.contour[&quot;settings&quot;]&#10;        return {}&#10;&#10;    @staticmethod&#10;    def serialize(workpiece):&#10;        def convert_ndarray_to_list(obj):&#10;            if isinstance(obj, np.ndarray):&#10;                if obj.ndim == 2 and obj.shape[1] == 2:&#10;                    obj = obj.reshape(-1, 1, 2)  # ✅ normalize before list conversion&#10;                return obj.tolist()&#10;            elif isinstance(obj, dict) and &quot;contour&quot; in obj:&#10;                contour = obj[&quot;contour&quot;]&#10;                if isinstance(contour, np.ndarray) and contour.ndim == 2 and contour.shape[1] == 2:&#10;                    contour = contour.reshape(-1, 1, 2)&#10;                return {&#10;                    &quot;contour&quot;: convert_ndarray_to_list(contour),&#10;                    &quot;settings&quot;: dict(obj.get(&quot;settings&quot;, {}))&#10;                }&#10;            elif isinstance(obj, list):&#10;                return [convert_ndarray_to_list(item) for item in obj]&#10;            return obj&#10;&#10;        # ✅ Handle dict contour directly&#10;        contour_data = convert_ndarray_to_list(workpiece.contour)&#10;&#10;        if isinstance(workpiece.sprayPattern, dict):&#10;            spray_pattern_dict = {&#10;                key: [convert_ndarray_to_list(seg) for seg in val]&#10;                for key, val in workpiece.sprayPattern.items()&#10;            }&#10;        else:&#10;            spray_pattern_dict = convert_ndarray_to_list(workpiece.sprayPattern)&#10;&#10;        workpiece.contour = contour_data&#10;        workpiece.sprayPattern = spray_pattern_dict&#10;        return workpiece.to_dict()&#10;&#10;    @staticmethod&#10;    def deserialize(data):&#10;        def convert_list_to_ndarray(obj):&#10;            if isinstance(obj, dict) and &quot;contour&quot; in obj:&#10;                arr = np.array(obj[&quot;contour&quot;], dtype=np.float32)&#10;&#10;                # ✅ Normalize shape to (N, 1, 2)&#10;                if arr.ndim == 1 and arr.shape[0] == 2:&#10;                    arr = arr.reshape(1, 1, 2)  # single point → (1, 1, 2)&#10;                elif arr.ndim == 2 and arr.shape[1] == 2:&#10;                    arr = arr.reshape(-1, 1, 2)  # (N, 2) → (N, 1, 2)&#10;&#10;                return {&#10;                    &quot;contour&quot;: arr,&#10;                    &quot;settings&quot;: obj.get(&quot;settings&quot;, {})&#10;                }&#10;&#10;            elif isinstance(obj, list):&#10;                return [convert_list_to_ndarray(item) for item in obj]&#10;&#10;            return obj&#10;&#10;        # ----- Main contour -----&#10;        raw_contour = data.get(GlueWorkpieceField.CONTOUR.value, [])&#10;&#10;        if isinstance(raw_contour, dict):&#10;            contour = convert_list_to_ndarray(raw_contour)&#10;        elif isinstance(raw_contour, list):&#10;            contour = [convert_list_to_ndarray(seg) for seg in raw_contour]&#10;        else:&#10;            contour = raw_contour  # unexpected type, leave as-is&#10;&#10;        # ----- Spray pattern -----&#10;        raw_spray_pattern = data.get(GlueWorkpieceField.SPRAY_PATTERN.value, {})&#10;        spray_pattern = {}&#10;&#10;        if isinstance(raw_spray_pattern, dict):&#10;            for key, pattern in raw_spray_pattern.items():&#10;                spray_pattern[key] = [convert_list_to_ndarray(seg) for seg in pattern]&#10;        else:&#10;            spray_pattern = raw_spray_pattern&#10;&#10;        # ----- Build workpiece -----&#10;        workpiece = GlueWorkpiece.from_dict(data)&#10;        workpiece.contour = contour&#10;        workpiece.sprayPattern = spray_pattern&#10;        return workpiece&#10;&#10;    def to_dict(self)-&gt; dict:&#10;        &quot;&quot;&quot;&#10;                Convert the Workpiece object into a dictionary representation.&#10;&#10;                Returns:&#10;                    dict: A dictionary containing the Workpiece's properties, suitable for serialization or storage.&#10;                &quot;&quot;&quot;&#10;        return {&#10;            GlueWorkpieceField.WORKPIECE_ID.value: self.workpieceId,&#10;            GlueWorkpieceField.NAME.value: self.name,&#10;            GlueWorkpieceField.DESCRIPTION.value: self.description,&#10;            GlueWorkpieceField.TOOL_ID.value: self.toolID.value,&#10;            GlueWorkpieceField.GRIPPER_ID.value: self.gripperID.value,&#10;            GlueWorkpieceField.GLUE_TYPE.value: self.glueType.value,&#10;            GlueWorkpieceField.PROGRAM.value: self.program.value,&#10;            GlueWorkpieceField.MATERIAL.value: self.material,&#10;            GlueWorkpieceField.CONTOUR.value: self.contour,&#10;            GlueWorkpieceField.OFFSET.value: self.offset,&#10;            GlueWorkpieceField.HEIGHT.value: self.height,&#10;            GlueWorkpieceField.GLUE_QTY.value: self.glueQty,&#10;            GlueWorkpieceField.SPRAY_WIDTH.value: self.sprayWidth,&#10;            GlueWorkpieceField.PICKUP_POINT.value: self.pickupPoint,&#10;            GlueWorkpieceField.SPRAY_PATTERN.value: self.sprayPattern,&#10;            GlueWorkpieceField.CONTOUR_AREA.value: self.contourArea,&#10;            GlueWorkpieceField.NOZZLES.value: self.nozzles&#10;&#10;        }&#10;&#10;    @staticmethod&#10;    def flatten_spray_pattern(obj):&#10;        &quot;&quot;&quot;&#10;             Flatten nested spray pattern lists into a single list.&#10;&#10;             Args:&#10;                 obj (list): The spray pattern (possibly nested) to be flattened.&#10;&#10;             Returns:&#10;                 list: A flattened list containing all points from the spray pattern.&#10;             &quot;&quot;&quot;&#10;        if isinstance(obj, list):&#10;            flat_obj = []&#10;            for item in obj:&#10;                if isinstance(item, list):&#10;                    flat_obj.extend(GlueWorkpiece.flatten_spray_pattern(item))&#10;                else:&#10;                    flat_obj.append(item)&#10;            return flat_obj&#10;        return [obj]&#10;&#10;    @staticmethod&#10;    def reshape_spray_pattern(obj):&#10;        &quot;&quot;&quot;&#10;        Reshape spray pattern list into list of (N, 1, 2) numpy arrays.&#10;&#10;        Args:&#10;            obj (list): The spray pattern, either a single contour or a list of contours.&#10;&#10;        Returns:&#10;            list: A list of numpy arrays representing the reshaped spray pattern contours.&#10;&#10;        Raises:&#10;            ValueError: If the spray pattern format is invalid or unrecognized.&#10;        &quot;&quot;&quot;&#10;        if not obj:&#10;            return []&#10;&#10;        # If it's a single contour, flatten and reshape it&#10;        if all(isinstance(pt, (list, np.ndarray)) and len(pt) == 2 for pt in obj):&#10;            grouped = np.array(obj, dtype=np.float32).reshape(-1, 1, 2)&#10;            return [grouped]&#10;&#10;        # If it's a list of contours&#10;        if isinstance(obj, list) and all(isinstance(c, list) for c in obj):&#10;            result = []&#10;            for contour in obj:&#10;                if not contour:&#10;                    continue&#10;                flat = GlueWorkpiece.flatten_spray_pattern(contour)&#10;                if all(isinstance(x, (int, float)) for x in flat):&#10;                    grouped = [[flat[i], flat[i + 1]] for i in range(0, len(flat), 2)]&#10;                elif all(isinstance(x, list) and len(x) == 2 for x in flat):&#10;                    grouped = flat&#10;                else:&#10;                    raise ValueError(f&quot;Invalid spray pattern shape: {flat}&quot;)&#10;                result.append(np.array(grouped, dtype=np.float32).reshape(-1, 1, 2))&#10;            return result&#10;&#10;        raise ValueError(f&quot;Unknown spray pattern format: {obj}&quot;)&#10;&#10;    @staticmethod&#10;    def from_dict(data: dict):&#10;        &quot;&quot;&quot;&#10;        Deserialize a dictionary into a Workpiece object.&#10;&#10;        Args:&#10;          data (dict): A dictionary representation of a Workpiece.&#10;&#10;        Returns:&#10;          GlueWorkpiece: The reconstructed Workpiece object.&#10;        &quot;&quot;&quot;&#10;        return GlueWorkpiece(&#10;            workpieceId=data[GlueWorkpieceField.WORKPIECE_ID.value],&#10;            name=data[GlueWorkpieceField.NAME.value],&#10;            description=data[GlueWorkpieceField.DESCRIPTION.value],&#10;            toolID=ToolID(data[GlueWorkpieceField.TOOL_ID.value]),&#10;            gripperID=Gripper(data[GlueWorkpieceField.GRIPPER_ID.value]),&#10;            glueType=GlueType(data[GlueWorkpieceField.GLUE_TYPE.value]),&#10;            program=Program(data[GlueWorkpieceField.PROGRAM.value]),&#10;            material=data[GlueWorkpieceField.MATERIAL.value],&#10;            contour=data[GlueWorkpieceField.CONTOUR.value],&#10;            offset=data[GlueWorkpieceField.OFFSET.value],&#10;            height=data.get(GlueWorkpieceField.HEIGHT.value, 4),&#10;            pickupPoint=data.get(GlueWorkpieceField.PICKUP_POINT.value, None),&#10;            nozzles=data.get(GlueWorkpieceField.NOZZLES.value, []),  # Setting nozzles to empty list if missing&#10;            contourArea=data[GlueWorkpieceField.CONTOUR_AREA.value],&#10;            glueQty=data[GlueWorkpieceField.GLUE_QTY.value],&#10;            sprayWidth=data[GlueWorkpieceField.SPRAY_WIDTH.value],&#10;            sprayPattern=data.get(GlueWorkpieceField.SPRAY_PATTERN.value, []),&#10;&#10;            # Setting spray pattern to empty list if missing&#10;        )&#10;" />
              <option name="updatedContent" value="import numpy as np&#10;&#10;from applications.glue_dispensing_application.workpiece.GlueWorkpieceField import GlueWorkpieceField&#10;from core.model.workpiece.Workpiece import BaseWorkpiece&#10;from modules.shared.core.interfaces.JsonSerializable import JsonSerializable&#10;from modules.shared.tools.GlueCell import GlueType&#10;from modules.shared.tools.enums.Gripper import Gripper&#10;from modules.shared.tools.enums.Program import Program&#10;from modules.shared.tools.enums.ToolID import ToolID&#10;&#10;&#10;class GlueWorkpiece(BaseWorkpiece, JsonSerializable):&#10;    &quot;&quot;&quot;&#10;        A class representing a workpieces in a glue dispensing application, including its properties such as ID,&#10;        name, description, tool, gripper, glue type, program, material, contour, offset, height, nozzles,&#10;        contour area, and spray pattern.&#10;&#10;        Inherits from BaseWorkpiece and JsonSerializable for basic workpieces functionality and serialization support.&#10;        &quot;&quot;&quot;&#10;    def __init__(self, workpieceId, name, description, toolID, gripperID, glueType, program, material, contour, offset,&#10;                 height, nozzles, contourArea, glueQty, sprayWidth, pickupPoint, sprayPattern=None):&#10;        &quot;&quot;&quot;&#10;              Initializes a Workpiece object with specified parameters.&#10;&#10;              Args:&#10;                  workpieceId (int): The unique identifier for the workpieces.&#10;                  name (str): The name of the workpieces.&#10;                  description (str): A description of the workpieces.&#10;                  toolID (ToolID): The tool ID associated with the workpieces.&#10;                  gripperID (Gripper): The gripper ID associated with the workpieces.&#10;                  glueType (GlueType): The type of glue used in the workpieces.&#10;                  program (Program): The program associated with the workpieces.&#10;                  material (str): The material of the workpieces.&#10;                  contour (list of np.ndarray): The contour points of the workpieces.&#10;                  offset (float): The offset of the workpieces.&#10;                  height (float): The height of the workpieces.&#10;                  nozzles (list): The list of nozzles associated with the workpieces.&#10;                  contourArea (float): The area of the contour.&#10;                  sprayPattern (optional, list): The spray pattern used for the workpieces. Defaults to an empty list if None.&#10;&#10;              &quot;&quot;&quot;&#10;        super().__init__(workpieceId, contour)&#10;        if sprayPattern is None:&#10;            sprayPattern = []&#10;        self.workpieceId = workpieceId&#10;        self.name = name&#10;        self.description = description&#10;        self.toolID = toolID&#10;        self.gripperID = gripperID&#10;        self.glueType = glueType&#10;        self.program = program&#10;        self.material = material&#10;        self.contour = contour  # This should be a list of nd arrays&#10;        self.offset = offset&#10;        self.height = height&#10;        self.sprayPattern = sprayPattern&#10;        self.contourArea = contourArea&#10;        self.nozzles = nozzles&#10;        self.glueQty = glueQty&#10;        self.sprayWidth = sprayWidth&#10;        self.pickupPoint = pickupPoint  # Placeholder for pickup point&#10;&#10;    def __str__(self):&#10;        return (f&quot;Workpiece(ID: {self.workpieceId}, &quot;&#10;                f&quot;Name: {self.name}, &quot;&#10;                f&quot;Description: {self.description}, &quot;&#10;                f&quot;Tool: {self.toolID.value if hasattr(self.toolID, 'value') else self.toolID}, &quot;&#10;                f&quot;Gripper: {self.gripperID.value if hasattr(self.gripperID, 'value') else self.gripperID}, &quot;&#10;                f&quot;Material: {self.material}, &quot;&#10;                f&quot;Height: {self.height}, &quot;&#10;                f&quot;ContourArea: {self.contourArea}), &quot;&#10;                f&quot;PickupPoint: {self.pickupPoint})&quot;)&#10;&#10;    def get_spray_pattern_contours(self):&#10;        &quot;&quot;&quot;&#10;        Return list of spray pattern contour entries.&#10;        Each entry is a dict: {&quot;contour&quot;: np.ndarray, &quot;settings&quot;: dict}&#10;        &quot;&quot;&quot;&#10;        contours = []&#10;        for entry in self.sprayPattern.get(&quot;Contour&quot;, []):&#10;            contour_points = np.array(entry.get(&quot;contour&quot;, []), dtype=np.float32).reshape(-1, 2)&#10;            contours.append({&#10;                &quot;contour&quot;: contour_points,&#10;                &quot;settings&quot;: entry.get(&quot;settings&quot;, {})&#10;            })&#10;        return contours&#10;&#10;&#10;    def get_spray_pattern_fills(self):&#10;        &quot;&quot;&quot;&#10;        Return list of spray pattern fill entries.&#10;        Each entry is a dict: {&quot;contou  r&quot;: np.ndarray, &quot;settings&quot;: dict}&#10;        &quot;&quot;&quot;&#10;        fills = []&#10;        for entry in self.sprayPattern.get(&quot;Fill&quot;, []):&#10;            contour_points = np.array(entry.get(&quot;contour&quot;, []), dtype=np.float32).reshape(-1, 2)&#10;            fills.append({&#10;                &quot;contour&quot;: contour_points,&#10;                &quot;settings&quot;: entry.get(&quot;settings&quot;, {})&#10;            })&#10;        return fills&#10;&#10;    def set_main_contour(self, contour):&#10;      self.contour[&quot;contour&quot;] = contour&#10;&#10;&#10;&#10;    def get_main_contour(self):&#10;        &quot;&quot;&quot;&#10;        Return the main contour without settings.&#10;        Handles both dict and direct format of self.contour.&#10;        Returns numpy array in proper format for nesting operations.&#10;        &quot;&quot;&quot;&#10;&#10;        if isinstance(self.contour, dict) and &quot;contour&quot; in self.contour:&#10;            # Handle dict format: {&quot;contour&quot;: points, &quot;settings&quot;: {...}}&#10;            contour_data = self.contour[&quot;contour&quot;]&#10;        else:&#10;            # Handle direct format: contour data directly&#10;            contour_data = self.contour&#10;&#10;        # Convert to numpy array format expected by nesting (N, 1, 2)&#10;        if isinstance(contour_data, np.ndarray):&#10;            if len(contour_data.shape) == 3 and contour_data.shape[1] == 1:&#10;                # Already in correct format (N, 1, 2)&#10;                return contour_data&#10;            elif len(contour_data.shape) == 2:&#10;                # Convert from (N, 2) to (N, 1, 2)&#10;                return contour_data.reshape(-1, 1, 2)&#10;            else:&#10;                # Flatten and reshape&#10;                return contour_data.reshape(-1, 2).reshape(-1, 1, 2)&#10;        else:&#10;            # Handle list format - convert to numpy array&#10;            flat_points = []&#10;            for point in contour_data:&#10;                if isinstance(point, (list, tuple, np.ndarray)):&#10;                    # Handle nested structures like [[[x, y]]] or [[x, y]]&#10;                    while isinstance(point, (list, tuple, np.ndarray)) and len(point) == 1:&#10;                        point = point[0]&#10;                    if len(point) &gt;= 2:&#10;                        # Recursively flatten nested coordinates&#10;                        x, y = point[0], point[1]&#10;                        while isinstance(x, (list, tuple, np.ndarray)):&#10;                            x = x[0] if len(x) &gt; 0 else 0&#10;                        while isinstance(y, (list, tuple, np.ndarray)):&#10;                            y = y[0] if len(y) &gt; 0 else 0&#10;                        flat_points.append([float(x), float(y)])&#10;&#10;            if flat_points:&#10;                return np.array(flat_points, dtype=np.float32).reshape(-1, 1, 2)&#10;            else:&#10;                return np.array([], dtype=np.float32).reshape(0, 1, 2)&#10;&#10;    def get_main_contour_settings(self):&#10;        &quot;&quot;&quot;&#10;        Return the settings associated with the main contour.&#10;        If no settings are found, return an empty dictionary.&#10;        &quot;&quot;&quot;&#10;        if isinstance(self.contour, dict) and &quot;settings&quot; in self.contour:&#10;            return self.contour[&quot;settings&quot;]&#10;        return {}&#10;&#10;    @staticmethod&#10;    def serialize(workpiece):&#10;        def convert_ndarray_to_list(obj):&#10;            if isinstance(obj, np.ndarray):&#10;                if obj.ndim == 2 and obj.shape[1] == 2:&#10;                    obj = obj.reshape(-1, 1, 2)  # ✅ normalize before list conversion&#10;                return obj.tolist()&#10;            elif isinstance(obj, dict) and &quot;contour&quot; in obj:&#10;                contour = obj[&quot;contour&quot;]&#10;                if isinstance(contour, np.ndarray) and contour.ndim == 2 and contour.shape[1] == 2:&#10;                    contour = contour.reshape(-1, 1, 2)&#10;                return {&#10;                    &quot;contour&quot;: convert_ndarray_to_list(contour),&#10;                    &quot;settings&quot;: dict(obj.get(&quot;settings&quot;, {}))&#10;                }&#10;            elif isinstance(obj, list):&#10;                return [convert_ndarray_to_list(item) for item in obj]&#10;            return obj&#10;&#10;        # ✅ Handle dict contour directly&#10;        contour_data = convert_ndarray_to_list(workpiece.contour)&#10;&#10;        if isinstance(workpiece.sprayPattern, dict):&#10;            spray_pattern_dict = {&#10;                key: [convert_ndarray_to_list(seg) for seg in val]&#10;                for key, val in workpiece.sprayPattern.items()&#10;            }&#10;        else:&#10;            spray_pattern_dict = convert_ndarray_to_list(workpiece.sprayPattern)&#10;&#10;        workpiece.contour = contour_data&#10;        workpiece.sprayPattern = spray_pattern_dict&#10;        return workpiece.to_dict()&#10;&#10;    @staticmethod&#10;    def deserialize(data):&#10;        def convert_list_to_ndarray(obj):&#10;            if isinstance(obj, dict) and &quot;contour&quot; in obj:&#10;                arr = np.array(obj[&quot;contour&quot;], dtype=np.float32)&#10;&#10;                # ✅ Normalize shape to (N, 1, 2)&#10;                if arr.ndim == 1 and arr.shape[0] == 2:&#10;                    arr = arr.reshape(1, 1, 2)  # single point → (1, 1, 2)&#10;                elif arr.ndim == 2 and arr.shape[1] == 2:&#10;                    arr = arr.reshape(-1, 1, 2)  # (N, 2) → (N, 1, 2)&#10;&#10;                return {&#10;                    &quot;contour&quot;: arr,&#10;                    &quot;settings&quot;: obj.get(&quot;settings&quot;, {})&#10;                }&#10;&#10;            elif isinstance(obj, list):&#10;                return [convert_list_to_ndarray(item) for item in obj]&#10;&#10;            return obj&#10;&#10;        # ----- Main contour -----&#10;        raw_contour = data.get(GlueWorkpieceField.CONTOUR.value, [])&#10;&#10;        if isinstance(raw_contour, dict):&#10;            contour = convert_list_to_ndarray(raw_contour)&#10;        elif isinstance(raw_contour, list):&#10;            contour = [convert_list_to_ndarray(seg) for seg in raw_contour]&#10;        else:&#10;            contour = raw_contour  # unexpected type, leave as-is&#10;&#10;        # ----- Spray pattern -----&#10;        raw_spray_pattern = data.get(GlueWorkpieceField.SPRAY_PATTERN.value, {})&#10;        spray_pattern = {}&#10;&#10;        if isinstance(raw_spray_pattern, dict):&#10;            for key, pattern in raw_spray_pattern.items():&#10;                spray_pattern[key] = [convert_list_to_ndarray(seg) for seg in pattern]&#10;        else:&#10;            spray_pattern = raw_spray_pattern&#10;&#10;        # ----- Build workpiece -----&#10;        workpiece = GlueWorkpiece.from_dict(data)&#10;        workpiece.contour = contour&#10;        workpiece.sprayPattern = spray_pattern&#10;        return workpiece&#10;&#10;    def to_dict(self)-&gt; dict:&#10;        &quot;&quot;&quot;&#10;                Convert the Workpiece object into a dictionary representation.&#10;&#10;                Returns:&#10;                    dict: A dictionary containing the Workpiece's properties, suitable for serialization or storage.&#10;                &quot;&quot;&quot;&#10;        return {&#10;            GlueWorkpieceField.WORKPIECE_ID.value: self.workpieceId,&#10;            GlueWorkpieceField.NAME.value: self.name,&#10;            GlueWorkpieceField.DESCRIPTION.value: self.description,&#10;            GlueWorkpieceField.TOOL_ID.value: self.toolID.value,&#10;            GlueWorkpieceField.GRIPPER_ID.value: self.gripperID.value,&#10;            GlueWorkpieceField.GLUE_TYPE.value: self.glueType.value,&#10;            GlueWorkpieceField.PROGRAM.value: self.program.value,&#10;            GlueWorkpieceField.MATERIAL.value: self.material,&#10;            GlueWorkpieceField.CONTOUR.value: self.contour,&#10;            GlueWorkpieceField.OFFSET.value: self.offset,&#10;            GlueWorkpieceField.HEIGHT.value: self.height,&#10;            GlueWorkpieceField.GLUE_QTY.value: self.glueQty,&#10;            GlueWorkpieceField.SPRAY_WIDTH.value: self.sprayWidth,&#10;            GlueWorkpieceField.PICKUP_POINT.value: self.pickupPoint,&#10;            GlueWorkpieceField.SPRAY_PATTERN.value: self.sprayPattern,&#10;            GlueWorkpieceField.CONTOUR_AREA.value: self.contourArea,&#10;            GlueWorkpieceField.NOZZLES.value: self.nozzles&#10;&#10;        }&#10;&#10;    @staticmethod&#10;    def flatten_spray_pattern(obj):&#10;        &quot;&quot;&quot;&#10;             Flatten nested spray pattern lists into a single list.&#10;&#10;             Args:&#10;                 obj (list): The spray pattern (possibly nested) to be flattened.&#10;&#10;             Returns:&#10;                 list: A flattened list containing all points from the spray pattern.&#10;             &quot;&quot;&quot;&#10;        if isinstance(obj, list):&#10;            flat_obj = []&#10;            for item in obj:&#10;                if isinstance(item, list):&#10;                    flat_obj.extend(GlueWorkpiece.flatten_spray_pattern(item))&#10;                else:&#10;                    flat_obj.append(item)&#10;            return flat_obj&#10;        return [obj]&#10;&#10;    @staticmethod&#10;    def reshape_spray_pattern(obj):&#10;        &quot;&quot;&quot;&#10;        Reshape spray pattern list into list of (N, 1, 2) numpy arrays.&#10;&#10;        Args:&#10;            obj (list): The spray pattern, either a single contour or a list of contours.&#10;&#10;        Returns:&#10;            list: A list of numpy arrays representing the reshaped spray pattern contours.&#10;&#10;        Raises:&#10;            ValueError: If the spray pattern format is invalid or unrecognized.&#10;        &quot;&quot;&quot;&#10;        if not obj:&#10;            return []&#10;&#10;        # If it's a single contour, flatten and reshape it&#10;        if all(isinstance(pt, (list, np.ndarray)) and len(pt) == 2 for pt in obj):&#10;            grouped = np.array(obj, dtype=np.float32).reshape(-1, 1, 2)&#10;            return [grouped]&#10;&#10;        # If it's a list of contours&#10;        if isinstance(obj, list) and all(isinstance(c, list) for c in obj):&#10;            result = []&#10;            for contour in obj:&#10;                if not contour:&#10;                    continue&#10;                flat = GlueWorkpiece.flatten_spray_pattern(contour)&#10;                if all(isinstance(x, (int, float)) for x in flat):&#10;                    grouped = [[flat[i], flat[i + 1]] for i in range(0, len(flat), 2)]&#10;                elif all(isinstance(x, list) and len(x) == 2 for x in flat):&#10;                    grouped = flat&#10;                else:&#10;                    raise ValueError(f&quot;Invalid spray pattern shape: {flat}&quot;)&#10;                result.append(np.array(grouped, dtype=np.float32).reshape(-1, 1, 2))&#10;            return result&#10;&#10;        raise ValueError(f&quot;Unknown spray pattern format: {obj}&quot;)&#10;&#10;    @staticmethod&#10;    def from_dict(data: dict):&#10;        &quot;&quot;&quot;&#10;        Deserialize a dictionary into a Workpiece object.&#10;&#10;        Args:&#10;          data (dict): A dictionary representation of a Workpiece.&#10;&#10;        Returns:&#10;          GlueWorkpiece: The reconstructed Workpiece object.&#10;        &quot;&quot;&quot;&#10;        return GlueWorkpiece(&#10;            workpieceId=data[GlueWorkpieceField.WORKPIECE_ID.value],&#10;            name=data[GlueWorkpieceField.NAME.value],&#10;            description=data[GlueWorkpieceField.DESCRIPTION.value],&#10;            toolID=ToolID(data[GlueWorkpieceField.TOOL_ID.value]),&#10;            gripperID=Gripper(data[GlueWorkpieceField.GRIPPER_ID.value]),&#10;            glueType=GlueType(data[GlueWorkpieceField.GLUE_TYPE.value]),&#10;            program=Program(data[GlueWorkpieceField.PROGRAM.value]),&#10;            material=data[GlueWorkpieceField.MATERIAL.value],&#10;            contour=data[GlueWorkpieceField.CONTOUR.value],&#10;            offset=data[GlueWorkpieceField.OFFSET.value],&#10;            height=data.get(GlueWorkpieceField.HEIGHT.value, 4),&#10;            pickupPoint=data.get(GlueWorkpieceField.PICKUP_POINT.value, None),&#10;            nozzles=data.get(GlueWorkpieceField.NOZZLES.value, []),  # Setting nozzles to empty list if missing&#10;            contourArea=data[GlueWorkpieceField.CONTOUR_AREA.value],&#10;            glueQty=data[GlueWorkpieceField.GLUE_QTY.value],&#10;            sprayWidth=data[GlueWorkpieceField.SPRAY_WIDTH.value],&#10;            sprayPattern=data.get(GlueWorkpieceField.SPRAY_PATTERN.value, []),&#10;&#10;            # Setting spray pattern to empty list if missing&#10;        )&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/src/applications/test_application.py">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/applications/test_application.py" />
              <option name="originalContent" value="from typing import Dict, Any, List&#10;&#10;from core.application_state_management import ApplicationState&#10;from core.base_robot_application import BaseRobotApplication, ApplicationMetadata&#10;from core.operation_state_management import IOperation, OperationStatePublisher, OperationResult&#10;from modules.shared.MessageBroker import MessageBroker&#10;&#10;&#10;class TestOperation(IOperation):&#10;&#10;    def __init__(self, broker: MessageBroker):&#10;        self.broker = broker&#10;        super().__init__()&#10;        self.set_state_publisher(OperationStatePublisher(broker=self.broker))&#10;&#10;    def _do_start(self, *args, **kwargs):&#10;        print(f&quot;Starting TestOperation with args: {args}, kwargs: {kwargs}&quot;)&#10;        return OperationResult(success=True, message=&quot;TestOperation started&quot;)&#10;&#10;    def _do_stop(self, *args, **kwargs):&#10;        print(&quot;Stopping TestOperation with args:&quot;, args, &quot;kwargs:&quot;, kwargs)&#10;        return OperationResult(success=True, message=&quot;TestOperation stopped&quot;)&#10;&#10;    def _do_pause(self, *args, **kwargs):&#10;        print(f&quot;Pausing TestOperation with args: {args}, kwargs: {kwargs}&quot;)&#10;        return OperationResult(success=True, message=&quot;TestOperation paused&quot;)&#10;&#10;    def _do_resume(self, *args, **kwargs):&#10;        print(f&quot;Resuming TestOperation with args: {args}, kwargs: {kwargs}&quot;)&#10;        return OperationResult(success=True, message=&quot;TestOperation resumed&quot;)&#10;&#10;&#10;class TestApplication(BaseRobotApplication):&#10;    def __init__(self, vision_service,settings_manager,robot_service,settings_registry, **kwargs):&#10;        super().__init__(vision_service,settings_manager,robot_service,settings_registry, **kwargs)&#10;        self.current_operation = TestOperation(broker=self.broker)&#10;&#10;    @property&#10;    def operation(self):&#10;        return self.current_operation&#10;&#10;    @staticmethod&#10;    def get_metadata() -&gt; ApplicationMetadata:&#10;        return ApplicationMetadata(name=&quot;TestApplication&quot;,&#10;                                   version=&quot;1.0.0&quot;,&#10;                                   dependencies=[&quot;_VisionService&quot;,&#10;                                                 &quot;SettingsService&quot;,&#10;                                                 &quot;BaseRobotService&quot;,&#10;                                                 &quot;ApplicationSettingsRegistry&quot;])&#10;&#10;    def get_initial_state(self) -&gt; ApplicationState:&#10;        return ApplicationState.INITIALIZING&#10;&#10;    def set_current_operation(self):&#10;        self.current_operation = TestOperation(broker=self.broker)&#10;&#10;    def __on_operation_start(self) -&gt; OperationResult:&#10;        print(&quot;[TestApplication] Operation is starting...&quot;)&#10;        return OperationResult(success=True, message=&quot;Operation started in TestApplication&quot;)&#10;&#10;&#10;    def stop(self) -&gt; OperationResult:&#10;        return self.operation.stop()&#10;&#10;    def pause(self) -&gt; OperationResult:&#10;        return self.operation.pause()&#10;&#10;    def resume(self) -&gt; OperationResult:&#10;        return self.operation.resume()&#10;&#10;    def on_mode_change(self,mode):&#10;        print(f&quot;[TestApplication] Mode changed to {mode}&quot;)&#10;&#10;    def calibrate_camera(self) -&gt; Dict[str, Any]:&#10;        print(&quot;[TestApplication] Calibrating camera...&quot;)&#10;        return {&quot;result&quot;: &quot;camera calibrated&quot;}&#10;&#10;    def calibrate_robot(self):&#10;        print(&quot;[TestApplication] Calibrating robot...&quot;)&#10;        return {&quot;result&quot;: &quot;robot calibrated&quot;}&#10;&#10;    def get_supported_operations(self) -&gt; List[str]:&#10;        return [&quot;test_operation&quot;]&#10;&#10;    def validate_configuration(self) -&gt; Dict[str, Any]:&#10;        print(&quot;[TestApplication] Validating configuration...&quot;)&#10;        return {&quot;result&quot;: &quot;configuration valid&quot;}&#10;" />
              <option name="updatedContent" value="from typing import Dict, Any, List&#10;&#10;from core.application_state_management import ApplicationState&#10;from core.base_robot_application import BaseRobotApplication, ApplicationMetadata&#10;from core.operation_state_management import IOperation, OperationStatePublisher, OperationResult&#10;from modules.shared.MessageBroker import MessageBroker&#10;&#10;&#10;class TestOperation(IOperation):&#10;&#10;    def __init__(self, broker: MessageBroker):&#10;        self.broker = broker&#10;        super().__init__()&#10;        self.set_state_publisher(OperationStatePublisher(broker=self.broker))&#10;&#10;    def _do_start(self, *args, **kwargs):&#10;        print(f&quot;Starting TestOperation with args: {args}, kwargs: {kwargs}&quot;)&#10;        return OperationResult(success=True, message=&quot;TestOperation started&quot;)&#10;&#10;    def _do_stop(self, *args, **kwargs):&#10;        print(&quot;Stopping TestOperation with args:&quot;, args, &quot;kwargs:&quot;, kwargs)&#10;        return OperationResult(success=True, message=&quot;TestOperation stopped&quot;)&#10;&#10;    def _do_pause(self, *args, **kwargs):&#10;        print(f&quot;Pausing TestOperation with args: {args}, kwargs: {kwargs}&quot;)&#10;        return OperationResult(success=True, message=&quot;TestOperation paused&quot;)&#10;&#10;    def _do_resume(self, *args, **kwargs):&#10;        print(f&quot;Resuming TestOperation with args: {args}, kwargs: {kwargs}&quot;)&#10;        return OperationResult(success=True, message=&quot;TestOperation resumed&quot;)&#10;&#10;&#10;class TestApplication(BaseRobotApplication):&#10;    def __init__(self, vision_service,settings_manager,robot_service,settings_registry, **kwargs):&#10;        super().__init__(vision_service,settings_manager,robot_service,settings_registry, **kwargs)&#10;        self.current_operation = TestOperation(broker=self.broker)&#10;&#10;    @property&#10;    def operation(self):&#10;        return self.current_operation&#10;&#10;    @staticmethod&#10;    def get_metadata() -&gt; ApplicationMetadata:&#10;        return ApplicationMetadata(name=&quot;TestApplication&quot;,&#10;                                   version=&quot;1.0.0&quot;,&#10;                                   dependencies=[&quot;_VisionService&quot;,&#10;                                                 &quot;SettingsService&quot;,&#10;                                                 &quot;BaseRobotService&quot;,&#10;                                                 &quot;ApplicationSettingsRegistry&quot;])&#10;&#10;    def get_initial_state(self) -&gt; ApplicationState:&#10;        return ApplicationState.INITIALIZING&#10;&#10;    def set_current_operation(self):&#10;        self.current_operation = TestOperation(broker=self.broker)&#10;&#10;    def __on_operation_start(self) -&gt; OperationResult:&#10;        print(&quot;[TestApplication] Operation is starting...&quot;)&#10;        return OperationResult(success=True, message=&quot;Operation started in TestApplication&quot;)&#10;&#10;&#10;    def stop(self) -&gt; OperationResult:&#10;        return self.operation.stop()&#10;&#10;    def pause(self) -&gt; OperationResult:&#10;        return self.operation.pause()&#10;&#10;    def resume(self) -&gt; OperationResult:&#10;        return self.operation.resume()&#10;&#10;    def on_mode_change(self,mode):&#10;        print(f&quot;[TestApplication] Mode changed to {mode}&quot;)&#10;&#10;    def calibrate_camera(self) -&gt; Dict[str, Any]:&#10;        print(&quot;[TestApplication] Calibrating camera...&quot;)&#10;        return {&quot;result&quot;: &quot;camera calibrated&quot;}&#10;&#10;    def calibrate_robot(self):&#10;        print(&quot;[TestApplication] Calibrating robot...&quot;)&#10;        return {&quot;result&quot;: &quot;robot calibrated&quot;}&#10;&#10;    def get_supported_operations(self) -&gt; List[str]:&#10;        return [&quot;test_operation&quot;]&#10;&#10;    def validate_configuration(self) -&gt; Dict[str, Any]:&#10;        print(&quot;[TestApplication] Validating configuration...&quot;)&#10;        return {&quot;result&quot;: &quot;configuration valid&quot;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/src/core/application/interfaces/robot_application_interface.py">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/core/application/interfaces/robot_application_interface.py" />
              <option name="originalContent" value="&quot;&quot;&quot;&#10;Robot Application Interface&#10;&#10;This module defines the standard interface that all robot applications must implement.&#10;It provides a contract for operation control, calibration, workpiece handling, and configuration.&#10;&quot;&quot;&quot;&#10;&#10;from abc import ABC, abstractmethod&#10;from typing import Dict, Any, List&#10;from enum import Enum&#10;&#10;from core.base_robot_application import ApplicationType&#10;from core.operation_state_management import OperationResult&#10;&#10;&#10;class CalibrationStatus(Enum):&#10;    &quot;&quot;&quot;Calibration status indicators&quot;&quot;&quot;&#10;    NOT_CALIBRATED = &quot;not_calibrated&quot;&#10;    IN_PROGRESS = &quot;in_progress&quot;&#10;    CALIBRATED = &quot;calibrated&quot;&#10;    FAILED = &quot;failed&quot;&#10;    EXPIRED = &quot;expired&quot;&#10;&#10;&#10;class WorkpieceProcessingResult(Enum):&#10;    &quot;&quot;&quot;Results of workpiece processing operations&quot;&quot;&quot;&#10;    SUCCESS = &quot;success&quot;&#10;    FAILED = &quot;failed&quot;&#10;    PARTIAL = &quot;partial&quot;&#10;    CANCELLED = &quot;cancelled&quot;&#10;    ERROR = &quot;error&quot;&#10;&#10;&#10;class RobotApplicationInterface(ABC):&#10;    &quot;&quot;&quot;&#10;    Standard interface that all robot applications must implement.&#10;    &#10;    This interface defines the contract for:&#10;    - Operation control (start, stop, pause, resume)&#10;    - Calibration management (robot, camera, tools)&#10;    - Workpiece handling and processing&#10;    - Configuration and settings management&#10;    - Status monitoring and reporting&#10;    &quot;&quot;&quot;&#10;    &#10;    # ========== Core Operation Control ==========&#10;    &#10;    @abstractmethod&#10;    def start(self, **kwargs) -&gt; OperationResult:&#10;        &quot;&quot;&quot;&#10;        Start the robot application operation.&#10;        &#10;        Args:&#10;            mode: Operation mode (automatic, manual, etc.)&#10;            **kwargs: Additional application-specific parameters&#10;            &#10;        Returns:&#10;            Dict containing operation result and status&#10;        &quot;&quot;&quot;&#10;        pass&#10;    &#10;    @abstractmethod&#10;    def stop(self, emergency: bool = False) -&gt; OperationResult:&#10;        &quot;&quot;&quot;&#10;        Stop the robot application operation.&#10;        &#10;        Args:&#10;            emergency: Whether this is an emergency stop&#10;            &#10;        Returns:&#10;            Dict containing operation result&#10;        &quot;&quot;&quot;&#10;        pass&#10;&#10;    @abstractmethod&#10;    def pause(self) -&gt; OperationResult:&#10;        &quot;&quot;&quot;&#10;        Pause the robot application operation.&#10;        &#10;        Returns:&#10;            Dict containing operation result&#10;        &quot;&quot;&quot;&#10;        pass&#10;    &#10;    @abstractmethod&#10;    def resume(self) -&gt; OperationResult:&#10;        &quot;&quot;&quot;&#10;        Resume the robot application operation.&#10;        &#10;        Returns:&#10;            Dict containing operation result&#10;        &quot;&quot;&quot;&#10;        pass&#10;    &#10;    @abstractmethod&#10;    def reset(self) -&gt; OperationResult:&#10;        &quot;&quot;&quot;&#10;        Reset the robot application to initial state.&#10;        &#10;        Returns:&#10;            Dict containing operation result&#10;        &quot;&quot;&quot;&#10;        pass&#10;    &#10;    # ========== Calibration Management ==========&#10;    &#10;    @abstractmethod&#10;    def calibrate_robot(self) -&gt; OperationResult:&#10;        &quot;&quot;&quot;&#10;        Calibrate the robot coordinate system.&#10;        &#10;&#10;        Returns:&#10;            Dict containing calibration result and status&#10;        &quot;&quot;&quot;&#10;        pass&#10;    &#10;    @abstractmethod&#10;    def calibrate_camera(self) -&gt; OperationResult:&#10;        &quot;&quot;&quot;&#10;        Calibrate the camera system.&#10;        &#10;&#10;        Returns:&#10;            Dict containing calibration result and status&#10;        &quot;&quot;&quot;&#10;        pass&#10;&#10;&#10;    # ========== Tool and Hardware Control ==========&#10;&#10;    @abstractmethod&#10;    def home_robot(self) -&gt; OperationResult:&#10;        &quot;&quot;&quot;&#10;        Move robot to home position.&#10;        &#10;        Returns:&#10;            Dict containing operation result&#10;        &quot;&quot;&quot;&#10;        pass&#10;&#10;# ========== Helper Data Classes ==========&#10;&#10;class ApplicationInfo:&#10;    &quot;&quot;&quot;Information about a robot application&quot;&quot;&quot;&#10;    &#10;    def __init__(self, &#10;                 app_type: ApplicationType, &#10;                 name: str, &#10;                 version: str,&#10;                 description: str,&#10;                 supported_operations: List[str],&#10;                 supported_tools: List[str],&#10;                 supported_workpieces: List[str]):&#10;        self.app_type = app_type&#10;        self.name = name&#10;        self.version = version&#10;        self.description = description&#10;        self.supported_operations = supported_operations&#10;        self.supported_tools = supported_tools&#10;        self.supported_workpieces = supported_workpieces&#10;    &#10;    def to_dict(self) -&gt; Dict[str, Any]:&#10;        &quot;&quot;&quot;Convert to dictionary representation&quot;&quot;&quot;&#10;        return {&#10;            &quot;type&quot;: self.app_type.value,&#10;            &quot;name&quot;: self.name,&#10;            &quot;version&quot;: self.version,&#10;            &quot;description&quot;: self.description,&#10;            &quot;supported_operations&quot;: self.supported_operations,&#10;            &quot;supported_tools&quot;: self.supported_tools,&#10;            &quot;supported_workpieces&quot;: self.supported_workpieces&#10;        }&#10;" />
              <option name="updatedContent" value="&quot;&quot;&quot;&#10;Robot Application Interface&#10;&#10;This module defines the standard interface that all robot applications must implement.&#10;It provides a contract for operation control, calibration, workpiece handling, and configuration.&#10;&quot;&quot;&quot;&#10;&#10;from abc import ABC, abstractmethod&#10;from typing import Dict, Any, List&#10;from enum import Enum&#10;&#10;from core.base_robot_application import ApplicationType&#10;from core.operation_state_management import OperationResult&#10;&#10;&#10;class CalibrationStatus(Enum):&#10;    &quot;&quot;&quot;Calibration status indicators&quot;&quot;&quot;&#10;    NOT_CALIBRATED = &quot;not_calibrated&quot;&#10;    IN_PROGRESS = &quot;in_progress&quot;&#10;    CALIBRATED = &quot;calibrated&quot;&#10;    FAILED = &quot;failed&quot;&#10;    EXPIRED = &quot;expired&quot;&#10;&#10;&#10;class WorkpieceProcessingResult(Enum):&#10;    &quot;&quot;&quot;Results of workpiece processing operations&quot;&quot;&quot;&#10;    SUCCESS = &quot;success&quot;&#10;    FAILED = &quot;failed&quot;&#10;    PARTIAL = &quot;partial&quot;&#10;    CANCELLED = &quot;cancelled&quot;&#10;    ERROR = &quot;error&quot;&#10;&#10;&#10;class RobotApplicationInterface(ABC):&#10;    &quot;&quot;&quot;&#10;    Standard interface that all robot applications must implement.&#10;    &#10;    This interface defines the contract for:&#10;    - Operation control (start, stop, pause, resume)&#10;    - Calibration management (robot, camera, tools)&#10;    - Workpiece handling and processing&#10;    - Configuration and settings management&#10;    - Status monitoring and reporting&#10;    &quot;&quot;&quot;&#10;    &#10;    # ========== Core Operation Control ==========&#10;    &#10;    @abstractmethod&#10;    def start(self, **kwargs) -&gt; OperationResult:&#10;        &quot;&quot;&quot;&#10;        Start the robot application operation.&#10;        &#10;        Args:&#10;            mode: Operation mode (automatic, manual, etc.)&#10;            **kwargs: Additional application-specific parameters&#10;            &#10;        Returns:&#10;            Dict containing operation result and status&#10;        &quot;&quot;&quot;&#10;        pass&#10;    &#10;    @abstractmethod&#10;    def stop(self, emergency: bool = False) -&gt; OperationResult:&#10;        &quot;&quot;&quot;&#10;        Stop the robot application operation.&#10;        &#10;        Args:&#10;            emergency: Whether this is an emergency stop&#10;            &#10;        Returns:&#10;            Dict containing operation result&#10;        &quot;&quot;&quot;&#10;        pass&#10;&#10;    @abstractmethod&#10;    def pause(self) -&gt; OperationResult:&#10;        &quot;&quot;&quot;&#10;        Pause the robot application operation.&#10;        &#10;        Returns:&#10;            Dict containing operation result&#10;        &quot;&quot;&quot;&#10;        pass&#10;    &#10;    @abstractmethod&#10;    def resume(self) -&gt; OperationResult:&#10;        &quot;&quot;&quot;&#10;        Resume the robot application operation.&#10;        &#10;        Returns:&#10;            Dict containing operation result&#10;        &quot;&quot;&quot;&#10;        pass&#10;    &#10;    @abstractmethod&#10;    def reset(self) -&gt; OperationResult:&#10;        &quot;&quot;&quot;&#10;        Reset the robot application to initial state.&#10;        &#10;        Returns:&#10;            Dict containing operation result&#10;        &quot;&quot;&quot;&#10;        pass&#10;    &#10;    # ========== Calibration Management ==========&#10;    &#10;    @abstractmethod&#10;    def calibrate_robot(self) -&gt; OperationResult:&#10;        &quot;&quot;&quot;&#10;        Calibrate the robot coordinate system.&#10;        &#10;&#10;        Returns:&#10;            Dict containing calibration result and status&#10;        &quot;&quot;&quot;&#10;        pass&#10;    &#10;    @abstractmethod&#10;    def calibrate_camera(self) -&gt; OperationResult:&#10;        &quot;&quot;&quot;&#10;        Calibrate the camera system.&#10;        &#10;&#10;        Returns:&#10;            Dict containing calibration result and status&#10;        &quot;&quot;&quot;&#10;        pass&#10;&#10;&#10;    # ========== Tool and Hardware Control ==========&#10;&#10;    @abstractmethod&#10;    def home_robot(self) -&gt; OperationResult:&#10;        &quot;&quot;&quot;&#10;        Move robot to home position.&#10;        &#10;        Returns:&#10;            Dict containing operation result&#10;        &quot;&quot;&quot;&#10;        pass&#10;&#10;# ========== Helper Data Classes ==========&#10;&#10;class ApplicationInfo:&#10;    &quot;&quot;&quot;Information about a robot application&quot;&quot;&quot;&#10;    &#10;    def __init__(self, &#10;                 app_type: ApplicationType, &#10;                 name: str, &#10;                 version: str,&#10;                 description: str,&#10;                 supported_operations: List[str],&#10;                 supported_tools: List[str],&#10;                 supported_workpieces: List[str]):&#10;        self.app_type = app_type&#10;        self.name = name&#10;        self.version = version&#10;        self.description = description&#10;        self.supported_operations = supported_operations&#10;        self.supported_tools = supported_tools&#10;        self.supported_workpieces = supported_workpieces&#10;    &#10;    def to_dict(self) -&gt; Dict[str, Any]:&#10;        &quot;&quot;&quot;Convert to dictionary representation&quot;&quot;&quot;&#10;        return {&#10;            &quot;type&quot;: self.app_type.value,&#10;            &quot;name&quot;: self.name,&#10;            &quot;version&quot;: self.version,&#10;            &quot;description&quot;: self.description,&#10;            &quot;supported_operations&quot;: self.supported_operations,&#10;            &quot;supported_tools&quot;: self.supported_tools,&#10;            &quot;supported_workpieces&quot;: self.supported_workpieces&#10;        }" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="/tmp/test_robot_repo.py">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="/tmp/test_robot_repo.py" />
            </PendingDiffInfo>
          </value>
        </entry>
      </map>
    </option>
  </component>
</project>