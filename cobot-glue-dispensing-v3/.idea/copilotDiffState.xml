<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="CopilotDiffPersistence">
    <option name="pendingDiffs">
      <map>
        <entry key="$PROJECT_DIR$/src/applications/glue_dispensing_application/workpiece/GlueWorkpiece.py">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/applications/glue_dispensing_application/workpiece/GlueWorkpiece.py" />
              <option name="originalContent" value="import numpy as np&#10;&#10;from applications.glue_dispensing_application.workpiece.GlueWorkpieceField import GlueWorkpieceField&#10;from core.model.workpiece.Workpiece import BaseWorkpiece&#10;from modules.shared.core.interfaces.JsonSerializable import JsonSerializable&#10;from modules.shared.tools.GlueCell import GlueType&#10;from modules.shared.tools.enums.Gripper import Gripper&#10;from modules.shared.tools.enums.Program import Program&#10;from modules.shared.tools.enums.ToolID import ToolID&#10;&#10;&#10;class GlueWorkpiece(BaseWorkpiece, JsonSerializable):&#10;    &quot;&quot;&quot;&#10;        A class representing a workpieces in a glue dispensing application, including its properties such as ID,&#10;        name, description, tool, gripper, glue type, program, material, contour, offset, height, nozzles,&#10;        contour area, and spray pattern.&#10;&#10;        Inherits from BaseWorkpiece and JsonSerializable for basic workpieces functionality and serialization support.&#10;        &quot;&quot;&quot;&#10;    def __init__(self, workpieceId, name, description, toolID, gripperID, glueType, program, material, contour, offset,&#10;                 height, nozzles, contourArea, glueQty, sprayWidth, pickupPoint, sprayPattern=None):&#10;        &quot;&quot;&quot;&#10;              Initializes a Workpiece object with specified parameters.&#10;&#10;              Args:&#10;                  workpieceId (int): The unique identifier for the workpieces.&#10;                  name (str): The name of the workpieces.&#10;                  description (str): A description of the workpieces.&#10;                  toolID (ToolID): The tool ID associated with the workpieces.&#10;                  gripperID (Gripper): The gripper ID associated with the workpieces.&#10;                  glueType (GlueType): The type of glue used in the workpieces.&#10;                  program (Program): The program associated with the workpieces.&#10;                  material (str): The material of the workpieces.&#10;                  contour (list of np.ndarray): The contour points of the workpieces.&#10;                  offset (float): The offset of the workpieces.&#10;                  height (float): The height of the workpieces.&#10;                  nozzles (list): The list of nozzles associated with the workpieces.&#10;                  contourArea (float): The area of the contour.&#10;                  sprayPattern (optional, list): The spray pattern used for the workpieces. Defaults to an empty list if None.&#10;&#10;              &quot;&quot;&quot;&#10;        super().__init__(workpieceId, contour)&#10;        if sprayPattern is None:&#10;            sprayPattern = []&#10;        self.workpieceId = workpieceId&#10;        self.name = name&#10;        self.description = description&#10;        self.toolID = toolID&#10;        self.gripperID = gripperID&#10;        self.glueType = glueType&#10;        self.program = program&#10;        self.material = material&#10;        self.contour = contour  # This should be a list of nd arrays&#10;        self.offset = offset&#10;        self.height = height&#10;        self.sprayPattern = sprayPattern&#10;        self.contourArea = contourArea&#10;        self.nozzles = nozzles&#10;        self.glueQty = glueQty&#10;        self.sprayWidth = sprayWidth&#10;        self.pickupPoint = pickupPoint  # Placeholder for pickup point&#10;&#10;    def __str__(self):&#10;        return (f&quot;Workpiece(ID: {self.workpieceId}, &quot;&#10;                f&quot;Name: {self.name}, &quot;&#10;                f&quot;Description: {self.description}, &quot;&#10;                f&quot;Tool: {self.toolID.value if hasattr(self.toolID, 'value') else self.toolID}, &quot;&#10;                f&quot;Gripper: {self.gripperID.value if hasattr(self.gripperID, 'value') else self.gripperID}, &quot;&#10;                f&quot;Material: {self.material}, &quot;&#10;                f&quot;Height: {self.height}, &quot;&#10;                f&quot;ContourArea: {self.contourArea}), &quot;&#10;                f&quot;PickupPoint: {self.pickupPoint})&quot;)&#10;&#10;    def get_spray_pattern_contours(self):&#10;        &quot;&quot;&quot;&#10;        Return list of spray pattern contour entries.&#10;        Each entry is a dict: {&quot;contour&quot;: np.ndarray, &quot;settings&quot;: dict}&#10;        &quot;&quot;&quot;&#10;        contours = []&#10;        for entry in self.sprayPattern.get(&quot;Contour&quot;, []):&#10;            contour_points = np.array(entry.get(&quot;contour&quot;, []), dtype=np.float32).reshape(-1, 2)&#10;            contours.append({&#10;                &quot;contour&quot;: contour_points,&#10;                &quot;settings&quot;: entry.get(&quot;settings&quot;, {})&#10;            })&#10;        return contours&#10;&#10;&#10;    def get_spray_pattern_fills(self):&#10;        &quot;&quot;&quot;&#10;        Return list of spray pattern fill entries.&#10;        Each entry is a dict: {&quot;contou  r&quot;: np.ndarray, &quot;settings&quot;: dict}&#10;        &quot;&quot;&quot;&#10;        fills = []&#10;        for entry in self.sprayPattern.get(&quot;Fill&quot;, []):&#10;            contour_points = np.array(entry.get(&quot;contour&quot;, []), dtype=np.float32).reshape(-1, 2)&#10;            fills.append({&#10;                &quot;contour&quot;: contour_points,&#10;                &quot;settings&quot;: entry.get(&quot;settings&quot;, {})&#10;            })&#10;        return fills&#10;&#10;    def set_main_contour(self, contour):&#10;      self.contour[&quot;contour&quot;] = contour&#10;&#10;&#10;&#10;    def get_main_contour(self):&#10;        &quot;&quot;&quot;&#10;        Return the main contour without settings.&#10;        Handles both dict and direct format of self.contour.&#10;        Returns numpy array in proper format for nesting operations.&#10;        &quot;&quot;&quot;&#10;&#10;        if isinstance(self.contour, dict) and &quot;contour&quot; in self.contour:&#10;            # Handle dict format: {&quot;contour&quot;: points, &quot;settings&quot;: {...}}&#10;            contour_data = self.contour[&quot;contour&quot;]&#10;        else:&#10;            # Handle direct format: contour data directly&#10;            contour_data = self.contour&#10;&#10;        # Convert to numpy array format expected by nesting (N, 1, 2)&#10;        if isinstance(contour_data, np.ndarray):&#10;            if len(contour_data.shape) == 3 and contour_data.shape[1] == 1:&#10;                # Already in correct format (N, 1, 2)&#10;                return contour_data&#10;            elif len(contour_data.shape) == 2:&#10;                # Convert from (N, 2) to (N, 1, 2)&#10;                return contour_data.reshape(-1, 1, 2)&#10;            else:&#10;                # Flatten and reshape&#10;                return contour_data.reshape(-1, 2).reshape(-1, 1, 2)&#10;        else:&#10;            # Handle list format - convert to numpy array&#10;            flat_points = []&#10;            for point in contour_data:&#10;                if isinstance(point, (list, tuple, np.ndarray)):&#10;                    # Handle nested structures like [[[x, y]]] or [[x, y]]&#10;                    while isinstance(point, (list, tuple, np.ndarray)) and len(point) == 1:&#10;                        point = point[0]&#10;                    if len(point) &gt;= 2:&#10;                        # Recursively flatten nested coordinates&#10;                        x, y = point[0], point[1]&#10;                        while isinstance(x, (list, tuple, np.ndarray)):&#10;                            x = x[0] if len(x) &gt; 0 else 0&#10;                        while isinstance(y, (list, tuple, np.ndarray)):&#10;                            y = y[0] if len(y) &gt; 0 else 0&#10;                        flat_points.append([float(x), float(y)])&#10;&#10;            if flat_points:&#10;                return np.array(flat_points, dtype=np.float32).reshape(-1, 1, 2)&#10;            else:&#10;                return np.array([], dtype=np.float32).reshape(0, 1, 2)&#10;&#10;    def get_main_contour_settings(self):&#10;        &quot;&quot;&quot;&#10;        Return the settings associated with the main contour.&#10;        If no settings are found, return an empty dictionary.&#10;        &quot;&quot;&quot;&#10;        if isinstance(self.contour, dict) and &quot;settings&quot; in self.contour:&#10;            return self.contour[&quot;settings&quot;]&#10;        return {}&#10;&#10;    @staticmethod&#10;    def serialize(workpiece):&#10;        def convert_ndarray_to_list(obj):&#10;            if isinstance(obj, np.ndarray):&#10;                if obj.ndim == 2 and obj.shape[1] == 2:&#10;                    obj = obj.reshape(-1, 1, 2)  # ✅ normalize before list conversion&#10;                return obj.tolist()&#10;            elif isinstance(obj, dict) and &quot;contour&quot; in obj:&#10;                contour = obj[&quot;contour&quot;]&#10;                if isinstance(contour, np.ndarray) and contour.ndim == 2 and contour.shape[1] == 2:&#10;                    contour = contour.reshape(-1, 1, 2)&#10;                return {&#10;                    &quot;contour&quot;: convert_ndarray_to_list(contour),&#10;                    &quot;settings&quot;: dict(obj.get(&quot;settings&quot;, {}))&#10;                }&#10;            elif isinstance(obj, list):&#10;                return [convert_ndarray_to_list(item) for item in obj]&#10;            return obj&#10;&#10;        # ✅ Handle dict contour directly&#10;        contour_data = convert_ndarray_to_list(workpiece.contour)&#10;&#10;        if isinstance(workpiece.sprayPattern, dict):&#10;            spray_pattern_dict = {&#10;                key: [convert_ndarray_to_list(seg) for seg in val]&#10;                for key, val in workpiece.sprayPattern.items()&#10;            }&#10;        else:&#10;            spray_pattern_dict = convert_ndarray_to_list(workpiece.sprayPattern)&#10;&#10;        workpiece.contour = contour_data&#10;        workpiece.sprayPattern = spray_pattern_dict&#10;        return workpiece.to_dict()&#10;&#10;    @staticmethod&#10;    def deserialize(data):&#10;        def convert_list_to_ndarray(obj):&#10;            if isinstance(obj, dict) and &quot;contour&quot; in obj:&#10;                arr = np.array(obj[&quot;contour&quot;], dtype=np.float32)&#10;&#10;                # ✅ Normalize shape to (N, 1, 2)&#10;                if arr.ndim == 1 and arr.shape[0] == 2:&#10;                    arr = arr.reshape(1, 1, 2)  # single point → (1, 1, 2)&#10;                elif arr.ndim == 2 and arr.shape[1] == 2:&#10;                    arr = arr.reshape(-1, 1, 2)  # (N, 2) → (N, 1, 2)&#10;&#10;                return {&#10;                    &quot;contour&quot;: arr,&#10;                    &quot;settings&quot;: obj.get(&quot;settings&quot;, {})&#10;                }&#10;&#10;            elif isinstance(obj, list):&#10;                return [convert_list_to_ndarray(item) for item in obj]&#10;&#10;            return obj&#10;&#10;        # ----- Main contour -----&#10;        raw_contour = data.get(GlueWorkpieceField.CONTOUR.value, [])&#10;&#10;        if isinstance(raw_contour, dict):&#10;            contour = convert_list_to_ndarray(raw_contour)&#10;        elif isinstance(raw_contour, list):&#10;            contour = [convert_list_to_ndarray(seg) for seg in raw_contour]&#10;        else:&#10;            contour = raw_contour  # unexpected type, leave as-is&#10;&#10;        # ----- Spray pattern -----&#10;        raw_spray_pattern = data.get(GlueWorkpieceField.SPRAY_PATTERN.value, {})&#10;        spray_pattern = {}&#10;&#10;        if isinstance(raw_spray_pattern, dict):&#10;            for key, pattern in raw_spray_pattern.items():&#10;                spray_pattern[key] = [convert_list_to_ndarray(seg) for seg in pattern]&#10;        else:&#10;            spray_pattern = raw_spray_pattern&#10;&#10;        # ----- Build workpiece -----&#10;        workpiece = GlueWorkpiece.from_dict(data)&#10;        workpiece.contour = contour&#10;        workpiece.sprayPattern = spray_pattern&#10;        return workpiece&#10;&#10;    def to_dict(self)-&gt; dict:&#10;        &quot;&quot;&quot;&#10;                Convert the Workpiece object into a dictionary representation.&#10;&#10;                Returns:&#10;                    dict: A dictionary containing the Workpiece's properties, suitable for serialization or storage.&#10;                &quot;&quot;&quot;&#10;        return {&#10;            GlueWorkpieceField.WORKPIECE_ID.value: self.workpieceId,&#10;            GlueWorkpieceField.NAME.value: self.name,&#10;            GlueWorkpieceField.DESCRIPTION.value: self.description,&#10;            GlueWorkpieceField.TOOL_ID.value: self.toolID.value,&#10;            GlueWorkpieceField.GRIPPER_ID.value: self.gripperID.value,&#10;            GlueWorkpieceField.GLUE_TYPE.value: self.glueType.value,&#10;            GlueWorkpieceField.PROGRAM.value: self.program.value,&#10;            GlueWorkpieceField.MATERIAL.value: self.material,&#10;            GlueWorkpieceField.CONTOUR.value: self.contour,&#10;            GlueWorkpieceField.OFFSET.value: self.offset,&#10;            GlueWorkpieceField.HEIGHT.value: self.height,&#10;            GlueWorkpieceField.GLUE_QTY.value: self.glueQty,&#10;            GlueWorkpieceField.SPRAY_WIDTH.value: self.sprayWidth,&#10;            GlueWorkpieceField.PICKUP_POINT.value: self.pickupPoint,&#10;            GlueWorkpieceField.SPRAY_PATTERN.value: self.sprayPattern,&#10;            GlueWorkpieceField.CONTOUR_AREA.value: self.contourArea,&#10;            GlueWorkpieceField.NOZZLES.value: self.nozzles&#10;&#10;        }&#10;&#10;    @staticmethod&#10;    def flatten_spray_pattern(obj):&#10;        &quot;&quot;&quot;&#10;             Flatten nested spray pattern lists into a single list.&#10;&#10;             Args:&#10;                 obj (list): The spray pattern (possibly nested) to be flattened.&#10;&#10;             Returns:&#10;                 list: A flattened list containing all points from the spray pattern.&#10;             &quot;&quot;&quot;&#10;        if isinstance(obj, list):&#10;            flat_obj = []&#10;            for item in obj:&#10;                if isinstance(item, list):&#10;                    flat_obj.extend(GlueWorkpiece.flatten_spray_pattern(item))&#10;                else:&#10;                    flat_obj.append(item)&#10;            return flat_obj&#10;        return [obj]&#10;&#10;    @staticmethod&#10;    def reshape_spray_pattern(obj):&#10;        &quot;&quot;&quot;&#10;        Reshape spray pattern list into list of (N, 1, 2) numpy arrays.&#10;&#10;        Args:&#10;            obj (list): The spray pattern, either a single contour or a list of contours.&#10;&#10;        Returns:&#10;            list: A list of numpy arrays representing the reshaped spray pattern contours.&#10;&#10;        Raises:&#10;            ValueError: If the spray pattern format is invalid or unrecognized.&#10;        &quot;&quot;&quot;&#10;        if not obj:&#10;            return []&#10;&#10;        # If it's a single contour, flatten and reshape it&#10;        if all(isinstance(pt, (list, np.ndarray)) and len(pt) == 2 for pt in obj):&#10;            grouped = np.array(obj, dtype=np.float32).reshape(-1, 1, 2)&#10;            return [grouped]&#10;&#10;        # If it's a list of contours&#10;        if isinstance(obj, list) and all(isinstance(c, list) for c in obj):&#10;            result = []&#10;            for contour in obj:&#10;                if not contour:&#10;                    continue&#10;                flat = GlueWorkpiece.flatten_spray_pattern(contour)&#10;                if all(isinstance(x, (int, float)) for x in flat):&#10;                    grouped = [[flat[i], flat[i + 1]] for i in range(0, len(flat), 2)]&#10;                elif all(isinstance(x, list) and len(x) == 2 for x in flat):&#10;                    grouped = flat&#10;                else:&#10;                    raise ValueError(f&quot;Invalid spray pattern shape: {flat}&quot;)&#10;                result.append(np.array(grouped, dtype=np.float32).reshape(-1, 1, 2))&#10;            return result&#10;&#10;        raise ValueError(f&quot;Unknown spray pattern format: {obj}&quot;)&#10;&#10;    @staticmethod&#10;    def from_dict(data: dict):&#10;        &quot;&quot;&quot;&#10;        Deserialize a dictionary into a Workpiece object.&#10;&#10;        Args:&#10;          data (dict): A dictionary representation of a Workpiece.&#10;&#10;        Returns:&#10;          GlueWorkpiece: The reconstructed Workpiece object.&#10;        &quot;&quot;&quot;&#10;        return GlueWorkpiece(&#10;            workpieceId=data[GlueWorkpieceField.WORKPIECE_ID.value],&#10;            name=data[GlueWorkpieceField.NAME.value],&#10;            description=data[GlueWorkpieceField.DESCRIPTION.value],&#10;            toolID=ToolID(data[GlueWorkpieceField.TOOL_ID.value]),&#10;            gripperID=Gripper(data[GlueWorkpieceField.GRIPPER_ID.value]),&#10;            glueType=GlueType(data[GlueWorkpieceField.GLUE_TYPE.value]),&#10;            program=Program(data[GlueWorkpieceField.PROGRAM.value]),&#10;            material=data[GlueWorkpieceField.MATERIAL.value],&#10;            contour=data[GlueWorkpieceField.CONTOUR.value],&#10;            offset=data[GlueWorkpieceField.OFFSET.value],&#10;            height=data.get(GlueWorkpieceField.HEIGHT.value, 4),&#10;            pickupPoint=data.get(GlueWorkpieceField.PICKUP_POINT.value, None),&#10;            nozzles=data.get(GlueWorkpieceField.NOZZLES.value, []),  # Setting nozzles to empty list if missing&#10;            contourArea=data[GlueWorkpieceField.CONTOUR_AREA.value],&#10;            glueQty=data[GlueWorkpieceField.GLUE_QTY.value],&#10;            sprayWidth=data[GlueWorkpieceField.SPRAY_WIDTH.value],&#10;            sprayPattern=data.get(GlueWorkpieceField.SPRAY_PATTERN.value, []),&#10;&#10;            # Setting spray pattern to empty list if missing&#10;        )&#10;" />
              <option name="updatedContent" value="import numpy as np&#10;&#10;from applications.glue_dispensing_application.workpiece.GlueWorkpieceField import GlueWorkpieceField&#10;from core.model.workpiece.Workpiece import BaseWorkpiece&#10;from modules.shared.core.interfaces.JsonSerializable import JsonSerializable&#10;from modules.shared.tools.GlueCell import GlueType&#10;from modules.shared.tools.enums.Gripper import Gripper&#10;from modules.shared.tools.enums.Program import Program&#10;from modules.shared.tools.enums.ToolID import ToolID&#10;&#10;&#10;class GlueWorkpiece(BaseWorkpiece, JsonSerializable):&#10;    &quot;&quot;&quot;&#10;        A class representing a workpieces in a glue dispensing application, including its properties such as ID,&#10;        name, description, tool, gripper, glue type, program, material, contour, offset, height, nozzles,&#10;        contour area, and spray pattern.&#10;&#10;        Inherits from BaseWorkpiece and JsonSerializable for basic workpieces functionality and serialization support.&#10;        &quot;&quot;&quot;&#10;    def __init__(self, workpieceId, name, description, toolID, gripperID, glueType, program, material, contour, offset,&#10;                 height, nozzles, contourArea, glueQty, sprayWidth, pickupPoint, sprayPattern=None):&#10;        &quot;&quot;&quot;&#10;              Initializes a Workpiece object with specified parameters.&#10;&#10;              Args:&#10;                  workpieceId (int): The unique identifier for the workpieces.&#10;                  name (str): The name of the workpieces.&#10;                  description (str): A description of the workpieces.&#10;                  toolID (ToolID): The tool ID associated with the workpieces.&#10;                  gripperID (Gripper): The gripper ID associated with the workpieces.&#10;                  glueType (GlueType): The type of glue used in the workpieces.&#10;                  program (Program): The program associated with the workpieces.&#10;                  material (str): The material of the workpieces.&#10;                  contour (list of np.ndarray): The contour points of the workpieces.&#10;                  offset (float): The offset of the workpieces.&#10;                  height (float): The height of the workpieces.&#10;                  nozzles (list): The list of nozzles associated with the workpieces.&#10;                  contourArea (float): The area of the contour.&#10;                  sprayPattern (optional, list): The spray pattern used for the workpieces. Defaults to an empty list if None.&#10;&#10;              &quot;&quot;&quot;&#10;        super().__init__(workpieceId, contour)&#10;        if sprayPattern is None:&#10;            sprayPattern = []&#10;        self.workpieceId = workpieceId&#10;        self.name = name&#10;        self.description = description&#10;        self.toolID = toolID&#10;        self.gripperID = gripperID&#10;        self.glueType = glueType&#10;        self.program = program&#10;        self.material = material&#10;        self.contour = contour  # This should be a list of nd arrays&#10;        self.offset = offset&#10;        self.height = height&#10;        self.sprayPattern = sprayPattern&#10;        self.contourArea = contourArea&#10;        self.nozzles = nozzles&#10;        self.glueQty = glueQty&#10;        self.sprayWidth = sprayWidth&#10;        self.pickupPoint = pickupPoint  # Placeholder for pickup point&#10;&#10;    def __str__(self):&#10;        return (f&quot;Workpiece(ID: {self.workpieceId}, &quot;&#10;                f&quot;Name: {self.name}, &quot;&#10;                f&quot;Description: {self.description}, &quot;&#10;                f&quot;Tool: {self.toolID.value if hasattr(self.toolID, 'value') else self.toolID}, &quot;&#10;                f&quot;Gripper: {self.gripperID.value if hasattr(self.gripperID, 'value') else self.gripperID}, &quot;&#10;                f&quot;Material: {self.material}, &quot;&#10;                f&quot;Height: {self.height}, &quot;&#10;                f&quot;ContourArea: {self.contourArea}), &quot;&#10;                f&quot;PickupPoint: {self.pickupPoint})&quot;)&#10;&#10;    def get_spray_pattern_contours(self):&#10;        &quot;&quot;&quot;&#10;        Return list of spray pattern contour entries.&#10;        Each entry is a dict: {&quot;contour&quot;: np.ndarray, &quot;settings&quot;: dict}&#10;        &quot;&quot;&quot;&#10;        contours = []&#10;        for entry in self.sprayPattern.get(&quot;Contour&quot;, []):&#10;            contour_points = np.array(entry.get(&quot;contour&quot;, []), dtype=np.float32).reshape(-1, 2)&#10;            contours.append({&#10;                &quot;contour&quot;: contour_points,&#10;                &quot;settings&quot;: entry.get(&quot;settings&quot;, {})&#10;            })&#10;        return contours&#10;&#10;&#10;    def get_spray_pattern_fills(self):&#10;        &quot;&quot;&quot;&#10;        Return list of spray pattern fill entries.&#10;        Each entry is a dict: {&quot;contou  r&quot;: np.ndarray, &quot;settings&quot;: dict}&#10;        &quot;&quot;&quot;&#10;        fills = []&#10;        for entry in self.sprayPattern.get(&quot;Fill&quot;, []):&#10;            contour_points = np.array(entry.get(&quot;contour&quot;, []), dtype=np.float32).reshape(-1, 2)&#10;            fills.append({&#10;                &quot;contour&quot;: contour_points,&#10;                &quot;settings&quot;: entry.get(&quot;settings&quot;, {})&#10;            })&#10;        return fills&#10;&#10;    def set_main_contour(self, contour):&#10;      self.contour[&quot;contour&quot;] = contour&#10;&#10;&#10;&#10;    def get_main_contour(self):&#10;        &quot;&quot;&quot;&#10;        Return the main contour without settings.&#10;        Handles both dict and direct format of self.contour.&#10;        Returns numpy array in proper format for nesting operations.&#10;        &quot;&quot;&quot;&#10;&#10;        if isinstance(self.contour, dict) and &quot;contour&quot; in self.contour:&#10;            # Handle dict format: {&quot;contour&quot;: points, &quot;settings&quot;: {...}}&#10;            contour_data = self.contour[&quot;contour&quot;]&#10;        else:&#10;            # Handle direct format: contour data directly&#10;            contour_data = self.contour&#10;&#10;        # Convert to numpy array format expected by nesting (N, 1, 2)&#10;        if isinstance(contour_data, np.ndarray):&#10;            if len(contour_data.shape) == 3 and contour_data.shape[1] == 1:&#10;                # Already in correct format (N, 1, 2)&#10;                return contour_data&#10;            elif len(contour_data.shape) == 2:&#10;                # Convert from (N, 2) to (N, 1, 2)&#10;                return contour_data.reshape(-1, 1, 2)&#10;            else:&#10;                # Flatten and reshape&#10;                return contour_data.reshape(-1, 2).reshape(-1, 1, 2)&#10;        else:&#10;            # Handle list format - convert to numpy array&#10;            flat_points = []&#10;            for point in contour_data:&#10;                if isinstance(point, (list, tuple, np.ndarray)):&#10;                    # Handle nested structures like [[[x, y]]] or [[x, y]]&#10;                    while isinstance(point, (list, tuple, np.ndarray)) and len(point) == 1:&#10;                        point = point[0]&#10;                    if len(point) &gt;= 2:&#10;                        # Recursively flatten nested coordinates&#10;                        x, y = point[0], point[1]&#10;                        while isinstance(x, (list, tuple, np.ndarray)):&#10;                            x = x[0] if len(x) &gt; 0 else 0&#10;                        while isinstance(y, (list, tuple, np.ndarray)):&#10;                            y = y[0] if len(y) &gt; 0 else 0&#10;                        flat_points.append([float(x), float(y)])&#10;&#10;            if flat_points:&#10;                return np.array(flat_points, dtype=np.float32).reshape(-1, 1, 2)&#10;            else:&#10;                return np.array([], dtype=np.float32).reshape(0, 1, 2)&#10;&#10;    def get_main_contour_settings(self):&#10;        &quot;&quot;&quot;&#10;        Return the settings associated with the main contour.&#10;        If no settings are found, return an empty dictionary.&#10;        &quot;&quot;&quot;&#10;        if isinstance(self.contour, dict) and &quot;settings&quot; in self.contour:&#10;            return self.contour[&quot;settings&quot;]&#10;        return {}&#10;&#10;    @staticmethod&#10;    def serialize(workpiece):&#10;        def convert_ndarray_to_list(obj):&#10;            if isinstance(obj, np.ndarray):&#10;                if obj.ndim == 2 and obj.shape[1] == 2:&#10;                    obj = obj.reshape(-1, 1, 2)  # ✅ normalize before list conversion&#10;                return obj.tolist()&#10;            elif isinstance(obj, dict) and &quot;contour&quot; in obj:&#10;                contour = obj[&quot;contour&quot;]&#10;                if isinstance(contour, np.ndarray) and contour.ndim == 2 and contour.shape[1] == 2:&#10;                    contour = contour.reshape(-1, 1, 2)&#10;                return {&#10;                    &quot;contour&quot;: convert_ndarray_to_list(contour),&#10;                    &quot;settings&quot;: dict(obj.get(&quot;settings&quot;, {}))&#10;                }&#10;            elif isinstance(obj, list):&#10;                return [convert_ndarray_to_list(item) for item in obj]&#10;            return obj&#10;&#10;        # ✅ Handle dict contour directly&#10;        contour_data = convert_ndarray_to_list(workpiece.contour)&#10;&#10;        if isinstance(workpiece.sprayPattern, dict):&#10;            spray_pattern_dict = {&#10;                key: [convert_ndarray_to_list(seg) for seg in val]&#10;                for key, val in workpiece.sprayPattern.items()&#10;            }&#10;        else:&#10;            spray_pattern_dict = convert_ndarray_to_list(workpiece.sprayPattern)&#10;&#10;        workpiece.contour = contour_data&#10;        workpiece.sprayPattern = spray_pattern_dict&#10;        return workpiece.to_dict()&#10;&#10;    @staticmethod&#10;    def deserialize(data):&#10;        def convert_list_to_ndarray(obj):&#10;            if isinstance(obj, dict) and &quot;contour&quot; in obj:&#10;                arr = np.array(obj[&quot;contour&quot;], dtype=np.float32)&#10;&#10;                # ✅ Normalize shape to (N, 1, 2)&#10;                if arr.ndim == 1 and arr.shape[0] == 2:&#10;                    arr = arr.reshape(1, 1, 2)  # single point → (1, 1, 2)&#10;                elif arr.ndim == 2 and arr.shape[1] == 2:&#10;                    arr = arr.reshape(-1, 1, 2)  # (N, 2) → (N, 1, 2)&#10;&#10;                return {&#10;                    &quot;contour&quot;: arr,&#10;                    &quot;settings&quot;: obj.get(&quot;settings&quot;, {})&#10;                }&#10;&#10;            elif isinstance(obj, list):&#10;                return [convert_list_to_ndarray(item) for item in obj]&#10;&#10;            return obj&#10;&#10;        # ----- Main contour -----&#10;        raw_contour = data.get(GlueWorkpieceField.CONTOUR.value, [])&#10;&#10;        if isinstance(raw_contour, dict):&#10;            contour = convert_list_to_ndarray(raw_contour)&#10;        elif isinstance(raw_contour, list):&#10;            contour = [convert_list_to_ndarray(seg) for seg in raw_contour]&#10;        else:&#10;            contour = raw_contour  # unexpected type, leave as-is&#10;&#10;        # ----- Spray pattern -----&#10;        raw_spray_pattern = data.get(GlueWorkpieceField.SPRAY_PATTERN.value, {})&#10;        spray_pattern = {}&#10;&#10;        if isinstance(raw_spray_pattern, dict):&#10;            for key, pattern in raw_spray_pattern.items():&#10;                spray_pattern[key] = [convert_list_to_ndarray(seg) for seg in pattern]&#10;        else:&#10;            spray_pattern = raw_spray_pattern&#10;&#10;        # ----- Build workpiece -----&#10;        workpiece = GlueWorkpiece.from_dict(data)&#10;        workpiece.contour = contour&#10;        workpiece.sprayPattern = spray_pattern&#10;        return workpiece&#10;&#10;    def to_dict(self)-&gt; dict:&#10;        &quot;&quot;&quot;&#10;                Convert the Workpiece object into a dictionary representation.&#10;&#10;                Returns:&#10;                    dict: A dictionary containing the Workpiece's properties, suitable for serialization or storage.&#10;                &quot;&quot;&quot;&#10;        return {&#10;            GlueWorkpieceField.WORKPIECE_ID.value: self.workpieceId,&#10;            GlueWorkpieceField.NAME.value: self.name,&#10;            GlueWorkpieceField.DESCRIPTION.value: self.description,&#10;            GlueWorkpieceField.TOOL_ID.value: self.toolID.value,&#10;            GlueWorkpieceField.GRIPPER_ID.value: self.gripperID.value,&#10;            GlueWorkpieceField.GLUE_TYPE.value: self.glueType.value,&#10;            GlueWorkpieceField.PROGRAM.value: self.program.value,&#10;            GlueWorkpieceField.MATERIAL.value: self.material,&#10;            GlueWorkpieceField.CONTOUR.value: self.contour,&#10;            GlueWorkpieceField.OFFSET.value: self.offset,&#10;            GlueWorkpieceField.HEIGHT.value: self.height,&#10;            GlueWorkpieceField.GLUE_QTY.value: self.glueQty,&#10;            GlueWorkpieceField.SPRAY_WIDTH.value: self.sprayWidth,&#10;            GlueWorkpieceField.PICKUP_POINT.value: self.pickupPoint,&#10;            GlueWorkpieceField.SPRAY_PATTERN.value: self.sprayPattern,&#10;            GlueWorkpieceField.CONTOUR_AREA.value: self.contourArea,&#10;            GlueWorkpieceField.NOZZLES.value: self.nozzles&#10;&#10;        }&#10;&#10;    @staticmethod&#10;    def flatten_spray_pattern(obj):&#10;        &quot;&quot;&quot;&#10;             Flatten nested spray pattern lists into a single list.&#10;&#10;             Args:&#10;                 obj (list): The spray pattern (possibly nested) to be flattened.&#10;&#10;             Returns:&#10;                 list: A flattened list containing all points from the spray pattern.&#10;             &quot;&quot;&quot;&#10;        if isinstance(obj, list):&#10;            flat_obj = []&#10;            for item in obj:&#10;                if isinstance(item, list):&#10;                    flat_obj.extend(GlueWorkpiece.flatten_spray_pattern(item))&#10;                else:&#10;                    flat_obj.append(item)&#10;            return flat_obj&#10;        return [obj]&#10;&#10;    @staticmethod&#10;    def reshape_spray_pattern(obj):&#10;        &quot;&quot;&quot;&#10;        Reshape spray pattern list into list of (N, 1, 2) numpy arrays.&#10;&#10;        Args:&#10;            obj (list): The spray pattern, either a single contour or a list of contours.&#10;&#10;        Returns:&#10;            list: A list of numpy arrays representing the reshaped spray pattern contours.&#10;&#10;        Raises:&#10;            ValueError: If the spray pattern format is invalid or unrecognized.&#10;        &quot;&quot;&quot;&#10;        if not obj:&#10;            return []&#10;&#10;        # If it's a single contour, flatten and reshape it&#10;        if all(isinstance(pt, (list, np.ndarray)) and len(pt) == 2 for pt in obj):&#10;            grouped = np.array(obj, dtype=np.float32).reshape(-1, 1, 2)&#10;            return [grouped]&#10;&#10;        # If it's a list of contours&#10;        if isinstance(obj, list) and all(isinstance(c, list) for c in obj):&#10;            result = []&#10;            for contour in obj:&#10;                if not contour:&#10;                    continue&#10;                flat = GlueWorkpiece.flatten_spray_pattern(contour)&#10;                if all(isinstance(x, (int, float)) for x in flat):&#10;                    grouped = [[flat[i], flat[i + 1]] for i in range(0, len(flat), 2)]&#10;                elif all(isinstance(x, list) and len(x) == 2 for x in flat):&#10;                    grouped = flat&#10;                else:&#10;                    raise ValueError(f&quot;Invalid spray pattern shape: {flat}&quot;)&#10;                result.append(np.array(grouped, dtype=np.float32).reshape(-1, 1, 2))&#10;            return result&#10;&#10;        raise ValueError(f&quot;Unknown spray pattern format: {obj}&quot;)&#10;&#10;    @staticmethod&#10;    def from_dict(data: dict):&#10;        &quot;&quot;&quot;&#10;        Deserialize a dictionary into a Workpiece object.&#10;&#10;        Args:&#10;          data (dict): A dictionary representation of a Workpiece.&#10;&#10;        Returns:&#10;          GlueWorkpiece: The reconstructed Workpiece object.&#10;        &quot;&quot;&quot;&#10;        return GlueWorkpiece(&#10;            workpieceId=data[GlueWorkpieceField.WORKPIECE_ID.value],&#10;            name=data[GlueWorkpieceField.NAME.value],&#10;            description=data[GlueWorkpieceField.DESCRIPTION.value],&#10;            toolID=ToolID(data[GlueWorkpieceField.TOOL_ID.value]),&#10;            gripperID=Gripper(data[GlueWorkpieceField.GRIPPER_ID.value]),&#10;            glueType=GlueType(data[GlueWorkpieceField.GLUE_TYPE.value]),&#10;            program=Program(data[GlueWorkpieceField.PROGRAM.value]),&#10;            material=data[GlueWorkpieceField.MATERIAL.value],&#10;            contour=data[GlueWorkpieceField.CONTOUR.value],&#10;            offset=data[GlueWorkpieceField.OFFSET.value],&#10;            height=data.get(GlueWorkpieceField.HEIGHT.value, 4),&#10;            pickupPoint=data.get(GlueWorkpieceField.PICKUP_POINT.value, None),&#10;            nozzles=data.get(GlueWorkpieceField.NOZZLES.value, []),  # Setting nozzles to empty list if missing&#10;            contourArea=data[GlueWorkpieceField.CONTOUR_AREA.value],&#10;            glueQty=data[GlueWorkpieceField.GLUE_QTY.value],&#10;            sprayWidth=data[GlueWorkpieceField.SPRAY_WIDTH.value],&#10;            sprayPattern=data.get(GlueWorkpieceField.SPRAY_PATTERN.value, []),&#10;&#10;            # Setting spray pattern to empty list if missing&#10;        )&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="/tmp/test_robot_repo.py">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="/tmp/test_robot_repo.py" />
            </PendingDiffInfo>
          </value>
        </entry>
      </map>
    </option>
  </component>
</project>